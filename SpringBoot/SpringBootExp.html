<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link href="../style.css" rel="stylesheet" type="text/css" >
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11/build/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>


</head>
<body>

<h1 id="spring-boot-interview-questions">Spring Boot Interview Questions</h1>
<hr>
<h2 id="table-of-contents">Table of Contents</h2>
<h3 id="section-1-spring-boot-fundamentals">Section 1: Spring Boot Fundamentals</h3>
<ul>
    <li>Introduction to Spring Boot</li>
    <li>Core Features and Benefits</li>
    <li>Spring Boot Architecture</li>
    <li>Spring Boot vs Traditional Spring</li>
    <li>Starter Dependencies</li>
    <li>Auto-Configuration</li>
</ul>
<h3 id="section-2-spring-boot-configuration">Section 2: Spring Boot Configuration</h3>
<ul>
    <li>Properties Files</li>
    <li>YAML Configuration</li>
    <li>Profiles</li>
    <li>External Configuration</li>
    <li>Configuration Properties</li>
    <li>Logging Configuration</li>
</ul>
<h3 id="section-3-spring-boot-core-components">Section 3: Spring Boot Core Components</h3>
<ul>
    <li>Spring Boot Annotations</li>
    <li>Spring Boot Actuator</li>
    <li>Embedded Servers</li>
    <li>Spring Boot CLI</li>
    <li>Spring Boot DevTools</li>
    <li>Command Line Runner and Application Runner</li>
</ul>
<h3 id="section-4-database-access-with-spring-boot">Section 4: Database Access with Spring Boot</h3>
<ul>
    <li>Spring Data JPA</li>
    <li>Database Configuration</li>
    <li>Transaction Management</li>
    <li>ORM Integration</li>
    <li>NoSQL Support</li>
    <li>Multiple Data Sources</li>
</ul>
<h3 id="section-5-building-rest-apis-with-spring-boot">Section 5: Building REST APIs with Spring Boot</h3>
<ul>
    <li>REST Controllers</li>
    <li>Request Mapping</li>
    <li>Request/Response Handling</li>
    <li>Exception Handling</li>
    <li>Validation</li>
    <li>Versioning REST APIs</li>
</ul>
<h3 id="section-6-spring-boot-security">Section 6: Spring Boot Security</h3>
<ul>
    <li>Authentication Methods</li>
    <li>Authorization</li>
    <li>OAuth 2.0 Integration</li>
    <li>JWT Implementation</li>
    <li>Security Best Practices</li>
    <li>Custom Security Configurations</li>
</ul>
<h3 id="section-7-testing-in-spring-boot">Section 7: Testing in Spring Boot</h3>
<ul>
    <li>Unit Testing</li>
    <li>Integration Testing</li>
    <li>MockMVC</li>
    <li>TestRestTemplate</li>
    <li>Testing with Databases</li>
    <li>Test Slices</li>
</ul>
<h3 id="section-8-spring-boot-and-microservices">Section 8: Spring Boot and Microservices</h3>
<ul>
    <li>Microservices Architecture</li>
    <li>Service Discovery</li>
    <li>API Gateway</li>
    <li>Circuit Breaker Pattern</li>
    <li>Distributed Tracing</li>
    <li>Containerization with Docker</li>
</ul>
<h3 id="section-9-spring-boot-performance-and-monitoring">Section 9: Spring Boot Performance and Monitoring</h3>
<ul>
    <li>Performance Optimization</li>
    <li>Metrics Collection</li>
    <li>Health Checks</li>
    <li>Application Monitoring</li>
    <li>Caching Strategies</li>
    <li>JVM Tuning</li>
</ul>
<h3 id="section-10-advanced-spring-boot-topics">Section 10: Advanced Spring Boot Topics</h3>
<ul>
    <li>Event Handling</li>
    <li>WebSockets</li>
    <li>Reactive Programming</li>
    <li>Custom Auto-Configuration</li>
    <li>Spring Boot Admin</li>
    <li>Production Deployment Strategies</li>
</ul>
<h2 id="fundamentals-and-configuration">Fundamentals and Configuration</h2>
<hr>
<h2 id="section-1-spring-boot-fundamentals-1">Section 1: Spring Boot Fundamentals</h2>
<h3 id="1-what-is-spring-boot-and-what-problem-does-it-solve">1. What is Spring Boot and what problem does it solve?</h3>
<p><strong>Answer:</strong> Spring Boot is an extension of the Spring framework that eliminates the boilerplate configurations required for setting up a Spring application. It solves several problems:</p>
<ul>
    <li>Simplifies the bootstrapping and development of new Spring applications</li>
    <li>Provides opinionated &#39;starter&#39; dependencies to simplify build configuration</li>
    <li>Embeds Tomcat, Jetty, or Undertow directly (no need to deploy WAR files)</li>
    <li>Provides production-ready features like metrics, health checks, and externalized configuration</li>
    <li>Requires no XML configuration</li>
    <li>Facilitates microservices architecture with minimal setup</li>
</ul>
<p>Spring Boot essentially addresses the complexity of configuration in traditional Spring applications, making development faster and deployment easier.</p>
<h3 id="2-what-are-the-key-features-of-spring-boot">2. What are the key features of Spring Boot?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><strong>Auto-configuration</strong>: Automatically configures your application based on the dependencies present in the classpath</li>
    <li><strong>Starter dependencies</strong>: Simplified dependency management</li>
    <li><strong>Embedded server support</strong>: No need for external deployment of applications</li>
    <li><strong>Spring Boot Actuator</strong>: Provides production-ready features to monitor and manage applications</li>
    <li><strong>Spring Boot CLI</strong>: Command Line Interface to run and test Spring Boot applications from the command prompt</li>
    <li><strong>Spring Initializer</strong>: Web tool and CLI tool to quickly bootstrap application</li>
    <li><strong>Externalized Configuration</strong>: Easy application configuration using properties files, YAML files, environment variables, and command-line arguments</li>
    <li><strong>Production-ready metrics</strong>: Built-in metrics, health checks, and external configuration</li>
    <li><strong>Spring Boot DevTools</strong>: Additional development-time features like automatic restart and live reload</li>
</ul>
<h3 id="3-explain-spring-boots-auto-configuration-mechanism">3. Explain Spring Boot&#39;s auto-configuration mechanism.</h3>
<p><strong>Answer:</strong> Spring Boot&#39;s auto-configuration is a feature that automatically configures a Spring application based on the dependencies present in the classpath. The process works as follows:</p>
<ol>
    <li>Spring Boot detects the libraries available on the classpath</li>
    <li>It predicts what you&#39;re trying to build (web app, data application, etc.)</li>
    <li>It automatically configures beans that you are likely to need</li>
    <li>The auto-configuration is smart enough to step back if you begin to define your own configurations</li>
</ol>
<p>Auto-configuration is implemented using the <code>@EnableAutoConfiguration</code> or <code>@SpringBootApplication</code> annotation. Under the hood, it uses conditional annotations like <code>@ConditionalOnClass</code>, <code>@ConditionalOnMissingBean</code>, etc., to determine when to apply specific configurations.</p>
<p>For example, if HSQLDB is on your classpath, and you have not manually configured any database connection beans, then Spring Boot auto-configures an in-memory database.</p>
<h3 id="4-what-is-the-difference-between-spring-and-spring-boot">4. What is the difference between Spring and Spring Boot?</h3>
<p><strong>Answer:</strong></p>
<table>
    <thead>
    <tr>
        <th>Spring</th>
        <th>Spring Boot</th>
    </tr>
    </thead>
    <tbody><tr>
        <td>Spring is a comprehensive framework for Java application development</td>
        <td>Spring Boot is an extension of Spring that simplifies configuration and setup</td>
    </tr>
    <tr>
        <td>Requires manual configuration for most parts</td>
        <td>Provides auto-configuration based on classpath dependencies</td>
    </tr>
    <tr>
        <td>XML configuration or Java configuration is needed</td>
        <td>Minimal or zero configuration required</td>
    </tr>
    <tr>
        <td>Requires explicit dependency declaration</td>
        <td>Provides starter dependencies that implicitly include required dependencies</td>
    </tr>
    <tr>
        <td>Manual server configuration needed</td>
        <td>Embedded server comes pre-configured</td>
    </tr>
    <tr>
        <td>Deployment requires WAR files</td>
        <td>Can be deployed as standalone JAR</td>
    </tr>
    <tr>
        <td>Requires manual setup for initial project</td>
        <td>Provides Spring Initializer to quickly bootstrap applications</td>
    </tr>
    <tr>
        <td>No built-in production-ready features</td>
        <td>Includes Actuator for production metrics and monitoring</td>
    </tr>
    </tbody></table>
<h3 id="5-what-is-a-spring-boot-starter-name-some-important-starters">5. What is a Spring Boot Starter? Name some important starters.</h3>
<p><strong>Answer:</strong> A Spring Boot Starter is a set of convenient dependency descriptors that you can include in your application to get required dependencies for a specific functionality. Starters significantly reduce the amount of manual dependency configuration needed.</p>
<p>Important starters include:</p>
<ol>
    <li><strong>spring-boot-starter</strong>: Core starter including auto-configuration support, logging, and YAML</li>
    <li><strong>spring-boot-starter-web</strong>: For building web applications, including RESTful applications using Spring MVC</li>
    <li><strong>spring-boot-starter-data-jpa</strong>: For using Spring Data JPA with Hibernate</li>
    <li><strong>spring-boot-starter-security</strong>: For using Spring Security</li>
    <li><strong>spring-boot-starter-test</strong>: For testing Spring Boot applications</li>
    <li><strong>spring-boot-starter-actuator</strong>: For monitoring and managing application</li>
    <li><strong>spring-boot-starter-jdbc</strong>: For JDBC operations with HikariCP connection pool</li>
    <li><strong>spring-boot-starter-thymeleaf</strong>: For building MVC web applications using Thymeleaf views</li>
    <li><strong>spring-boot-starter-mail</strong>: For sending email</li>
    <li><strong>spring-boot-starter-websocket</strong>: For building WebSocket applications</li>
</ol>
<h3 id="6-what-is-the-importance-of-the-springbootapplication-annotation">6. What is the importance of the @SpringBootApplication annotation?</h3>
<p><strong>Answer:</strong> <code>@SpringBootApplication</code> is a convenience annotation that combines three essential annotations:</p>
<ol>
    <li><p><strong>@Configuration</strong>: Tags the class as a source of bean definitions for the application context.</p>
    </li>
    <li><p><strong>@EnableAutoConfiguration</strong>: Enables Spring Boot&#39;s auto-configuration mechanism, which attempts to configure beans based on the classpath.</p>
    </li>
    <li><p><strong>@ComponentScan</strong>: Tells Spring to scan for components, configurations, and services in the specified package and its sub-packages.</p>
    </li>
</ol>
<p>By using <code>@SpringBootApplication</code>, you apply all three of these annotations with their default attributes, simplifying your configuration and reducing boilerplate code. It&#39;s typically applied to the main class of a Spring Boot application.</p>
<pre><code class="language-java">@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
</code></pre>
<h3 id="7-how-does-spring-boot-work-internally">7. How does Spring Boot work internally?</h3>
<p><strong>Answer:</strong> Spring Boot works through several key mechanisms:</p>
<ol>
    <li><p><strong>Entry Point</strong>: The process starts with the <code>SpringApplication.run()</code> method that bootstraps the entire application.</p>
    </li>
    <li><p><strong>Application Context Creation</strong>: Spring Boot creates an appropriate <code>ApplicationContext</code> (e.g., <code>AnnotationConfigServletWebServerApplicationContext</code> for web applications).</p>
    </li>
    <li><p><strong>Auto-Configuration</strong>: Spring Boot scans for auto-configuration classes in the classpath, typically in the <code>spring-boot-autoconfigure</code> JAR. These classes contain conditional configurations that are applied based on:</p>
        <ul>
            <li>The presence of specific classes in the classpath</li>
            <li>The absence of user-defined beans</li>
            <li>Specific properties being set</li>
        </ul>
    </li>
    <li><p><strong>Component Scanning</strong>: Spring Boot scans for components, services, configurations in the application package and its sub-packages.</p>
    </li>
    <li><p><strong>Property Resolution</strong>: It loads properties from various sources (application.properties, application.yml, environment variables, command-line arguments) with a well-defined precedence order.</p>
    </li>
    <li><p><strong>Bean Instantiation and Initialization</strong>: Spring Boot creates beans defined in configuration classes or detected through component scanning.</p>
    </li>
    <li><p><strong>Embedded Server Initialization</strong>: For web applications, Spring Boot initializes and starts an embedded server (Tomcat, Jetty, or Undertow).</p>
    </li>
    <li><p><strong>Post-Initialization Hooks</strong>: Spring Boot executes any registered <code>CommandLineRunner</code> or <code>ApplicationRunner</code> beans.</p>
    </li>
</ol>
<h3 id="8-explain-the-spring-boot-architecture">8. Explain the Spring Boot architecture.</h3>
<p><strong>Answer:</strong> Spring Boot follows a layered architecture that can be described as:</p>
<ol>
    <li><p><strong>Presentation Layer</strong>: Contains REST endpoints, controllers, and view templates that handle HTTP requests and responses.</p>
    </li>
    <li><p><strong>Business Layer</strong>: Contains service classes that implement business logic, validation rules, and workflow.</p>
    </li>
    <li><p><strong>Persistence Layer</strong>: Contains repositories and data access objects that interact with databases.</p>
    </li>
    <li><p><strong>Database Layer</strong>: The actual database used by the application.</p>
    </li>
</ol>
<p>Spring Boot enhances this architecture with:</p>
<ul>
    <li><p><strong>Auto-configuration Layer</strong>: Automatically configures beans based on the classpath and existing configuration.</p>
    </li>
    <li><p><strong>Spring Boot Starters</strong>: Pre-packaged dependency descriptors for different technologies.</p>
    </li>
    <li><p><strong>Spring Boot Actuator</strong>: Adds production-ready features like monitoring, metrics, and management endpoints.</p>
    </li>
    <li><p><strong>Embedded Server</strong>: Contains a pre-configured server (Tomcat, Jetty, or Undertow) for running web applications.</p>
    </li>
    <li><p><strong>Spring Core Container</strong>: The IoC container responsible for creating, configuring, and managing beans.</p>
    </li>
</ul>
<p>The architecture is designed to be flexible, allowing developers to focus on application code rather than infrastructure setup.</p>
<h3 id="9-what-are-the-limitations-or-disadvantages-of-spring-boot">9. What are the limitations or disadvantages of Spring Boot?</h3>
<p><strong>Answer:</strong>
    Despite its benefits, Spring Boot has some limitations:</p>
<ol>
    <li><p><strong>Learning Curve</strong>: Understanding the auto-configuration magic can be challenging for beginners.</p>
    </li>
    <li><p><strong>Legacy System Integration</strong>: It can be challenging to integrate Spring Boot with legacy systems or databases.</p>
    </li>
    <li><p><strong>Size Overhead</strong>: Spring Boot applications can have a larger deployment footprint due to embedded servers and included dependencies.</p>
    </li>
    <li><p><strong>Configuration Complexity</strong>: While auto-configuration simplifies setup, troubleshooting configuration issues can be complex because of the &quot;magic&quot; happening behind the scenes.</p>
    </li>
    <li><p><strong>Version Compatibility</strong>: Upgrading Spring Boot versions may require adjustments due to changes in auto-configuration behavior.</p>
    </li>
    <li><p><strong>Control Reduction</strong>: The opinionated approach means less control over specific configurations unless explicitly overridden.</p>
    </li>
    <li><p><strong>Build Time</strong>: Initial build time can be slower due to the number of dependencies and processing required.</p>
    </li>
    <li><p><strong>Memory Consumption</strong>: Spring Boot applications typically consume more memory than leaner frameworks like Micronaut or Quarkus.</p>
    </li>
    <li><p><strong>Startup Time</strong>: Traditional Spring Boot applications can have slower startup times compared to native compiled applications.</p>
    </li>
    <li><p><strong>Unnecessary Dependencies</strong>: Spring Boot starters might include more dependencies than actually needed for your specific use case.</p>
    </li>
</ol>
<h3 id="10-what-is-spring-boot-actuator-and-why-is-it-used">10. What is Spring Boot Actuator and why is it used?</h3>
<p><strong>Answer:</strong> Spring Boot Actuator is a sub-project of Spring Boot that adds production-ready features to applications. It provides built-in endpoints that let you monitor and interact with your application.</p>
<p><strong>Key features include:</strong></p>
<ol>
    <li><p><strong>Health Checks</strong>: The <code>/health</code> endpoint provides basic health information about your application.</p>
    </li>
    <li><p><strong>Metrics</strong>: The <code>/metrics</code> endpoint provides information about memory usage, garbage collection, web requests, etc.</p>
    </li>
    <li><p><strong>Environment Information</strong>: The <code>/env</code> endpoint provides access to the current environment properties.</p>
    </li>
    <li><p><strong>Logging</strong>: The <code>/loggers</code> endpoint allows viewing and modifying logging configuration at runtime.</p>
    </li>
    <li><p><strong>Thread Dump</strong>: The <code>/threaddump</code> endpoint provides a thread dump of the application.</p>
    </li>
    <li><p><strong>HTTP Tracing</strong>: The <code>/httptrace</code> endpoint provides HTTP trace information.</p>
    </li>
    <li><p><strong>Management</strong>: Endpoints for shutdown, configuration properties changes, etc.</p>
    </li>
</ol>
<p><strong>Usage and Benefits:</strong></p>
<ul>
    <li>Monitoring and managing applications in production</li>
    <li>Integrating with monitoring systems</li>
    <li>Troubleshooting and diagnostics</li>
    <li>Getting insights into the running application</li>
    <li>No need to write additional code for common operational features</li>
</ul>
<p>To use Actuator, you simply add the <code>spring-boot-starter-actuator</code> dependency to your project, and Spring Boot configures the endpoints automatically.</p>
<h2 id="section-2-spring-boot-configuration-1">Section 2: Spring Boot Configuration</h2>
<h3 id="11-what-are-the-different-ways-to-configure-a-spring-boot-application">11. What are the different ways to configure a Spring Boot application?</h3>
<p><strong>Answer:</strong> Spring Boot offers multiple ways to configure applications:</p>
<ol>
    <li><p><strong>application.properties</strong>: Simple key-value pair configurations.</p>
        <pre><code class="language-properties">server.port=8080
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
</code></pre>
    </li>
    <li><p><strong>application.yml</strong>: YAML configuration with hierarchical format.</p>
        <pre><code class="language-yaml">server:
  port: 8080
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
</code></pre>
    </li>
    <li><p><strong>Environment Variables</strong>: System environment variables override properties files.</p>
        <pre><code class="language-bash">export SERVER_PORT=8080
</code></pre>
    </li>
    <li><p><strong>Command Line Arguments</strong>: Pass arguments when starting the application.</p>
        <pre><code class="language-bash">java -jar app.jar --server.port=8080
</code></pre>
    </li>
    <li><p><strong>@Configuration Classes</strong>: Java-based configuration.</p>
        <pre><code class="language-java">@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}
</code></pre>
    </li>
    <li><p><strong>Cloud Configuration</strong>: Using Spring Cloud Config Server for centralized configuration.</p>
    </li>
    <li><p><strong>Profile-specific Properties</strong>: Like <code>application-dev.properties</code> or <code>application-prod.yml</code>.</p>
    </li>
    <li><p><strong>OS Environment Variables</strong>: Using OS environment variables.</p>
    </li>
    <li><p><strong>Java System Properties</strong>: Using <code>-D</code> flag when running the application.</p>
    </li>
</ol>
<p>Spring Boot follows a strict order of precedence when loading properties from different sources, with command-line arguments having the highest priority.</p>
<h3 id="12-how-are-properties-loaded-in-spring-boot">12. How are properties loaded in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot loads properties in a specific order of precedence (from highest to lowest):</p>
<ol>
    <li><p><strong>Command-line arguments</strong></p>
        <pre><code class="language-bash">java -jar app.jar --server.port=8080
</code></pre>
    </li>
    <li><p><strong>JNDI attributes from <code>java:comp/env</code></strong></p>
    </li>
    <li><p><strong>Java System properties (<code>System.getProperties()</code>)</strong></p>
        <pre><code class="language-bash">java -Dserver.port=8080 -jar app.jar
</code></pre>
    </li>
    <li><p><strong>OS environment variables</strong></p>
        <pre><code class="language-bash">export SERVER_PORT=8080
</code></pre>
    </li>
    <li><p><strong>Profile-specific application properties outside of packaged jar</strong></p>
        <pre><code>application-{profile}.properties or application-{profile}.yml
</code></pre>
    </li>
    <li><p><strong>Profile-specific application properties packaged inside jar</strong></p>
        <pre><code>application-{profile}.properties or application-{profile}.yml
</code></pre>
    </li>
    <li><p><strong>Application properties outside of packaged jar</strong></p>
        <pre><code>application.properties or application.yml
</code></pre>
    </li>
    <li><p><strong>Application properties packaged inside jar</strong></p>
        <pre><code>application.properties or application.yml
</code></pre>
    </li>
    <li><p><strong>@PropertySource annotations on your @Configuration classes</strong></p>
    </li>
    <li><p><strong>Default properties (specified by SpringApplication.setDefaultProperties)</strong></p>
    </li>
</ol>
<p>This order ensures that properties defined at a higher level override those defined at a lower level, allowing for flexible configuration across different environments.</p>
<h3 id="13-what-is-the-difference-between-an-embedded-container-and-a-war-deployment-in-spring-boot">13. What is the difference between an embedded container and a WAR deployment in Spring Boot?</h3>
<p><strong>Answer:</strong></p>
<table>
    <thead>
    <tr>
        <th>Embedded Container</th>
        <th>WAR Deployment</th>
    </tr>
    </thead>
    <tbody><tr>
        <td>Application and server are packaged together as a single executable JAR</td>
        <td>Application is packaged as a WAR file that needs to be deployed to an external server</td>
    </tr>
    <tr>
        <td>Self-contained and easy to deploy</td>
        <td>Depends on an external application server</td>
    </tr>
    <tr>
        <td>Uses embedded servers like Tomcat, Jetty, or Undertow</td>
        <td>Uses external application servers like Tomcat, WebSphere, JBoss, etc.</td>
    </tr>
    <tr>
        <td>Default approach in Spring Boot</td>
        <td>Requires additional configuration in Spring Boot</td>
    </tr>
    <tr>
        <td>Typical packaging: <code>jar</code> in Maven/Gradle</td>
        <td>Packaging: <code>war</code> in Maven/Gradle</td>
    </tr>
    <tr>
        <td>Main class needs <code>@SpringBootApplication</code></td>
        <td>Main class needs to extend <code>SpringBootServletInitializer</code></td>
    </tr>
    <tr>
        <td>Runs using <code>java -jar application.jar</code></td>
        <td>Deployed to server using server&#39;s deployment tools</td>
    </tr>
    <tr>
        <td>Good for microservices and cloud deployments</td>
        <td>Often used in traditional enterprise environments</td>
    </tr>
    <tr>
        <td>Simplified deployment process</td>
        <td>More complex deployment process</td>
    </tr>
    <tr>
        <td>Limited to the embedded server&#39;s capabilities</td>
        <td>Can leverage specific features of the external server</td>
    </tr>
    </tbody></table>
<p>To create a WAR deployment in Spring Boot:</p>
<pre><code class="language-java">@SpringBootApplication
public class Application extends SpringBootServletInitializer {
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(Application.class);
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<h3 id="14-how-do-you-externalize-configuration-in-spring-boot">14. How do you externalize configuration in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot provides several ways to externalize configuration:</p>
<ol>
    <li><p><strong>Properties Files</strong>: Create an <code>application.properties</code> or <code>application.yml</code> file in the following locations:</p>
        <ul>
            <li>Inside the application JAR in <code>/config</code> subdirectory</li>
            <li>Inside the application JAR at the root</li>
            <li>In a <code>/config</code> subdirectory of the current directory</li>
            <li>In the current directory</li>
        </ul>
    </li>
    <li><p><strong>Profile-Specific Properties</strong>: Create files like <code>application-{profile}.properties</code> to load environment-specific configurations.</p>
    </li>
    <li><p><strong>Environment Variables</strong>: Spring Boot automatically converts environment variables to properties.</p>
        <pre><code class="language-bash"># Environment variable
export APP_CONFIG_DATABASE_HOST=localhost

# Equivalent property
app.config.database.host=localhost
</code></pre>
    </li>
    <li><p><strong>Command Line Arguments</strong>:</p>
        <pre><code class="language-bash">java -jar myapp.jar --server.port=9090 --spring.profiles.active=prod
</code></pre>
    </li>
    <li><p><strong>Cloud Configuration</strong>: Use Spring Cloud Config for centralized configuration management.</p>
    </li>
    <li><p><strong>@ConfigurationProperties</strong>: Bind externalized properties to Java objects.</p>
        <pre><code class="language-java">@ConfigurationProperties(prefix = &quot;mail&quot;)
public class MailProperties {
    private String host;
    private int port;
    // getters and setters
}
</code></pre>
    </li>
    <li><p><strong>@Value Annotation</strong>: Inject specific properties into beans.</p>
        <pre><code class="language-java">@Value(&quot;${server.port}&quot;)
private int serverPort;
</code></pre>
    </li>
    <li><p><strong>PropertySource Annotation</strong>: Load properties from custom locations.</p>
        <pre><code class="language-java">@PropertySource(&quot;classpath:custom.properties&quot;)
</code></pre>
    </li>
</ol>
<p>These approaches allow for flexible configuration that can change between environments without recompiling the application.</p>
<h3 id="15-what-are-spring-boot-profiles-and-how-do-you-use-them">15. What are Spring Boot profiles and how do you use them?</h3>
<p><strong>Answer:</strong> Spring Boot profiles provide a way to segregate parts of your application configuration and make it available only in specific environments. They allow you to have different configurations for different environments like development, testing, and production.</p>
<p><strong>How to define profiles:</strong></p>
<ol>
    <li><p><strong>In properties files</strong>:</p>
        <ul>
            <li>Create profile-specific property files: <code>application-dev.properties</code>, <code>application-prod.properties</code></li>
            <li>Properties in these files override the ones in the default <code>application.properties</code></li>
        </ul>
    </li>
    <li><h2 id="in-yaml-files-yaml--common-properties-spring---application-----name-myapp"><strong>In YAML files</strong>:
        ```yaml
        # Common properties
        spring:
        application:
        name: myapp</h2>
        <h1 id="development-profile">Development profile</h1>
        <h2 id="spring---config-----activate-------on-profile-dev---datasource-----url-jdbch2memtestdb">spring:
            config:
            activate:
            on-profile: dev
            datasource:
            url: jdbc:h2:mem:testdb</h2>
        <h1 id="production-profile">Production profile</h1>
        <p>spring:
            config:
            activate:
            on-profile: prod
            datasource:
            url: jdbc:mysql://localhost/mydb</p>
        <pre><code>
</code></pre>
    </li>
    <li><p><strong>In Java configuration</strong>:</p>
        <pre><code class="language-java">@Configuration
@Profile(&quot;dev&quot;)
public class DevConfig {
    @Bean
    public DataSource dataSource() {
        // development data source
    }
}

@Configuration
@Profile(&quot;prod&quot;)
public class ProdConfig {
    @Bean
    public DataSource dataSource() {
        // production data source
    }
}
</code></pre>
    </li>
</ol>
<p><strong>How to activate profiles:</strong></p>
<ol>
    <li><p><strong>In application.properties/yml</strong>:</p>
        <pre><code class="language-properties">spring.profiles.active=dev,mysql
</code></pre>
    </li>
    <li><p><strong>Command line arguments</strong>:</p>
        <pre><code class="language-bash">java -jar app.jar --spring.profiles.active=prod
</code></pre>
    </li>
    <li><p><strong>Environment variable</strong>:</p>
        <pre><code class="language-bash">export SPRING_PROFILES_ACTIVE=prod
</code></pre>
    </li>
    <li><p><strong>Programmatically</strong>:</p>
        <pre><code class="language-java">SpringApplication app = new SpringApplication(MyApp.class);
app.setAdditionalProfiles(&quot;prod&quot;);
app.run(args);
</code></pre>
    </li>
</ol>
<p>Profiles help organize configuration across various environments and make applications portable between different deployment scenarios.</p>
<h3 id="16-how-do-you-set-custom-properties-in-spring-boot">16. How do you set custom properties in Spring Boot?</h3>
<p><strong>Answer:</strong> There are several ways to set custom properties in Spring Boot:</p>
<ol>
    <li><p><strong>In application.properties</strong>:</p>
        <pre><code class="language-properties"># Custom properties
app.name=My Spring Application
app.description=A description of my application
app.api.version=v1
</code></pre>
    </li>
    <li><p><strong>In application.yml</strong>:</p>
        <pre><code class="language-yaml">app:
  name: My Spring Application
  description: A description of my application
  api:
    version: v1
</code></pre>
    </li>
    <li><p><strong>Using @Value annotation</strong>:</p>
        <pre><code class="language-java">@RestController
public class MyController {
    @Value(&quot;${app.name}&quot;)
    private String appName;

    @Value(&quot;${app.api.version}&quot;)
    private String apiVersion;

    @GetMapping(&quot;/info&quot;)
    public String getInfo() {
        return appName + &quot; - &quot; + apiVersion;
    }
}
</code></pre>
    </li>
    <li><p><strong>Using @ConfigurationProperties</strong>:</p>
        <pre><code class="language-java">@Component
@ConfigurationProperties(prefix = &quot;app&quot;)
public class ApplicationProperties {
    private String name;
    private String description;
    private Api api = new Api();

    // getters and setters

    public static class Api {
        private String version;
        // getters and setters
    }
}
</code></pre>
    </li>
    <li><p><strong>Environment class</strong>:</p>
        <pre><code class="language-java">@RestController
public class ConfigController {
    @Autowired
    private Environment env;

    @GetMapping(&quot;/config&quot;)
    public String getConfig() {
        return env.getProperty(&quot;app.name&quot;);
    }
}
</code></pre>
    </li>
    <li><p><strong>Custom property source</strong>:</p>
        <pre><code class="language-java">@Configuration
@PropertySource(&quot;classpath:custom.properties&quot;)
public class AppConfig {
    // configuration
}
</code></pre>
    </li>
    <li><p><strong>Command-line overrides</strong>:</p>
        <pre><code class="language-bash">java -jar myapp.jar --app.name=&quot;Custom App Name&quot;
</code></pre>
    </li>
</ol>
<p>The most common approach for structured properties is using <code>@ConfigurationProperties</code> as it provides type-safety, nested properties, and validation capabilities.</p>
<h3 id="17-what-is-relaxed-binding-in-spring-boot">17. What is relaxed binding in Spring Boot?</h3>
<p><strong>Answer:</strong> Relaxed binding is a feature in Spring Boot that allows for flexible binding of properties to <code>@ConfigurationProperties</code> beans. It&#39;s &quot;relaxed&quot; because it&#39;s not strict about the exact format or case of property names.</p>
<p>With relaxed binding, the following property formats are all equivalent and will bind to a Java property named <code>databaseUrl</code>:</p>
<ol>
    <li><strong>Standard camel case</strong>: <code>database-url</code> (recommended for <code>.properties</code> and <code>.yml</code> files)</li>
    <li><strong>Kebab case</strong>: <code>database-url</code> (recommended for use in <code>.properties</code> and <code>.yml</code> files)</li>
    <li><strong>Underscore notation</strong>: <code>database_url</code> (alternative format for <code>.properties</code> and <code>.yml</code> files)</li>
    <li><strong>Upper case format</strong>: <code>DATABASE_URL</code> (recommended when using system environment variables)</li>
</ol>
<p><strong>Example:</strong></p>
<p>Java class with <code>@ConfigurationProperties</code>:</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;mail&quot;)
public class MailProperties {
    private String hostName;  // Can be bound from any of the below formats
    // getters and setters
}
</code></pre>
<p>Any of these property definitions will bind to the <code>hostName</code> field:</p>
<pre><code class="language-properties"># In application.properties
mail.host-name=smtp.example.com
mail.hostname=smtp.example.com
mail.hostName=smtp.example.com
mail.HOST_NAME=smtp.example.com
</code></pre>
<pre><code class="language-yaml"># In application.yml
mail:
  host-name: smtp.example.com
  # OR
  hostname: smtp.example.com
  # OR
  hostName: smtp.example.com
  # OR
  HOST_NAME: smtp.example.com
</code></pre>
<pre><code class="language-bash"># Environment variable
export MAIL_HOST_NAME=smtp.example.com
</code></pre>
<p>This flexibility allows for seamless integration across different environments and configuration styles without requiring exact matches between property names and Java field names.</p>
<h3 id="18-what-is-the-difference-between-value-and-configurationproperties-annotations">18. What is the difference between @Value and @ConfigurationProperties annotations?</h3>
<p><strong>Answer:</strong></p>
<table>
    <thead>
    <tr>
        <th>Feature</th>
        <th>@Value</th>
        <th>@ConfigurationProperties</th>
    </tr>
    </thead>
    <tbody><tr>
        <td><strong>Purpose</strong></td>
        <td>Inject single property values</td>
        <td>Bind grouped properties to structured objects</td>
    </tr>
    <tr>
        <td><strong>Type safety</strong></td>
        <td>Limited type conversion</td>
        <td>Full type safety with conversion and validation</td>
    </tr>
    <tr>
        <td><strong>Relaxed binding</strong></td>
        <td>No</td>
        <td>Yes (supports various formats like kebab-case, camel-case)</td>
    </tr>
    <tr>
        <td><strong>Meta-data support</strong></td>
        <td>No</td>
        <td>Yes (supports JavaDoc, default values, etc.)</td>
    </tr>
    <tr>
        <td><strong>Complex structures</strong></td>
        <td>Difficult to map to arrays and complex types</td>
        <td>Easily maps to POJOs, Lists, Maps, etc.</td>
    </tr>
    <tr>
        <td><strong>Validation</strong></td>
        <td>Manual validation needed</td>
        <td>Supports JSR-303 Bean Validation (<code>@Valid</code>)</td>
    </tr>
    <tr>
        <td><strong>Syntax</strong></td>
        <td><code>@Value(&quot;${property.name}&quot;)</code></td>
        <td><code>@ConfigurationProperties(prefix = &quot;prefix&quot;)</code></td>
    </tr>
    </tbody></table>
<p><strong>@Value example:</strong></p>
<pre><code class="language-java">@Component
public class AppSettings {
    @Value(&quot;${app.name}&quot;)
    private String appName;

    @Value(&quot;${app.timeout:30}&quot;)  // Default value of 30
    private int timeout;

    @Value(&quot;${app.servers}&quot;)
    private List&lt;String&gt; servers;  // Requires special handling
}
</code></pre>
<p><strong>@ConfigurationProperties example:</strong></p>
<pre><code class="language-java">@Component
@ConfigurationProperties(prefix = &quot;app&quot;)
@Validated
public class AppSettings {
    private String name;

    private int timeout = 30;  // Default value

    private List&lt;String&gt; servers = new ArrayList&lt;&gt;();  // Easy list handling

    @NotEmpty  // Validation
    private Map&lt;String, String&gt; additionalHeaders = new HashMap&lt;&gt;();

    // Nested properties
    private Security security = new Security();

    public static class Security {
        private boolean enabled;
        private String tokenHeader;
        // getters and setters
    }

    // getters and setters
}
</code></pre>
<p><strong>When to use which:</strong></p>
<ul>
    <li>Use <code>@Value</code> for simple property injection, especially when you need just a few values from different sections</li>
    <li>Use <code>@ConfigurationProperties</code> when working with related properties that form a logical group or when you need validation and more complex mapping</li>
</ul>
<h3 id="19-how-can-you-change-the-default-port-in-spring-boot">19. How can you change the default port in Spring Boot?</h3>
<p><strong>Answer:</strong> There are several ways to change the default port (8080) in a Spring Boot application:</p>
<ol>
    <li><p><strong>In application.properties</strong>:</p>
        <pre><code class="language-properties">server.port=9090
</code></pre>
    </li>
    <li><p><strong>In application.yml</strong>:</p>
        <pre><code class="language-yaml">server:
  port: 9090
</code></pre>
    </li>
    <li><p><strong>Environment variable</strong>:</p>
        <pre><code class="language-bash">export SERVER_PORT=9090
</code></pre>
    </li>
    <li><p><strong>Command line argument</strong>:</p>
        <pre><code class="language-bash">java -jar myapp.jar --server.port=9090
</code></pre>
    </li>
    <li><p><strong>Programmatically</strong>:</p>
        <pre><code class="language-java">@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(Application.class);
        app.setDefaultProperties(Collections.singletonMap(&quot;server.port&quot;, &quot;9090&quot;));
        app.run(args);
    }
}
</code></pre>
    </li>
    <li><p><strong>Implementing EmbeddedServletContainerCustomizer</strong> (Spring Boot 1.x):</p>
        <pre><code class="language-java">@Component
public class ServerPortCustomizer implements EmbeddedServletContainerCustomizer {
    @Override
    public void customize(ConfigurableEmbeddedServletContainer container) {
        container.setPort(9090);
    }
}
</code></pre>
    </li>
    <li><p><strong>Using WebServerFactoryCustomizer</strong> (Spring Boot 2.x+):</p>
        <pre><code class="language-java">@Component
public class ServerPortCustomizer implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; {
    @Override
    public void customize(ConfigurableServletWebServerFactory factory) {
        factory.setPort(9090);
    }
}
</code></pre>
    </li>
    <li><p><strong>Random port (for testing):</strong></p>
        <pre><code class="language-properties">server.port=0
</code></pre>
        <p>or</p>
        <pre><code class="language-properties"># Random port but available as a property
server.port=0
spring.webserver.port=${server.port}
</code></pre>
    </li>
</ol>
<p>The port settings follow Spring Boot&#39;s property resolution order, with command line arguments having the highest priority.</p>
<h3 id="20-how-can-you-access-command-line-properties-in-spring-boot">20. How can you access command-line properties in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot provides multiple ways to access command-line properties:</p>
<ol>
    <li><p><strong>Using @Value annotation</strong>:</p>
        <pre><code class="language-java">@Component
public class MyComponent {
    @Value(&quot;${name}&quot;)
    private String name;

    public void printName() {
        System.out.println(&quot;Name: &quot; + name);
    }
}
</code></pre>
        <p>Run with: <code>java -jar myapp.jar --name=John</code></p>
    </li>
    <li><p><strong>Using Environment object</strong>:</p>
        <pre><code class="language-java">@Component
public class MyComponent {
    @Autowired
    private Environment environment;

    public void printName() {
        String name = environment.getProperty(&quot;name&quot;);
        System.out.println(&quot;Name: &quot; + name);
    }
}
</code></pre>
    </li>
    <li><p><strong>Using ApplicationArguments</strong>:</p>
        <pre><code class="language-java">@Component
public class MyComponent implements CommandLineRunner {
    @Autowired
    private ApplicationArguments args;

    @Override
    public void run(String... strings) throws Exception {
        // Option arguments (with --)
        boolean hasName = args.containsOption(&quot;name&quot;);
        List&lt;String&gt; nameValues = args.getOptionValues(&quot;name&quot;);

        // Non-option arguments (without --)
        List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs();

        System.out.println(&quot;Has name: &quot; + hasName);
        System.out.println(&quot;Name values: &quot; + nameValues);
        System.out.println(&quot;Non-option args: &quot; + nonOptionArgs);
    }
}
</code></pre>
    </li>
    <li><p><strong>Using CommandLineRunner</strong>:</p>
        <pre><code class="language-java">@Component
public class CommandLineAppStartupRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        // args contains raw command line arguments
        System.out.println(&quot;Application started with command-line arguments: &quot;);
        for (String arg : args) {
            System.out.println(arg);
        }
    }
}
</code></pre>
    </li>
    <li><p><strong>Using ApplicationRunner</strong> (provides parsed arguments):</p>
        <pre><code class="language-java">@Component
public class AppStartupRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println(&quot;Application started with option arguments: &quot;);
        for (String name : args.getOptionNames()) {
            System.out.println(name + &quot; = &quot; + args.getOptionValues(name));
        }
    }
}
</code></pre>
    </li>
</ol>
<p>Command-line arguments in Spring Boot can be passed as:</p>
<ul>
    <li>Option arguments with <code>--</code> prefix: <code>--name=value</code> or <code>--name value</code></li>
    <li>Non-option arguments: <code>value1 value2</code></li>
</ul>
<p>Spring Boot converts option arguments into properties that can be accessed using Environment or @Value.</p>
<h2 id="database-access-and-rest-apis">Database Access and REST APIs</h2>
<h2 id="section-3-spring-boot-core-components-1">Section 3: Spring Boot Core Components</h2>
<h3 id="21-explain-the-important-annotations-used-in-spring-boot">21. Explain the important annotations used in Spring Boot.</h3>
<p><strong>Answer:</strong> Spring Boot leverages several important annotations that simplify configuration and development:</p>
<ol>
    <li><p><strong>@SpringBootApplication</strong>: A convenience annotation that combines:</p>
        <ul>
            <li>@Configuration: Designates the class as a source of bean definitions</li>
            <li>@EnableAutoConfiguration: Enables Spring Boot&#39;s auto-configuration mechanism</li>
            <li>@ComponentScan: Scans for components in the package and sub-packages</li>
        </ul>
    </li>
    <li><p><strong>@EnableAutoConfiguration</strong>: Tells Spring Boot to configure beans based on the classpath dependencies.</p>
    </li>
    <li><p><strong>@ComponentScan</strong>: Scans for Spring components, repositories, services, and controllers.</p>
    </li>
    <li><p><strong>@Configuration</strong>: Marks a class as a configuration class that declares beans.</p>
    </li>
    <li><p><strong>@ConfigurationProperties</strong>: Binds and validates external configuration properties to a POJO.</p>
    </li>
    <li><p><strong>@Value</strong>: Injects values from properties files into fields.</p>
    </li>
    <li><p><strong>@Profile</strong>: Indicates that a component is eligible for registration when specific profiles are active.</p>
    </li>
    <li><p><strong>@Conditional</strong>: Set of annotations enabling conditional bean creation:</p>
        <ul>
            <li>@ConditionalOnClass</li>
            <li>@ConditionalOnMissingClass</li>
            <li>@ConditionalOnBean</li>
            <li>@ConditionalOnMissingBean</li>
            <li>@ConditionalOnProperty</li>
        </ul>
    </li>
    <li><p><strong>@EnableCaching</strong>: Enables caching in the application.</p>
    </li>
    <li><p><strong>@EnableScheduling</strong>: Enables scheduled tasks.</p>
    </li>
    <li><p><strong>@EnableAsync</strong>: Enables asynchronous method execution.</p>
    </li>
    <li><p><strong>@RestController</strong>: Combines @Controller and @ResponseBody, simplifying the creation of RESTful services.</p>
    </li>
    <li><p><strong>@RequestMapping</strong>: Maps HTTP requests to handler methods.</p>
    </li>
    <li><p><strong>@Autowired</strong>: Enables dependency injection.</p>
    </li>
    <li><p><strong>@Bean</strong>: Declares a method produces a bean managed by Spring.</p>
    </li>
    <li><p><strong>@Service</strong>, <strong>@Repository</strong>, <strong>@Controller</strong>: Indicates specialized @Component classes.</p>
    </li>
    <li><p><strong>@ControllerAdvice</strong>: Enables global exception handling.</p>
    </li>
    <li><p><strong>@ResponseStatus</strong>: Marks methods with HTTP status codes.</p>
    </li>
</ol>
<h3 id="22-explain-the-spring-boot-actuator-and-its-endpoints">22. Explain the Spring Boot Actuator and its endpoints.</h3>
<p><strong>Answer:</strong> Spring Boot Actuator adds production-ready features to an application, providing endpoints to monitor and manage the application.</p>
<p><strong>Key Endpoints:</strong></p>
<ol>
    <li><p><strong>/health</strong>: Shows application health information (status, diskSpace, etc.)</p>
        <ul>
            <li>Can be customized with HealthIndicator beans</li>
        </ul>
    </li>
    <li><p><strong>/info</strong>: Displays arbitrary application information</p>
        <ul>
            <li>Populated from properties prefixed with &#39;info.&#39;</li>
        </ul>
    </li>
    <li><p><strong>/metrics</strong>: Shows metrics information like memory usage, thread counts, HTTP request metrics, etc.</p>
    </li>
    <li><p><strong>/env</strong>: Shows the current environment properties from Spring&#39;s ConfigurableEnvironment</p>
    </li>
    <li><p><strong>/configprops</strong>: Displays a list of all @ConfigurationProperties</p>
    </li>
    <li><p><strong>/mappings</strong>: Displays a list of all @RequestMapping paths</p>
    </li>
    <li><p><strong>/beans</strong>: Shows a complete list of all Spring beans in the application</p>
    </li>
    <li><p><strong>/threaddump</strong>: Performs a thread dump</p>
    </li>
    <li><p><strong>/loggers</strong>: Shows and modifies the configuration of loggers in the application</p>
    </li>
    <li><p><strong>/shutdown</strong>: Allows the application to be gracefully shutdown (disabled by default)</p>
    </li>
    <li><p><strong>/httptrace</strong>: Displays HTTP trace information</p>
    </li>
    <li><p><strong>/flyway</strong>: Shows Flyway database migrations (if applicable)</p>
    </li>
    <li><p><strong>/liquibase</strong>: Shows Liquibase database migrations (if applicable)</p>
    </li>
    <li><p><strong>/auditevents</strong>: Exposes audit events information</p>
    </li>
</ol>
<p><strong>How to enable and use Actuator:</strong></p>
<ol>
    <li>Add the dependency:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li>Configure endpoints in application.properties:</li>
</ol>
<pre><code class="language-properties"># Enable all endpoints
management.endpoints.web.exposure.include=*

# Or enable specific endpoints
management.endpoints.web.exposure.include=health,info,metrics

# Enable shutdown endpoint
management.endpoint.shutdown.enabled=true

# Change base path for actuator endpoints (default is /actuator)
management.endpoints.web.base-path=/management
</code></pre>
<ol start="3">
    <li><p>Access via HTTP: <code>http://localhost:8080/actuator/health</code></p>
    </li>
    <li><p>Secure endpoints in production using Spring Security</p>
    </li>
</ol>
<h3 id="23-what-are-embedded-servers-in-spring-boot-which-servers-are-supported">23. What are embedded servers in Spring Boot? Which servers are supported?</h3>
<p><strong>Answer:</strong> Embedded servers in Spring Boot are servlet containers that are packaged within the application JAR file, allowing the application to be self-contained and run independently without deploying to an external server.</p>
<p><strong>Supported embedded servers in Spring Boot:</strong></p>
<ol>
    <li><p><strong>Apache Tomcat (Default)</strong>: The default embedded server for Spring Boot web applications.</p>
    </li>
    <li><p><strong>Jetty</strong>: An alternative to Tomcat, often used for its efficiency with long-lived connections and WebSockets.</p>
    </li>
    <li><p><strong>Undertow</strong>: A flexible, high-performance web server by JBoss, known for its high throughput and scalability.</p>
    </li>
    <li><p><strong>Netty</strong>: A non-blocking I/O client-server framework, primarily used with Spring WebFlux for reactive applications.</p>
    </li>
</ol>
<p><strong>How to switch between embedded servers:</strong></p>
<ol>
    <li>Exclude the default Tomcat starter and include a different one:</li>
</ol>
<pre><code class="language-xml">&lt;!-- Using Jetty instead of Tomcat --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li>For reactive applications (Spring WebFlux):</li>
</ol>
<pre><code class="language-xml">&lt;!-- Default is Netty --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- To use Tomcat with WebFlux --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-reactor-netty&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>Configuring embedded servers:</strong></p>
<pre><code class="language-properties"># Tomcat-specific properties
server.tomcat.max-threads=200
server.tomcat.min-spare-threads=10

# Jetty-specific properties
server.jetty.max-threads=200

# Undertow-specific properties
server.undertow.worker-threads=64
server.undertow.io-threads=16

# Common server properties
server.port=8080
server.address=127.0.0.1
server.compression.enabled=true
</code></pre>
<h3 id="24-what-is-spring-boot-cli-how-do-you-use-it">24. What is Spring Boot CLI? How do you use it?</h3>
<p><strong>Answer:</strong> Spring Boot CLI (Command Line Interface) is a tool that allows you to quickly prototype and develop Spring applications using Groovy scripts without requiring a full project setup.</p>
<p><strong>Key features of Spring Boot CLI:</strong></p>
<ol>
    <li><strong>Rapid prototyping</strong>: Write Spring applications with minimal code using Groovy.</li>
    <li><strong>Auto-dependency resolution</strong>: Automatically determines dependencies based on the code.</li>
    <li><strong>Auto-configuration</strong>: Applies Spring Boot&#39;s auto-configuration based on dependencies.</li>
    <li><strong>Embedded shell</strong>: Provides a built-in shell for running commands.</li>
    <li><strong>Spring Initializer integration</strong>: Creates new projects easily.</li>
</ol>
<p><strong>Installation:</strong></p>
<ol>
    <li><p><strong>Using SDKMAN</strong>:</p>
        <pre><code class="language-bash">sdk install springboot
</code></pre>
    </li>
    <li><p><strong>Using Homebrew</strong>:</p>
        <pre><code class="language-bash">brew tap spring-io/tap
brew install spring-boot
</code></pre>
    </li>
    <li><p><strong>Manual installation</strong>: Download and extract ZIP file, add bin directory to PATH</p>
    </li>
</ol>
<p><strong>Basic usage:</strong></p>
<ol>
    <li><p><strong>Running a Groovy script</strong>:</p>
        <pre><code class="language-bash">spring run app.groovy
</code></pre>
    </li>
    <li><p><strong>Creating a new project</strong>:</p>
        <pre><code class="language-bash">spring init --dependencies=web,data-jpa my-project
</code></pre>
    </li>
    <li><p><strong>Running tests</strong>:</p>
        <pre><code class="language-bash">spring test app.groovy
</code></pre>
    </li>
    <li><p><strong>Grabbing dependencies</strong> (in Groovy script):</p>
        <pre><code class="language-groovy">@Grab(&#39;spring-boot-starter-web&#39;)
@RestController
class HelloController {
    @RequestMapping(&quot;/&quot;)
    String home() {
        return &quot;Hello World!&quot;
    }
}
</code></pre>
    </li>
    <li><p><strong>Starting the shell</strong>:</p>
        <pre><code class="language-bash">spring shell
</code></pre>
    </li>
    <li><p><strong>View available commands</strong>:</p>
        <pre><code class="language-bash">spring help
</code></pre>
    </li>
</ol>
<p>The CLI significantly reduces boilerplate code. For example, a simple REST application can be written in a single Groovy file:</p>
<pre><code class="language-groovy">@RestController
class ThisWillActuallyRun {
    @RequestMapping(&quot;/&quot;)
    String home() {
        &quot;Hello World!&quot;
    }
}
</code></pre>
<p>Spring Boot CLI is particularly useful for:</p>
<ul>
    <li>Quickly testing concepts</li>
    <li>Creating simple microservices</li>
    <li>Learning Spring Boot features</li>
    <li>Automation scripts</li>
</ul>
<h3 id="25-what-are-spring-boot-devtools-and-how-do-they-help-developers">25. What are Spring Boot DevTools and how do they help developers?</h3>
<p><strong>Answer:</strong> Spring Boot DevTools is a set of tools that enhances developer productivity by providing development-time features like automatic restarts, live reload, and remote debugging.</p>
<p><strong>Key features:</strong></p>
<ol>
    <li><p><strong>Automatic restart</strong>: </p>
        <ul>
            <li>The application automatically restarts when files on the classpath change</li>
            <li>Uses two classloaders: one for unchanging classes (libraries) and one for your changing code</li>
            <li>Only your code gets reloaded, making restarts much faster</li>
        </ul>
    </li>
    <li><p><strong>Live reload</strong>: </p>
        <ul>
            <li>Browser refreshes automatically when resources change</li>
            <li>Requires a browser plugin or integration with supported IDE</li>
            <li>Works with HTML, CSS, JavaScript, and templates</li>
        </ul>
    </li>
    <li><p><strong>Property defaults</strong>: </p>
        <ul>
            <li>Disables template caching</li>
            <li>Enables debug logging for web groups</li>
            <li>Optimizes for development rather than production</li>
        </ul>
    </li>
    <li><p><strong>Remote development support</strong>:</p>
        <ul>
            <li>Allows remote updating and debugging</li>
            <li>Secured with a password</li>
            <li>Enables hot code replacement on remote applications</li>
        </ul>
    </li>
</ol>
<p><strong>How to use DevTools:</strong></p>
<ol>
    <li><p><strong>Add the dependency</strong>:</p>
        <pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
    </li>
    <li><p><strong>Configure DevTools</strong> (application.properties):</p>
        <pre><code class="language-properties"># Exclude specific paths from triggering restart
spring.devtools.restart.exclude=static/**,public/**

# Add additional paths to watch
spring.devtools.restart.additional-paths=scripts/**

# Disable automatic restart
spring.devtools.restart.enabled=false

# Enable/disable live reload
spring.devtools.livereload.enabled=true
</code></pre>
    </li>
    <li><p><strong>Remote development</strong>:</p>
        <pre><code class="language-properties"># Enable remote support
spring.devtools.remote.secret=mysecret
</code></pre>
    </li>
    <li><p><strong>Trigger restart manually</strong>: Create a file called <code>.trigger</code> in your project root and update it to force a restart</p>
    </li>
</ol>
<p>DevTools is automatically disabled when running a packaged application (such as a JAR file with <code>java -jar</code>), ensuring it doesn&#39;t affect production behavior.</p>
<h3 id="26-explain-commandlinerunner-and-applicationrunner-in-spring-boot">26. Explain CommandLineRunner and ApplicationRunner in Spring Boot.</h3>
<p><strong>Answer:</strong> <code>CommandLineRunner</code> and <code>ApplicationRunner</code> are interfaces in Spring Boot that allow you to execute code after the application context is loaded but before the application starts. They&#39;re commonly used for tasks like database initialization, data loading, or checking preconditions before the application becomes available.</p>
<p><strong>CommandLineRunner:</strong></p>
<ul>
    <li>Method: <code>run(String... args)</code></li>
    <li>Receives raw command-line arguments</li>
</ul>
<pre><code class="language-java">@Component
public class MyCommandLineRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        System.out.println(&quot;CommandLineRunner: Application started with arguments:&quot;);
        for (String arg : args) {
            System.out.println(arg);
        }
        // Initialize or load data here
    }
}
</code></pre>
<p><strong>ApplicationRunner:</strong></p>
<ul>
    <li>Method: <code>run(ApplicationArguments args)</code></li>
    <li>Receives parsed arguments as an <code>ApplicationArguments</code> object</li>
    <li>Provides convenient access to option arguments (--key=value) and non-option arguments</li>
</ul>
<pre><code class="language-java">@Component
public class MyApplicationRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println(&quot;ApplicationRunner: Application started&quot;);

        // Access option arguments (arguments starting with --)
        System.out.println(&quot;Option Names: &quot; + args.getOptionNames());

        // Get specific option values
        if (args.containsOption(&quot;environment&quot;)) {
            System.out.println(&quot;Environment: &quot; + args.getOptionValues(&quot;environment&quot;));
        }

        // Access non-option arguments
        System.out.println(&quot;Non-Option Args: &quot; + args.getNonOptionArgs());
    }
}
</code></pre>
<p><strong>Key differences:</strong></p>
<ol>
    <li><code>CommandLineRunner</code> receives raw string arguments</li>
    <li><code>ApplicationRunner</code> receives parsed <code>ApplicationArguments</code> with methods to access option and non-option arguments</li>
</ol>
<p><strong>Controlling execution order:</strong></p>
<ul>
    <li>Use the <code>@Order</code> annotation to specify execution sequence</li>
    <li>Lower values have higher priority</li>
</ul>
<pre><code class="language-java">@Component
@Order(1)
public class FirstRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        System.out.println(&quot;FirstRunner executed&quot;);
    }
}

@Component
@Order(2)
public class SecondRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        System.out.println(&quot;SecondRunner executed&quot;);
    }
}
</code></pre>
<p><strong>Usage scenarios:</strong></p>
<ul>
    <li>Database initialization</li>
    <li>Default data creation</li>
    <li>Configuration validation</li>
    <li>Preliminary checks</li>
    <li>Startup tasks</li>
    <li>Generating reports at startup</li>
    <li>Cache warming</li>
</ul>
<h3 id="27-what-are-the-different-ways-to-create-a-spring-boot-application">27. What are the different ways to create a Spring Boot application?</h3>
<p><strong>Answer:</strong> There are several ways to create a Spring Boot application:</p>
<ol>
    <li><p><strong>Spring Initializr Web Interface (<a href="https://start.spring.io">https://start.spring.io</a>)</strong>:</p>
        <ul>
            <li>Visit start.spring.io</li>
            <li>Choose project type (Maven/Gradle)</li>
            <li>Specify metadata (Group, Artifact, Java version)</li>
            <li>Select dependencies</li>
            <li>Click &quot;Generate&quot; to download the project zip</li>
        </ul>
    </li>
    <li><p><strong>Using IDEs with Spring Initializr Integration</strong>:</p>
        <ul>
            <li><strong>IntelliJ IDEA</strong>: File → New → Project → Spring Initializer</li>
            <li><strong>Eclipse</strong> with STS (Spring Tool Suite): File → New → Spring Starter Project</li>
            <li><strong>Visual Studio Code</strong> with Spring Boot Extension: Command Palette → Spring Initializer</li>
        </ul>
    </li>
    <li><p><strong>Spring Boot CLI</strong>:</p>
        <pre><code class="language-bash">spring init --dependencies=web,data-jpa myproject
</code></pre>
    </li>
    <li><p><strong>Spring Boot CLI with Groovy scripts</strong>:</p>
        <pre><code class="language-groovy">// app.groovy
@RestController
class SimpleApp {
    @GetMapping(&quot;/&quot;)
    String home() {
        &quot;Hello World!&quot;
    }
}
</code></pre>
        <p>Run with: <code>spring run app.groovy</code></p>
    </li>
    <li><p><strong>Maven with Spring Boot Starter POM</strong>:
        Create a pom.xml manually:</p>
        <pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.7.0&lt;/version&gt;
&lt;/parent&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
    </li>
    <li><p><strong>Gradle with Spring Boot</strong>:
        Create a build.gradle file:</p>
        <pre><code class="language-groovy">plugins {
    id &#39;org.springframework.boot&#39; version &#39;2.7.0&#39;
    id &#39;io.spring.dependency-management&#39; version &#39;1.0.11.RELEASE&#39;
    id &#39;java&#39;
}

dependencies {
    implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;
}
</code></pre>
    </li>
    <li><p><strong>Using the curl Command</strong>:</p>
        <pre><code class="language-bash">curl https://start.spring.io/starter.zip \
    -d dependencies=web,data-jpa \
    -d bootVersion=2.7.0.RELEASE \
    -o myproject.zip
</code></pre>
    </li>
    <li><p><strong>GitHub Repository Templates</strong>:</p>
        <ul>
            <li>Fork or clone existing Spring Boot template repositories</li>
            <li>Customize according to your requirements</li>
        </ul>
    </li>
    <li><p><strong>JHipster</strong> (for full-stack applications):</p>
        <pre><code class="language-bash">npm install -g generator-jhipster
jhipster
</code></pre>
    </li>
</ol>
<p>Each method has advantages:</p>
<ul>
    <li><strong>Spring Initializer</strong>: Best for most developers, easy UI</li>
    <li><strong>IDE Integration</strong>: Convenient for those already using supported IDEs</li>
    <li><strong>Command Line</strong>: Good for automation and CI/CD pipelines</li>
    <li><strong>Manual Configuration</strong>: Provides complete control over the setup</li>
</ul>
<h3 id="28-what-is-spring-boots-auto-configuration-and-how-does-it-work">28. What is Spring Boot&#39;s Auto-Configuration and how does it work?</h3>
<p><strong>Answer:</strong> Spring Boot Auto-Configuration automatically configures a Spring application based on the dependencies present in the classpath, reducing the need for explicit configuration.</p>
<p><strong>How Auto-Configuration Works:</strong></p>
<ol>
    <li><p><strong>Detection Mechanism</strong>:</p>
        <ul>
            <li>When an application starts, Spring Boot checks the classpath for specific libraries and JARs</li>
            <li>Based on what it finds, it makes reasonable assumptions about what you need</li>
            <li>For example, if it finds HSQLDB but no other database drivers, it configures an in-memory database</li>
        </ul>
    </li>
    <li><p><strong>Conditional Configuration</strong>:</p>
        <ul>
            <li>Leverages Spring&#39;s condition annotations to apply configuration only when certain conditions are met</li>
            <li>Common conditions include:<ul>
                <li><code>@ConditionalOnClass</code>: Apply when a specific class is present</li>
                <li><code>@ConditionalOnMissingBean</code>: Apply when a bean of specific type is not already defined</li>
                <li><code>@ConditionalOnProperty</code>: Apply when a specific property has a specific value</li>
                <li><code>@ConditionalOnWebApplication</code>: Apply when the application is a web application</li>
            </ul>
            </li>
        </ul>
    </li>
    <li><p><strong>Auto-Configuration Classes</strong>:</p>
        <ul>
            <li>Located in spring-boot-autoconfigure.jar</li>
            <li>Each represents a &quot;slice&quot; of functionality like web, data, messaging, etc.</li>
            <li>Named with pattern <code>*AutoConfiguration</code> (e.g., <code>JpaRepositoriesAutoConfiguration</code>)</li>
        </ul>
    </li>
    <li><p><strong>Ordering and Priority</strong>:</p>
        <ul>
            <li>Uses <code>@AutoConfigureBefore</code> and <code>@AutoConfigureAfter</code> to manage dependency ordering</li>
            <li>Respects <code>@Order</code> annotation for prioritization</li>
        </ul>
    </li>
    <li><p><strong>Discovery Process</strong>:</p>
        <ul>
            <li>Auto-configuration classes are loaded from <code>META-INF/spring.factories</code></li>
            <li>Located in spring-boot-autoconfigure.jar under the key <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code></li>
        </ul>
    </li>
</ol>
<p><strong>Example of an Auto-Configuration Class:</strong></p>
<pre><code class="language-java">@Configuration
@ConditionalOnClass(DataSource.class)
@ConditionalOnMissingBean(DataSource.class)
@PropertySource(&quot;classpath:datasource.properties&quot;)
public class JdbcTemplateAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean(JdbcTemplate.class)
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
</code></pre>
<p><strong>Enabling Auto-Configuration:</strong></p>
<ul>
    <li>It&#39;s enabled by default with <code>@SpringBootApplication</code> annotation</li>
    <li>Can be explicitly enabled with <code>@EnableAutoConfiguration</code></li>
    <li>Can be disabled for specific classes: <code>@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})</code></li>
</ul>
<h2 id="viewing-auto-configuration-report-1-add-debug-mode----properties-----in-applicationproperties----debugtrue-----2-check-console-output-when-application-starts--------positive-matches"><strong>Viewing Auto-Configuration Report:</strong>
    1. Add debug mode:
    <code>properties    # In application.properties    debug=true    </code>
    <br>2. Check console output when application starts:
    ```
    Positive matches:</h2>
<h2 id="jparepositoriesautoconfiguration-matched----------conditionalonclass-found-required-class-condition-evaluation-passed----negative-matches">   JpaRepositoriesAutoConfiguration matched
    - @ConditionalOnClass found required class (Condition evaluation passed)
    <br>   Negative matches:</h2>
<p>   MongoDataAutoConfiguration did not match
    - @ConditionalOnClass did not find required class (Condition evaluation failed)</p>
<pre><code>
3. Or use the actuator endpoint:
</code></pre>
<p>   GET /actuator/conditions</p>
<pre><code>
Auto-configuration significantly reduces boilerplate configuration while still allowing developers to override any default when needed. It follows a &quot;convention over configuration&quot; approach, providing sensible defaults based on the application&#39;s dependencies.

### 29. How do you disable a specific auto-configuration class in Spring Boot?
**Answer:** There are several ways to disable specific auto-configuration classes in Spring Boot:

1. **Using the exclude attribute of @SpringBootApplication**:
```java
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class,
                                 HibernateJpaAutoConfiguration.class})
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
</code></pre>
<ol start="2">
    <li><p><strong>Using the exclude attribute of @EnableAutoConfiguration</strong>:</p>
        <pre><code class="language-java">@Configuration
@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
@ComponentScan
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
</code></pre>
    </li>
    <li><p><strong>Using properties in application.properties</strong>:</p>
        <pre><code class="language-properties">spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration
</code></pre>
    </li>
    <li><p><strong>Using properties in application.yml</strong>:</p>
        <pre><code class="language-yaml">spring:
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
      - org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration
</code></pre>
    </li>
    <li><p><strong>Programmatically using SpringApplication</strong>:</p>
        <pre><code class="language-java">public class MyApplication {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApplication.class);

        Set&lt;String&gt; excludes = new HashSet&lt;&gt;();
        excludes.add(&quot;org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration&quot;);

        app.setDefaultProperties(Collections.singletonMap(
            &quot;spring.autoconfigure.exclude&quot;, String.join(&quot;,&quot;, excludes)
        ));

        app.run(args);
    }
}
</code></pre>
    </li>
    <li><p><strong>By providing your own implementation</strong>:</p>
        <ul>
            <li>Define a bean of the same type that the auto-configuration would create</li>
            <li>Spring Boot respects <code>@ConditionalOnMissingBean</code> in auto-configurations</li>
        </ul>
    </li>
    <li><p><strong>Using specific property flags</strong>:</p>
        <ul>
            <li>Some auto-configurations have specific properties to enable/disable them</li>
        </ul>
        <pre><code class="language-properties"># Examples
spring.jpa.enabled=false
spring.data.mongodb.auto-index-creation=false
</code></pre>
    </li>
</ol>
<p><strong>Choosing the right approach:</strong></p>
<ul>
    <li><strong>Method 1 &amp; 2</strong> (annotation-based): Good for permanent exclusions known at compile time</li>
    <li><strong>Method 3 &amp; 4</strong> (property-based): Flexible for environment-specific exclusions and runtime changes</li>
    <li><strong>Method 5</strong> (programmatic): Useful when exclusions need to be determined dynamically</li>
    <li><strong>Method 6</strong> (bean replacement): When you need a custom implementation instead of the auto-configured one</li>
    <li><strong>Method 7</strong> (feature flags): When the auto-configuration supports fine-grained control</li>
</ul>
<p><strong>Verifying disabled auto-configuration:</strong></p>
<ul>
    <li>Run the application with <code>debug=true</code> property</li>
    <li>Check the auto-configuration report in the logs</li>
    <li>Look under &quot;Negative matches&quot; for your excluded configurations</li>
</ul>
<h3 id="30-what-are-spring-boot-starters-and-how-do-they-simplify-dependency-management">30. What are Spring Boot Starters and how do they simplify dependency management?</h3>
<p><strong>Answer:</strong> Spring Boot Starters are curated sets of dependencies that address specific use cases, allowing developers to add functionality with minimal configuration. They act as a convenient way to include related dependencies without having to research and declare each dependency separately.</p>
<p><strong>How they work:</strong></p>
<ol>
    <li><p><strong>Dependency Aggregation</strong>: Each starter POM includes related dependencies required for a specific functionality.</p>
    </li>
    <li><p><strong>Transitive Dependencies</strong>: Starters handle not only direct dependencies but also all required transitive dependencies.</p>
    </li>
    <li><p><strong>Version Compatibility</strong>: Spring Boot manages version compatibility between different libraries.</p>
    </li>
    <li><p><strong>Consistent Dependency Structure</strong>: All starters follow a naming convention: <code>spring-boot-starter-*</code>.</p>
    </li>
</ol>
<p><strong>Benefits of using starters:</strong></p>
<ol>
    <li><p><strong>Simplified build configuration</strong>: Developers need to add only one dependency instead of multiple related ones.</p>
    </li>
    <li><p><strong>Reduced version conflicts</strong>: Spring Boot ensures all libraries work together without version conflicts.</p>
    </li>
    <li><p><strong>Faster project setup</strong>: Quickly set up applications with specific functionalities.</p>
    </li>
    <li><p><strong>Consistent dependency management</strong>: Standard approach to including common functionality.</p>
    </li>
    <li><p><strong>Auto-configuration support</strong>: Starters work with Spring Boot&#39;s auto-configuration to provide out-of-the-box functionality.</p>
    </li>
</ol>
<p><strong>Common Spring Boot Starters:</strong></p>
<pre><code>spring-boot-starter             : Core starter with auto-configuration, logging, and YAML support
spring-boot-starter-web         : Web and RESTful applications with Tomcat
spring-boot-starter-data-jpa    : Spring Data JPA with Hibernate
spring-boot-starter-security    : Spring Security
spring-boot-starter-test        : Testing including JUnit, Hamcrest, and Mockito
spring-boot-starter-jdbc        : JDBC with HikariCP connection pool
spring-boot-starter-thymeleaf   : Thymeleaf template engine
spring-boot-starter-mail        : Java Mail sender
spring-boot-starter-actuator    : Production ready features to monitor and manage application
spring-boot-starter-aop         : Aspect-oriented programming with AspectJ
spring-boot-starter-webflux     : Reactive web applications
spring-boot-starter-data-mongodb: MongoDB document database
spring-boot-starter-data-redis  : Redis key-value data store
spring-boot-starter-batch       : Spring Batch processing
spring-boot-starter-validation  : Java Bean Validation with Hibernate Validator
</code></pre>
<p><strong>Example of dependency reduction:</strong></p>
<p>Without Spring Boot Starter:</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
        &lt;version&gt;5.3.9&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.3.9&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
        &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;
        &lt;version&gt;9.0.50&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
        &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt;
        &lt;version&gt;9.0.50&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;version&gt;2.12.4&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- And many more... --&gt;
&lt;/dependencies&gt;
</code></pre>
<p>With Spring Boot Starter:</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p><strong>Creating custom starters:</strong>
    Spring Boot allows creating custom starters for common functionality used across projects:</p>
<ol>
    <li>Create an auto-configuration module</li>
    <li>Create a starter module that depends on it</li>
    <li>Follow naming convention: <code>acme-spring-boot-starter</code> for third-party starters</li>
</ol>
<p>Custom starter structure:</p>
<pre><code>acme-spring-boot-starter/
  ├── pom.xml                        # Dependencies and metadata
  └── src/main/resources/
      └── META-INF/
          └── spring.factories       # Auto-configuration entries
          └── spring.provides        # Optional documentation
</code></pre>
<h3 id="31-how-does-the-spring-boot-maven-plugin-work">31. How does the Spring Boot Maven plugin work?</h3>
<p><strong>Answer:</strong> The Spring Boot Maven plugin provides essential features for packaging and running Spring Boot applications. It works by enhancing Maven&#39;s build lifecycle with Spring Boot-specific functionality.</p>
<p><strong>Key features of the Spring Boot Maven plugin:</strong></p>
<ol>
    <li><p><strong>Executable JAR/WAR creation</strong>:</p>
        <ul>
            <li>Packages application and dependencies into a single, executable archive</li>
            <li>Creates a &quot;fat JAR&quot; containing an embedded classpath</li>
            <li>Includes an executable launcher so the JAR can be run with <code>java -jar</code></li>
        </ul>
    </li>
    <li><p><strong>Build information</strong>:</p>
        <ul>
            <li>Generates build information that can be accessed via the actuator</li>
            <li>Records details like build time, version, and artifact name</li>
        </ul>
    </li>
    <li><p><strong>Development enhancements</strong>:</p>
        <ul>
            <li>Provides a <code>spring-boot:run</code> goal for fast development iterations</li>
            <li>Supports automatic restart when files are modified</li>
        </ul>
    </li>
    <li><p><strong>Dependency resolution</strong>:</p>
        <ul>
            <li>Works with Spring Boot&#39;s starters and dependency management</li>
        </ul>
    </li>
</ol>
<p><strong>How to include the plugin:</strong></p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.7.0&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;repackage&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p><strong>Main goals provided by the plugin:</strong></p>
<ol>
    <li><p><strong>spring-boot:run</strong>: Runs the application directly from Maven</p>
        <pre><code class="language-bash">mvn spring-boot:run
</code></pre>
    </li>
    <li><p><strong>spring-boot:repackage</strong>: Repackages the JAR/WAR to make it executable</p>
        <pre><code class="language-bash">mvn package spring-boot:repackage
</code></pre>
    </li>
    <li><p><strong>spring-boot:build-info</strong>: Generates build information</p>
        <pre><code class="language-bash">mvn spring-boot:build-info
</code></pre>
    </li>
    <li><p><strong>spring-boot:start/stop</strong>: Start/stop the application for integration testing</p>
        <pre><code class="language-bash">mvn spring-boot:start
mvn spring-boot:stop
</code></pre>
    </li>
    <li><p><strong>spring-boot:build-image</strong>: Builds an OCI image using a packaged application</p>
        <pre><code class="language-bash">mvn spring-boot:build-image
</code></pre>
    </li>
</ol>
<p><strong>Customization options:</strong></p>
<ol>
    <li><p><strong>Custom launch script</strong>:</p>
        <pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;executable&gt;true&lt;/executable&gt;
        &lt;embeddedLaunchScript&gt;custom.script&lt;/embeddedLaunchScript&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
    </li>
    <li><p><strong>Excluding dependencies</strong>:</p>
        <pre><code class="language-xml">&lt;configuration&gt;
    &lt;excludes&gt;
        &lt;exclude&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/exclude&gt;
    &lt;/excludes&gt;
&lt;/configuration&gt;
</code></pre>
    </li>
    <li><p><strong>Custom main class</strong>:</p>
        <pre><code class="language-xml">&lt;configuration&gt;
    &lt;mainClass&gt;com.example.MyApplication&lt;/mainClass&gt;
&lt;/configuration&gt;
</code></pre>
    </li>
    <li><p><strong>Development profiles</strong>:</p>
        <pre><code class="language-xml">&lt;configuration&gt;
    &lt;profiles&gt;
        &lt;profile&gt;dev&lt;/profile&gt;
    &lt;/profiles&gt;
&lt;/configuration&gt;
</code></pre>
    </li>
</ol>
<p>The plugin works internally by using a special layout for the executable JAR:</p>
<ul>
    <li>Main application classes at the root</li>
    <li>Dependencies in BOOT-INF/lib</li>
    <li>Classes and resources in BOOT-INF/classes</li>
    <li>Main manifest pointing to the Spring Boot loader classes</li>
</ul>
<p>This structure allows the Spring Boot loader to load classes in the correct order while maintaining isolation between application code and dependencies.</p>
<h3 id="32-what-happens-when-a-spring-boot-application-is-run">32. What happens when a Spring Boot application is run?</h3>
<p><strong>Answer:</strong> When a Spring Boot application is run, it goes through a series of initialization steps:</p>
<ol>
    <li><p><strong>Bootstrap Initialization</strong>:</p>
        <ul>
            <li>Java&#39;s main method is called</li>
            <li><code>SpringApplication.run()</code> is invoked</li>
            <li>SpringApplication instance is created</li>
            <li>Application type is determined (Servlet, Reactive, None)</li>
            <li><code>ApplicationContextInitializer</code> instances are loaded from META-INF/spring.factories</li>
        </ul>
    </li>
    <li><p><strong>Environment Preparation</strong>:</p>
        <ul>
            <li>Environment is created based on application type</li>
            <li>Command-line arguments are parsed and added to the environment</li>
            <li>Properties are loaded from various sources (properties files, YAML, environment variables, etc.)</li>
            <li>Profiles are activated based on configuration</li>
        </ul>
    </li>
    <li><p><strong>ApplicationContext Creation</strong>:</p>
        <ul>
            <li>Appropriate ApplicationContext is created based on application type:<ul>
                <li><code>AnnotationConfigServletWebServerApplicationContext</code> for servlet web apps</li>
                <li><code>AnnotationConfigReactiveWebServerApplicationContext</code> for reactive web apps</li>
                <li><code>AnnotationConfigApplicationContext</code> for non-web apps</li>
            </ul>
            </li>
        </ul>
    </li>
    <li><p><strong>Bean Definitions Loading</strong>:</p>
        <ul>
            <li>Application class is registered as a configuration class</li>
            <li><code>@ComponentScan</code> finds and registers beans from annotated components</li>
            <li><code>@Import</code> annotations are processed</li>
            <li><code>@Bean</code> methods are registered</li>
        </ul>
    </li>
    <li><p><strong>Auto-Configuration Processing</strong>:</p>
        <ul>
            <li>Auto-configuration classes are loaded from META-INF/spring.factories</li>
            <li>Each auto-configuration class is evaluated based on conditions</li>
            <li>Qualifying configurations are applied</li>
            <li>Beans are conditionally registered based on what&#39;s already in the context</li>
        </ul>
    </li>
    <li><p><strong>ApplicationContext Refresh</strong>:</p>
        <ul>
            <li>Bean factories are prepared</li>
            <li>Bean definitions are evaluated</li>
            <li>Bean post-processors are registered</li>
            <li>Singleton beans are instantiated</li>
            <li>Bean dependencies are satisfied through injection</li>
        </ul>
    </li>
    <li><p><strong>Post-Refresh Operations</strong>:</p>
        <ul>
            <li>LiveReload server starts (if DevTools is enabled)</li>
            <li>Event publishers are notified that context is refreshed</li>
        </ul>
    </li>
    <li><p><strong>Embedded Server Startup</strong> (for web applications):</p>
        <ul>
            <li>Embedded server (Tomcat, Jetty, Undertow) is initialized</li>
            <li>Web-specific beans are configured</li>
            <li>Dispatcher servlet is registered</li>
            <li>Server is started on configured port</li>
        </ul>
    </li>
    <li><p><strong>Application Started Callbacks</strong>:</p>
        <ul>
            <li><code>ApplicationStartedEvent</code> is published</li>
            <li>ApplicationRunner and CommandLineRunner beans are executed</li>
            <li><code>ApplicationReadyEvent</code> is published when the application is ready to service requests</li>
        </ul>
    </li>
    <li><p><strong>Application Running State</strong>:</p>
        <ul>
            <li>Main thread may wait if it&#39;s a web application</li>
            <li>Application is ready for use</li>
        </ul>
    </li>
</ol>
<p><strong>Key events published during startup:</strong></p>
<ol>
    <li><code>ApplicationStartingEvent</code>: At the start, before environment or context preparation</li>
    <li><code>ApplicationEnvironmentPreparedEvent</code>: After environment is prepared but before context creation</li>
    <li><code>ApplicationContextInitializedEvent</code>: After context is created but before loading sources</li>
    <li><code>ApplicationPreparedEvent</code>: After bean definitions are loaded but before refresh</li>
    <li><code>ApplicationStartedEvent</code>: After context is refreshed but before runners are called</li>
    <li><code>ApplicationReadyEvent</code>: After all runners have been called</li>
    <li><code>ApplicationFailedEvent</code>: If exception occurs during startup</li>
</ol>
<p><strong>Error handling</strong>:</p>
<ul>
    <li>If an exception occurs during startup, context creation is aborted</li>
    <li>Registered failure analyzers try to provide user-friendly error messages</li>
    <li><code>FailureAnalysisReporter</code> displays error information</li>
    <li>JVM exits with error status</li>
</ul>
<p>This startup process combines traditional Spring Framework context initialization with Spring Boot&#39;s auto-configuration and embedded server capabilities.</p>
<h3 id="33-what-is-the-spring-boot-executable-jar-how-does-it-work">33. What is the Spring Boot Executable JAR? How does it work?</h3>
<p><strong>Answer:</strong> A Spring Boot Executable JAR (also called &quot;fat JAR&quot; or &quot;uber JAR&quot;) is a self-contained archive that includes the application code, all its dependencies, and an embedded server, enabling it to run as a standalone application with just the Java Runtime Environment.</p>
<p><strong>Structure of a Spring Boot Executable JAR:</strong></p>
<pre><code>example.jar
├── META-INF/
│   ├── MANIFEST.MF             (Contains Main-Class and Start-Class entries)
│   └── maven/...               (Maven metadata if built with Maven)
├── BOOT-INF/
│   ├── classes/                (Application classes and resources)
│   │   ├── com/example/...     (Java packages with compiled classes)
│   │   ├── application.properties
│   │   └── static/templates/...
│   └── lib/                    (Dependencies as JAR files)
│       ├── spring-core-5.3.9.jar
│       ├── spring-boot-2.7.0.jar
│       └── ...
└── org/springframework/boot/loader/  (Spring Boot loader classes)
    ├── JarLauncher.class       (Entry point class)
    ├── LaunchedURLClassLoader.class
    └── ...
</code></pre>
<p><strong>How it works:</strong></p>
<ol>
    <li><p><strong>Special Class Loader</strong>:</p>
        <ul>
            <li>Traditional Java doesn&#39;t support nested JARs directly</li>
            <li>Spring Boot provides a custom class loader (<code>LaunchedURLClassLoader</code>) that can load classes from nested JARs</li>
        </ul>
    </li>
    <li><p><strong>Manifest Configuration</strong>:</p>
        <ul>
            <li>MANIFEST.MF includes special entries:<ul>
                <li><code>Main-Class: org.springframework.boot.loader.JarLauncher</code> (Bootstrap class)</li>
                <li><code>Start-Class: com.example.MyApplication</code> (Your application main class)</li>
                <li><code>Spring-Boot-Classes: BOOT-INF/classes/</code> (Location of application classes)</li>
                <li><code>Spring-Boot-Lib: BOOT-INF/lib/</code> (Location of dependencies)</li>
                <li><code>Spring-Boot-Version: 2.7.0</code> (Spring Boot version)</li>
            </ul>
            </li>
        </ul>
    </li>
    <li><p><strong>Launch Process</strong>:</p>
        <ul>
            <li>When <code>java -jar example.jar</code> is executed:<ol>
                <li>JVM loads the <code>Main-Class</code> (JarLauncher)</li>
                <li>JarLauncher sets up the custom class loader</li>
                <li>JarLauncher reads the nested JARs in BOOT-INF/lib</li>
                <li>JarLauncher finds and loads the <code>Start-Class</code></li>
                <li>JarLauncher calls the main method on the Start-Class</li>
            </ol>
            </li>
        </ul>
    </li>
    <li><p><strong>Nested JAR Handling</strong>:</p>
        <ul>
            <li>Spring Boot loader can read entries from nested JARs using the <code>!</code> separator in URLs</li>
            <li>For example: <code>jar:file:/path/to/app.jar!/BOOT-INF/lib/some-library.jar!/com/example/Class.class</code></li>
        </ul>
    </li>
</ol>
<p><strong>Benefits of Executable JARs:</strong></p>
<ol>
    <li><strong>Self-contained deployment</strong>: Single file contains everything needed to run</li>
    <li><strong>Simplified deployment</strong>: No need for additional installation steps</li>
    <li><strong>No external server required</strong>: Embedded server is included</li>
    <li><strong>Consistent environment</strong>: All dependencies are fixed at build time</li>
    <li><strong>Cloud-friendly</strong>: Works well with containerized deployments</li>
    <li><strong>Version certainty</strong>: Eliminates &quot;works on my machine&quot; issues</li>
</ol>
<p><strong>Creating an Executable JAR:</strong></p>
<p>With Maven:</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;repackage&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>With Gradle:</p>
<pre><code class="language-groovy">plugins {
    id &#39;org.springframework.boot&#39; version &#39;2.7.0&#39;
    id &#39;java&#39;
}

bootJar {
    layered {
        enabled = true
    }
}
</code></pre>
<p><strong>Running an Executable JAR:</strong></p>
<pre><code class="language-bash"># Basic execution
java -jar myapplication.jar

# With system properties
java -Dspring.profiles.active=prod -jar myapplication.jar

# With command-line arguments
java -jar myapplication.jar --server.port=9090
</code></pre>
<h2 id="section-4-database-access-with-spring-boot-1">Section 4: Database Access with Spring Boot</h2>
<h3 id="34-how-does-spring-boot-simplify-database-access">34. How does Spring Boot simplify database access?</h3>
<p><strong>Answer:</strong> Spring Boot significantly simplifies database access through a variety of mechanisms:</p>
<ol>
    <li><p><strong>Auto-configuration</strong>: </p>
        <ul>
            <li>Automatically configures database components based on dependencies on the classpath</li>
            <li>Sets up data sources, entity managers, and transaction managers</li>
            <li>Configures JPA providers like Hibernate without explicit configuration</li>
        </ul>
    </li>
    <li><p><strong>Starter Dependencies</strong>:</p>
        <ul>
            <li><code>spring-boot-starter-data-jpa</code>: JPA with Hibernate</li>
            <li><code>spring-boot-starter-data-mongodb</code>: MongoDB support</li>
            <li><code>spring-boot-starter-data-redis</code>: Redis support</li>
            <li><code>spring-boot-starter-jdbc</code>: JDBC support with connection pooling</li>
        </ul>
    </li>
    <li><p><strong>Connection Pool Integration</strong>:</p>
        <ul>
            <li>Automatically configures HikariCP (default), Tomcat, or Commons DBCP2</li>
            <li>Sets sensible defaults for pool sizes and timeouts</li>
        </ul>
    </li>
    <li><p><strong>Property-Based Configuration</strong>:</p>
        <ul>
            <li>Simple database configuration through application.properties/application.yml</li>
        </ul>
        <pre><code class="language-properties">spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=user
spring.datasource.password=password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
</code></pre>
    </li>
    <li><p><strong>Repository Interfaces</strong>:</p>
        <ul>
            <li>Spring Data repositories provide CRUD operations with minimal code</li>
        </ul>
        <pre><code class="language-java">@Repository
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    List&lt;User&gt; findByLastName(String lastName);
    Optional&lt;User&gt; findByEmail(String email);
}
</code></pre>
    </li>
    <li><p><strong>Dialect Detection</strong>:</p>
        <ul>
            <li>Automatically detects and configures the appropriate SQL dialect</li>
            <li>Works with H2, MySQL, PostgreSQL, Oracle, SQL Server, etc.</li>
        </ul>
    </li>
    <li><p><strong>Migration Tool Integration</strong>:</p>
        <ul>
            <li>Built-in support for Flyway and Liquibase database migrations</li>
            <li>Auto-execution of migrations during application startup</li>
        </ul>
    </li>
    <li><p><strong>Testing Support</strong>:</p>
        <ul>
            <li><code>@DataJpaTest</code> for repository layer tests</li>
            <li>In-memory database auto-configuration for tests</li>
            <li>Test slices isolate the persistence layer</li>
        </ul>
    </li>
    <li><p><strong>Multi-Database Support</strong>:</p>
        <ul>
            <li>Simplified configuration for multiple data sources</li>
            <li>Separate transaction management for each data source</li>
        </ul>
    </li>
    <li><p><strong>NoSQL Integration</strong>:</p>
        <ul>
            <li>Similar conveniences for MongoDB, Redis, Elasticsearch, etc.</li>
            <li>Consistent programming model across different database types</li>
        </ul>
    </li>
</ol>
<p><strong>Example of simplified database access:</strong></p>
<p>Entity class:</p>
<pre><code class="language-java">@Entity
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String firstName;
    private String lastName;
    private String email;

    // Getters, setters, constructors
}
</code></pre>
<p>Repository interface:</p>
<pre><code class="language-java">public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt; {
    List&lt;Customer&gt; findByLastName(String lastName);

    @Query(&quot;SELECT c FROM Customer c WHERE c.email LIKE %:domain&quot;)
    List&lt;Customer&gt; findByEmailDomain(@Param(&quot;domain&quot;) String domain);
}
</code></pre>
<p>Service class:</p>
<pre><code class="language-java">@Service
@Transactional
public class CustomerService {
    private final CustomerRepository repository;

    public CustomerService(CustomerRepository repository) {
        this.repository = repository;
    }

    public Customer createCustomer(Customer customer) {
        return repository.save(customer);
    }

    public List&lt;Customer&gt; findByLastName(String lastName) {
        return repository.findByLastName(lastName);
    }
}
</code></pre>
<p>This simplification helps developers focus on business logic rather than boilerplate code and complex configuration, while still allowing for customization when needed.</p>
<h3 id="35-explain-spring-data-jpa-and-its-features-in-spring-boot">35. Explain Spring Data JPA and its features in Spring Boot.</h3>
<p><strong>Answer:</strong> Spring Data JPA is a part of the Spring Data family that makes it easy to implement JPA-based repositories (data access objects). When used with Spring Boot, it provides a higher-level abstraction over standard JPA, reducing boilerplate code and offering powerful features for database access.</p>
<p><strong>Key features of Spring Data JPA in Spring Boot:</strong></p>
<ol>
    <li><p><strong>Repository Interfaces</strong>:</p>
        <ul>
            <li>Create interfaces that extend Spring Data interfaces</li>
            <li>No need to write implementation classes</li>
            <li>Spring creates implementations at runtime</li>
        </ul>
        <pre><code class="language-java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    // All CRUD operations available automatically
}
</code></pre>
    </li>
    <li><p><strong>Method Name Query Creation</strong>:</p>
        <ul>
            <li>Define query methods using naming conventions</li>
            <li>Spring automatically generates the underlying JPQL queries</li>
        </ul>
        <pre><code class="language-java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    List&lt;User&gt; findByLastName(String lastName);
    Optional&lt;User&gt; findByEmail(String email);
    List&lt;User&gt; findByAgeBetween(int minAge, int maxAge);
    List&lt;User&gt; findByLastNameOrderByFirstNameAsc(String lastName);
    User findFirstByOrderByCreatedAtDesc();
}
</code></pre>
    </li>
    <li><p><strong>Custom Query Annotations</strong>:</p>
        <ul>
            <li><code>@Query</code> for custom JPQL or native SQL queries</li>
            <li><code>@Param</code> for named parameters</li>
        </ul>
        <pre><code class="language-java">@Query(&quot;SELECT u FROM User u WHERE u.status = :status AND u.emailVerified = true&quot;)
List&lt;User&gt; findActiveUsers(@Param(&quot;status&quot;) String status);

@Query(value = &quot;SELECT * FROM users WHERE role_id = ?1&quot;, nativeQuery = true)
List&lt;User&gt; findUsersByRoleNative(Long roleId);
</code></pre>
    </li>
    <li><p><strong>Paging and Sorting</strong>:</p>
        <ul>
            <li>Built-in support for pagination and sorting</li>
            <li>No custom code needed</li>
        </ul>
        <pre><code class="language-java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    Page&lt;User&gt; findByLastName(String lastName, Pageable pageable);
    List&lt;User&gt; findByCreatedAtAfter(LocalDate date, Sort sort);
}

// Usage:
Page&lt;User&gt; users = userRepository.findByLastName(&quot;Smith&quot;,
                        PageRequest.of(0, 20, Sort.by(&quot;firstName&quot;)));
</code></pre>
    </li>
    <li><p><strong>Specifications</strong>:</p>
        <ul>
            <li>Dynamic query construction</li>
            <li>Criteria API integration</li>
        </ul>
        <pre><code class="language-java">public interface UserRepository extends JpaRepository&lt;User, Long&gt;, JpaSpecificationExecutor&lt;User&gt; {
    // Additional methods
}

// Usage:
Specification&lt;User&gt; spec = (root, query, cb) -&gt;
    cb.and(
        cb.equal(root.get(&quot;active&quot;), true),
        cb.greaterThan(root.get(&quot;registrationDate&quot;), startDate)
    );
List&lt;User&gt; users = userRepository.findAll(spec);
</code></pre>
    </li>
    <li><p><strong>Query By Example</strong>:</p>
        <ul>
            <li>Create example objects to match against</li>
            <li>Useful for dynamic queries without complex specifications</li>
        </ul>
        <pre><code class="language-java">User probe = new User();
probe.setLastName(&quot;Smith&quot;);
probe.setActive(true);

ExampleMatcher matcher = ExampleMatcher.matching()
    .withIgnoreCase()
    .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING);

Example&lt;User&gt; example = Example.of(probe, matcher);
List&lt;User&gt; users = userRepository.findAll(example);
</code></pre>
    </li>
    <li><p><strong>Auditing</strong>:</p>
        <ul>
            <li>Automatic creation and modification timestamps</li>
            <li>User tracking</li>
        </ul>
        <pre><code class="language-java">@Entity
@EntityListeners(AuditingEntityListener.class)
public class User {
    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    @CreatedBy
    private String createdBy;

    @LastModifiedBy
    private String modifiedBy;
}

// Enable with:
@EnableJpaAuditing
</code></pre>
    </li>
    <li><p><strong>Projections</strong>:</p>
        <ul>
            <li>Retrieve only needed fields</li>
            <li>Interface-based or class-based</li>
        </ul>
        <pre><code class="language-java">public interface NameOnly {
    String getFirstName();
    String getLastName();
}

public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    List&lt;NameOnly&gt; findByLastName(String lastName);
}
</code></pre>
    </li>
    <li><p><strong>Transaction Management</strong>:</p>
        <ul>
            <li>Automatic transaction configuration</li>
            <li>Declarative transactions with <code>@Transactional</code></li>
        </ul>
    </li>
    <li><p><strong>Auto DDL Generation</strong>:</p>
        <ul>
            <li>Automatic schema creation/update from entities</li>
        </ul>
        <pre><code class="language-properties">spring.jpa.hibernate.ddl-auto=update
</code></pre>
    </li>
</ol>
<p>Spring Boot auto-configures all necessary components for Spring Data JPA, including:</p>
<ul>
    <li>EntityManagerFactory</li>
    <li>DataSource</li>
    <li>TransactionManager</li>
    <li>JPA Repositories</li>
</ul>
<p>This integration simplifies setup, allowing developers to focus on defining entities and repositories rather than configuration.</p>
<h3 id="36-how-do-you-configure-a-data-source-in-spring-boot">36. How do you configure a data source in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot offers multiple ways to configure a data source, ranging from simple property-based configuration to programmatic bean definitions.</p>
<p><strong>1. Using application.properties/yml:</strong>
    This is the most common approach for single data source applications.</p>
<pre><code class="language-properties"># Basic configuration
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=user
spring.datasource.password=secret
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# Connection pool settings (HikariCP is default)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=30000

# JPA settings
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
</code></pre>
<p><strong>2. Using YAML configuration:</strong></p>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: user
    password: secret
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      idle-timeout: 30000
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.MySQL8Dialect
</code></pre>
<p><strong>3. Using environment variables:</strong></p>
<pre><code class="language-bash">export SPRING_DATASOURCE_URL=jdbc:mysql://localhost:3306/mydb
export SPRING_DATASOURCE_USERNAME=user
export SPRING_DATASOURCE_PASSWORD=secret
</code></pre>
<p><strong>4. JNDI data source:</strong>
    If deploying to an application server with JNDI:</p>
<pre><code class="language-properties">spring.datasource.jndi-name=java:comp/env/jdbc/myDataSource
</code></pre>
<p><strong>5. Embedded database configuration:</strong>
    For testing or development:</p>
<pre><code class="language-properties"># H2 database
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.username=sa
spring.datasource.password=
spring.h2.console.enabled=true
</code></pre>
<p><strong>6. Programmatic configuration with @Bean methods:</strong>
    For more control or complex setups:</p>
<pre><code class="language-java">@Configuration
public class DataSourceConfig {

    @Bean
    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }

    // OR more explicit configuration:
    @Bean
    public DataSource customDataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/mydb&quot;);
        dataSource.setUsername(&quot;user&quot;);
        dataSource.setPassword(&quot;secret&quot;);
        dataSource.setMaximumPoolSize(10);
        return dataSource;
    }
}
</code></pre>
<p><strong>7. Multiple data sources:</strong>
    For applications that need to connect to multiple databases:</p>
<pre><code class="language-java">@Configuration
public class MultipleDataSourcesConfig {

    @Primary
    @Bean
    @ConfigurationProperties(&quot;spring.datasource.primary&quot;)
    public DataSourceProperties primaryDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Primary
    @Bean
    public DataSource primaryDataSource() {
        return primaryDataSourceProperties()
                .initializeDataSourceBuilder()
                .build();
    }

    @Bean
    @ConfigurationProperties(&quot;spring.datasource.secondary&quot;)
    public DataSourceProperties secondaryDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    public DataSource secondaryDataSource() {
        return secondaryDataSourceProperties()
                .initializeDataSourceBuilder()
                .build();
    }
}
</code></pre>
<p>With corresponding properties:</p>
<pre><code class="language-properties"># Primary database
spring.datasource.primary.url=jdbc:mysql://localhost:3306/db1
spring.datasource.primary.username=user1
spring.datasource.primary.password=pass1

# Secondary database
spring.datasource.secondary.url=jdbc:postgresql://localhost:5432/db2
spring.datasource.secondary.username=user2
spring.datasource.secondary.password=pass2
</code></pre>
<p><strong>8. Connection pooling specific configuration:</strong>
    Spring Boot automatically detects and uses available connection pool implementations with the following precedence:</p>
<ol>
    <li>HikariCP (default if available)</li>
    <li>Tomcat pooling</li>
    <li>Commons DBCP2</li>
</ol>
<pre><code class="language-properties"># HikariCP specific settings
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=1200000
spring.datasource.hikari.auto-commit=true

# If using Tomcat pooling
spring.datasource.tomcat.max-active=15
spring.datasource.tomcat.max-idle=10
spring.datasource.tomcat.min-idle=5
</code></pre>
<p>When configuring a data source, Spring Boot:</p>
<ul>
    <li>Detects the database driver based on the URL (if not explicitly specified)</li>
    <li>Sets up the appropriate connection pool</li>
    <li>Configures an EntityManagerFactory if JPA is on the classpath</li>
    <li>Registers a DataSourceTransactionManager if Spring Transaction is on the classpath</li>
</ul>
<h3 id="37-what-is-spring-boots-support-for-database-initialization">37. What is Spring Boot&#39;s support for database initialization?</h3>
<p><strong>Answer:</strong> Spring Boot offers several mechanisms for database initialization, allowing developers to set up schemas, load initial data, and ensure the database is ready for application use.</p>
<p><strong>1. Schema Initialization with Hibernate:</strong></p>
<p>Spring Boot can use Hibernate&#39;s schema generation feature to create, update, or validate the database schema based on entity definitions.</p>
<pre><code class="language-properties"># Options: none, validate, update, create, create-drop
spring.jpa.hibernate.ddl-auto=update
</code></pre>
<ul>
    <li><code>none</code>: No schema initialization</li>
    <li><code>validate</code>: Validates schema against entities but makes no changes</li>
    <li><code>update</code>: Updates schema to match entities (adds new tables/columns)</li>
    <li><code>create</code>: Creates schema from scratch, dropping existing tables</li>
    <li><code>create-drop</code>: Creates schema and drops it when application stops</li>
</ul>
<p>This is typically used for development or testing environments. For production, more controlled approaches like migrations are recommended.</p>
<p><strong>2. Schema Initialization with SQL Scripts:</strong></p>
<p>Spring Boot can execute SQL scripts to initialize the database schema:</p>
<pre><code class="language-properties"># Schema initialization
spring.sql.init.schema-locations=classpath:schema.sql
spring.sql.init.data-locations=classpath:data.sql
spring.sql.init.mode=always
</code></pre>
<ul>
    <li><code>spring.sql.init.schema-locations</code>: Locations of schema scripts</li>
    <li><code>spring.sql.init.data-locations</code>: Locations of data scripts</li>
    <li><code>spring.sql.init.mode</code>: <ul>
        <li><code>always</code>: Always initialize the database</li>
        <li><code>embedded</code>: Initialize only embedded databases (default)</li>
        <li><code>never</code>: Never initialize the database</li>
    </ul>
    </li>
</ul>
<p><strong>3. Database Migrations with Flyway:</strong></p>
<p>Spring Boot provides auto-configuration for Flyway, a database migration tool:</p>
<pre><code class="language-properties"># Flyway configuration
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.validate-on-migrate=true
</code></pre>
<p>Migration scripts follow naming convention <code>V&lt;version&gt;__&lt;description&gt;.sql</code>:</p>
<pre><code>V1__Create_users_table.sql
V2__Add_email_column.sql
</code></pre>
<p>Script example:</p>
<pre><code class="language-sql">-- V1__Create_users_table.sql
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(100) NOT NULL,
    password VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
</code></pre>
<p><strong>4. Database Migrations with Liquibase:</strong></p>
<p>Spring Boot also supports Liquibase for database migrations:</p>
<pre><code class="language-properties"># Liquibase configuration
spring.liquibase.enabled=true
spring.liquibase.change-log=classpath:db/changelog/db.changelog-master.xml
</code></pre>
<p>Example changelog:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;databaseChangeLog
    xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog
                        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.5.xsd&quot;&gt;

    &lt;changeSet id=&quot;1&quot; author=&quot;developer&quot;&gt;
        &lt;createTable tableName=&quot;users&quot;&gt;
            &lt;column name=&quot;id&quot; type=&quot;bigint&quot; autoIncrement=&quot;true&quot;&gt;
                &lt;constraints primaryKey=&quot;true&quot; nullable=&quot;false&quot;/&gt;
            &lt;/column&gt;
            &lt;column name=&quot;username&quot; type=&quot;varchar(100)&quot;&gt;
                &lt;constraints nullable=&quot;false&quot;/&gt;
            &lt;/column&gt;
            &lt;column name=&quot;password&quot; type=&quot;varchar(100)&quot;&gt;
                &lt;constraints nullable=&quot;false&quot;/&gt;
            &lt;/column&gt;
            &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot; defaultValueComputed=&quot;CURRENT_TIMESTAMP&quot;/&gt;
        &lt;/createTable&gt;
    &lt;/changeSet&gt;
&lt;/databaseChangeLog&gt;
</code></pre>
<p><strong>5. Programmatic Initialization:</strong></p>
<p>For more complex initialization needs, a CommandLineRunner or ApplicationRunner bean can be used:</p>
<pre><code class="language-java">@Component
public class DatabaseInitializer implements CommandLineRunner {

    private final JdbcTemplate jdbcTemplate;

    public DatabaseInitializer(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public void run(String... args) {
        // Check if table exists
        boolean tableExists = jdbcTemplate.queryForObject(
            &quot;SELECT COUNT(*) FROM information_schema.tables WHERE table_name = &#39;users&#39;&quot;,
            Integer.class) &gt; 0;

        if (!tableExists) {
            jdbcTemplate.execute(&quot;CREATE TABLE users (id BIGINT PRIMARY KEY, name VARCHAR(100))&quot;);
            // Insert initial data
            jdbcTemplate.update(&quot;INSERT INTO users (id, name) VALUES (1, &#39;Admin&#39;)&quot;);
        }
    }
}
</code></pre>
<p><strong>6. Data Initialization with Spring Data Repositories:</strong></p>
<pre><code class="language-java">@Component
public class DataInitializer implements CommandLineRunner {

    private final UserRepository userRepository;

    public DataInitializer(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public void run(String... args) {
        if (userRepository.count() == 0) {
            User admin = new User();
            admin.setUsername(&quot;admin&quot;);
            admin.setPassword(&quot;$2a$10$...&quot;);  // encoded password
            admin.setRole(&quot;ADMIN&quot;);

            userRepository.save(admin);
        }
    }
}
</code></pre>
<p><strong>Best Practices for Database Initialization:</strong></p>
<ol>
    <li><p><strong>Development vs. Production</strong>: Use different strategies for development (maybe Hibernate&#39;s ddl-auto) and production (definitely migrations)</p>
    </li>
    <li><p><strong>Migration Tools</strong>: Prefer Flyway or Liquibase for controlled schema evolution in production</p>
    </li>
    <li><p><strong>Validation</strong>: Use <code>spring.jpa.hibernate.ddl-auto=validate</code> in production to verify schema matches entities</p>
    </li>
    <li><p><strong>Initialization Order</strong>: When using JPA and SQL scripts together, configure the order:</p>
        <pre><code class="language-properties">spring.jpa.defer-datasource-initialization=true
</code></pre>
    </li>
    <li><p><strong>Database-specific Scripts</strong>: Use database-specific scripts for different databases:</p>
        <pre><code>schema.sql          # Default
schema-mysql.sql    # For MySQL
schema-postgres.sql # For PostgreSQL
</code></pre>
    </li>
</ol>
<h3 id="38-how-does-transaction-management-work-in-spring-boot">38. How does transaction management work in Spring Boot?</h3>
<p><strong>Transaction Aspects and Proxies:</strong></p>
<p>Spring uses proxies to implement transaction management:</p>
<ul>
    <li>For classes, CGLIB proxies are used (subclass-based)</li>
    <li>For interfaces, JDK dynamic proxies are used</li>
</ul>
<p>Important considerations:</p>
<ol>
    <li>Only external method calls coming through the proxy are intercepted</li>
    <li>Self-invocation (calling one method from another within the same class) bypasses the proxy</li>
    <li>Only public methods should be annotated with @Transactional</li>
</ol>
<p><strong>Best Practices for Transaction Management:</strong></p>
<ol>
    <li><p><strong>Apply at the appropriate level</strong>: Usually at service layer rather than repository or controller</p>
    </li>
    <li><p><strong>Use appropriate propagation</strong>: Consider how nested transactional calls should behave</p>
    </li>
    <li><p><strong>Set read-only when possible</strong>: Allows database optimizations for read operations</p>
    </li>
    <li><p><strong>Handle transaction boundaries properly</strong>:</p>
        <pre><code class="language-java">@Transactional
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    Account from = accountRepository.findById(fromId).orElseThrow();
    Account to = accountRepository.findById(toId).orElseThrow();

    from.withdraw(amount);
    to.deposit(amount);

    accountRepository.save(from);
    accountRepository.save(to);
}
</code></pre>
    </li>
    <li><p><strong>Be mindful of transaction isolation</strong>: Consider your application&#39;s concurrency needs</p>
    </li>
    <li><p><strong>Understand proxy limitations</strong>: Avoid calling @Transactional methods from within the same class</p>
    </li>
    <li><p><strong>Test transaction behavior</strong>: Verify rollback behavior with integration tests</p>
    </li>
</ol>
<h3 id="39-what-is-spring-data-jpa-repository-and-how-do-you-define-custom-queries">39. What is Spring Data JPA Repository and how do you define custom queries?</h3>
<p><strong>Answer:</strong> Spring Data JPA Repository is an abstraction that reduces boilerplate code for data access objects (DAOs) by providing ready-to-use CRUD operations and the ability to define custom queries with minimal code.</p>
<p><strong>Core Repository Interfaces:</strong></p>
<ol>
    <li><strong>Repository</strong>: Marker interface</li>
    <li><strong>CrudRepository</strong>: Basic CRUD operations</li>
    <li><strong>PagingAndSortingRepository</strong>: Adds pagination and sorting</li>
    <li><strong>JpaRepository</strong>: Adds JPA-specific methods and batch operations</li>
</ol>
<p><strong>Basic Usage:</strong></p>
<pre><code class="language-java">@Entity
public class Customer {
    @Id @GeneratedValue
    private Long id;
    private String firstName;
    private String lastName;
    private String email;
    // getters, setters, etc.
}

@Repository
public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt; {
    // Already has methods like:
    // save(), findById(), findAll(), count(), delete(), etc.
}
</code></pre>
<p><strong>Methods for Defining Custom Queries:</strong></p>
<ol>
    <li><p><strong>Method Name Query Derivation</strong>:
        Spring Data parses method names and automatically generates queries.</p>
        <pre><code class="language-java">public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt; {
    // SELECT c FROM Customer c WHERE c.lastName = ?1
    List&lt;Customer&gt; findByLastName(String lastName);

    // SELECT c FROM Customer c WHERE c.email = ?1
    Optional&lt;Customer&gt; findByEmail(String email);

    // SELECT c FROM Customer c WHERE c.firstName = ?1 AND c.lastName = ?2
    List&lt;Customer&gt; findByFirstNameAndLastName(String firstName, String lastName);

    // SELECT c FROM Customer c WHERE c.createdDate &gt; ?1
    List&lt;Customer&gt; findByCreatedDateAfter(LocalDate date);

    // SELECT c FROM Customer c WHERE c.age BETWEEN ?1 AND ?2
    List&lt;Customer&gt; findByAgeBetween(int minAge, int maxAge);

    // SELECT c FROM Customer c WHERE c.email LIKE ?1
    List&lt;Customer&gt; findByEmailContaining(String emailPart);

    // SELECT c FROM Customer c ORDER BY c.lastName ASC
    List&lt;Customer&gt; findAllByOrderByLastNameAsc();

    // SELECT c FROM Customer c WHERE c.active = true
    List&lt;Customer&gt; findByActiveTrue();

    // Return first 3 results
    List&lt;Customer&gt; findFirst3ByOrderByCreatedDateDesc();

    // Counting
    long countByLastName(String lastName);

    // Delete
    void deleteByEmail(String email);

    // Exists
    boolean existsByEmail(String email);
}
</code></pre>
        <p>Query creation keywords include:</p>
        <ul>
            <li>Comparison: <code>Is</code>, <code>Equals</code>, <code>GreaterThan</code>, <code>LessThan</code>, <code>Between</code>, etc.</li>
            <li>Logic: <code>And</code>, <code>Or</code>, <code>Not</code></li>
            <li>Condition: <code>IgnoreCase</code>, <code>StartingWith</code>, <code>EndingWith</code>, <code>Containing</code>, <code>Like</code></li>
            <li>Ordering: <code>OrderBy...Asc</code>, <code>OrderBy...Desc</code></li>
            <li>Pagination: <code>First</code>, <code>Top</code>, <code>DistinctBy</code></li>
        </ul>
    </li>
    <li><p><strong>@Query Annotation</strong>:
        For more complex queries or to optimize performance:</p>
        <pre><code class="language-java">@Repository
public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt; {
    // JPQL query
    @Query(&quot;SELECT c FROM Customer c WHERE c.status = :status AND c.type = :type&quot;)
    List&lt;Customer&gt; findActiveCustomersByType(@Param(&quot;status&quot;) String status,
                                           @Param(&quot;type&quot;) CustomerType type);

    // Native SQL query
    @Query(value = &quot;SELECT * FROM customers c WHERE c.email LIKE %:domain&quot;, nativeQuery = true)
    List&lt;Customer&gt; findCustomersByEmailDomain(@Param(&quot;domain&quot;) String domain);

    // Named parameters vs position parameters
    @Query(&quot;SELECT c FROM Customer c WHERE c.firstName LIKE %:name% OR c.lastName LIKE %:name%&quot;)
    List&lt;Customer&gt; searchByName(@Param(&quot;name&quot;) String name);

    // Update query
    @Modifying
    @Query(&quot;UPDATE Customer c SET c.status = :status WHERE c.createdDate &lt; :date&quot;)
    int updateStatusForOldCustomers(@Param(&quot;status&quot;) CustomerStatus status, @Param(&quot;date&quot;) LocalDate date);

    // Delete query
    @Modifying
    @Query(&quot;DELETE FROM Customer c WHERE c.lastLoginDate &lt; :date&quot;)
    void deleteInactiveCustomers(@Param(&quot;date&quot;) LocalDate date);

    // Projections
    @Query(&quot;SELECT c.firstName, c.lastName FROM Customer c WHERE c.active = true&quot;)
    List&lt;Object[]&gt; findActiveCustomerNames();
}
</code></pre>
    </li>
    <li><p><strong>Custom Implementation</strong>:
        For complex logic beyond simple queries:</p>
        <pre><code class="language-java">// Define custom methods
public interface CustomerRepositoryCustom {
    List&lt;Customer&gt; findCustomersWithComplexCriteria(String region,
                                                  CustomerStatus status,
                                                  LocalDate since);
}

// Extend both interfaces
public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt;, CustomerRepositoryCustom {
    // Standard query methods
}

// Implement custom interface
public class CustomerRepositoryImpl implements CustomerRepositoryCustom {
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public List&lt;Customer&gt; findCustomersWithComplexCriteria(String region,
                                                        CustomerStatus status,
                                                        LocalDate since) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery&lt;Customer&gt; query = cb.createQuery(Customer.class);
        Root&lt;Customer&gt; customer = query.from(Customer.class);

        // Build complex predicates
        List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();

        if (region != null) {
            predicates.add(cb.equal(customer.get(&quot;region&quot;), region));
        }

        if (status != null) {
            predicates.add(cb.equal(customer.get(&quot;status&quot;), status));
        }

        if (since != null) {
            predicates.add(cb.greaterThanOrEqualTo(customer.get(&quot;createdDate&quot;), since));
        }

        query.where(predicates.toArray(new Predicate[0]));

        return entityManager.createQuery(query).getResultList();
    }
}
</code></pre>
    </li>
    <li><p><strong>Specifications</strong>:
        For dynamic queries using type-safe criteria:</p>
        <pre><code class="language-java">public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt;,
                                           JpaSpecificationExecutor&lt;Customer&gt; {
    // Standard methods
}

// Usage
public List&lt;Customer&gt; findCustomersByDynamicCriteria(
        String firstName, String lastName, String email) {

    return customerRepository.findAll((root, query, cb) -&gt; {
        List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();

        if (StringUtils.hasText(firstName)) {
            predicates.add(cb.like(root.get(&quot;firstName&quot;), firstName + &quot;%&quot;));
        }

        if (StringUtils.hasText(lastName)) {
            predicates.add(cb.like(root.get(&quot;lastName&quot;), lastName + &quot;%&quot;));
        }

        if (StringUtils.hasText(email)) {
            predicates.add(cb.equal(root.get(&quot;email&quot;), email));
        }

        return cb.and(predicates.toArray(new Predicate[0]));
    });
}
</code></pre>
    </li>
    <li><p><strong>Named Queries</strong>:
        Defined in entity classes or orm.xml:</p>
        <pre><code class="language-java">@Entity
@NamedQuery(name = &quot;Customer.findByStatus&quot;,
           query = &quot;SELECT c FROM Customer c WHERE c.status = ?1&quot;)
public class Customer {
    // Entity definition
}

// Repository
public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt; {
    List&lt;Customer&gt; findByStatus(CustomerStatus status);
}
</code></pre>
    </li>
</ol>
<p><strong>Additional Features:</strong></p>
<ol>
    <li><p><strong>Projections</strong> for partial results:</p>
        <pre><code class="language-java">public interface CustomerNameOnly {
    String getFirstName();
    String getLastName();
}

public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt; {
    List&lt;CustomerNameOnly&gt; findByActiveTrue();
}
</code></pre>
    </li>
    <li><p><strong>Pagination and Sorting</strong>:</p>
        <pre><code class="language-java">Page&lt;Customer&gt; page = customerRepository.findAll(
    PageRequest.of(0, 20, Sort.by(&quot;lastName&quot;).ascending())
);

List&lt;Customer&gt; content = page.getContent();
int totalPages = page.getTotalPages();
long totalElements = page.getTotalElements();
</code></pre>
    </li>
    <li><p><strong>Query by Example</strong>:</p>
        <pre><code class="language-java">Customer probe = new Customer();
probe.setFirstName(&quot;John&quot;);
probe.setStatus(CustomerStatus.ACTIVE);

ExampleMatcher matcher = ExampleMatcher.matching()
    .withIgnorePaths(&quot;lastName&quot;)
    .withStringMatcher(ExampleMatcher.StringMatcher.STARTING);

Example&lt;Customer&gt; example = Example.of(probe, matcher);
List&lt;Customer&gt; customers = customerRepository.findAll(example);
</code></pre>
    </li>
</ol>
<p>Spring Data JPA repositories simplify database access while maintaining flexibility for complex requirements, allowing developers to focus more on business logic than database boilerplate.</p>
<h3 id="40-how-do-you-configure-multiple-data-sources-in-spring-boot">40. How do you configure multiple data sources in Spring Boot?</h3>
<p><strong>Answer:</strong> Configuring multiple data sources in Spring Boot requires explicit configuration of each data source, entity manager factory, and transaction manager. This setup is common in scenarios where an application needs to interact with multiple databases.</p>
<p><strong>Basic Approach for Multiple Data Sources:</strong></p>
<ol>
    <li><strong>Define properties</strong> for each data source:</li>
</ol>
<pre><code class="language-properties"># Primary DataSource
spring.datasource.primary.url=jdbc:mysql://localhost:3306/db1
spring.datasource.primary.username=user1
spring.datasource.primary.password=pass1
spring.datasource.primary.driver-class-name=com.mysql.cj.jdbc.Driver

# Secondary DataSource
spring.datasource.secondary.url=jdbc:postgresql://localhost:5432/db2
spring.datasource.secondary.username=user2
spring.datasource.secondary.password=pass2
spring.datasource.secondary.driver-class-name=org.postgresql.Driver
</code></pre>
<ol start="2">
    <li><strong>Configure Data Sources, Entity Manager Factories, and Transaction Managers</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
    basePackages = &quot;com.example.primary.repository&quot;,
    entityManagerFactoryRef = &quot;primaryEntityManagerFactory&quot;,
    transactionManagerRef = &quot;primaryTransactionManager&quot;
)
public class PrimaryDataSourceConfig {

    @Primary
    @Bean
    @ConfigurationProperties(&quot;spring.datasource.primary&quot;)
    public DataSourceProperties primaryDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Primary
    @Bean
    public DataSource primaryDataSource() {
        return primaryDataSourceProperties()
                .initializeDataSourceBuilder()
                .build();
    }

    @Primary
    @Bean
    public LocalContainerEntityManagerFactoryBean primaryEntityManagerFactory(
            EntityManagerFactoryBuilder builder) {
        return builder
                .dataSource(primaryDataSource())
                .packages(&quot;com.example.primary.entity&quot;)
                .persistenceUnit(&quot;primary&quot;)
                .properties(hibernateProperties())
                .build();
    }

    @Primary
    @Bean
    public PlatformTransactionManager primaryTransactionManager(
            @Qualifier(&quot;primaryEntityManagerFactory&quot;) EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }

    private Map&lt;String, Object&gt; hibernateProperties() {
        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
        props.put(&quot;hibernate.hbm2ddl.auto&quot;, &quot;update&quot;);
        props.put(&quot;hibernate.dialect&quot;, &quot;org.hibernate.dialect.MySQL8Dialect&quot;);
        return props;
    }
}
</code></pre>
<ol start="3">
    <li><strong>Secondary Data Source Configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
    basePackages = &quot;com.example.secondary.repository&quot;,
    entityManagerFactoryRef = &quot;secondaryEntityManagerFactory&quot;,
    transactionManagerRef = &quot;secondaryTransactionManager&quot;
)
public class SecondaryDataSourceConfig {

    @Bean
    @ConfigurationProperties(&quot;spring.datasource.secondary&quot;)
    public DataSourceProperties secondaryDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    public DataSource secondaryDataSource() {
        return secondaryDataSourceProperties()
                .initializeDataSourceBuilder()
                .build();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean secondaryEntityManagerFactory(
            EntityManagerFactoryBuilder builder) {
        return builder
                .dataSource(secondaryDataSource())
                .packages(&quot;com.example.secondary.entity&quot;)
                .persistenceUnit(&quot;secondary&quot;)
                .properties(hibernateProperties())
                .build();
    }

    @Bean
    public PlatformTransactionManager secondaryTransactionManager(
            @Qualifier(&quot;secondaryEntityManagerFactory&quot;) EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }

    private Map&lt;String, Object&gt; hibernateProperties() {
        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
        props.put(&quot;hibernate.hbm2ddl.auto&quot;, &quot;update&quot;);
        props.put(&quot;hibernate.dialect&quot;, &quot;org.hibernate.dialect.PostgreSQLDialect&quot;);
        return props;
    }
}
</code></pre>
<ol start="4">
    <li><strong>Package Structure</strong>:</li>
</ol>
<p>Organize entities and repositories in separate packages:</p>
<pre><code>com.example
├── primary
│   ├── entity
│   │   └── User.java
│   └── repository
│       └── UserRepository.java
└── secondary
    ├── entity
    │   └── Product.java
    └── repository
        └── ProductRepository.java
</code></pre>
<ol start="5">
    <li><strong>Entity Classes</strong>:</li>
</ol>
<pre><code class="language-java">// Primary database entity
package com.example.primary.entity;

@Entity
@Table(name = &quot;users&quot;)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String username;
    // getters, setters
}

// Secondary database entity
package com.example.secondary.entity;

@Entity
@Table(name = &quot;products&quot;)
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    // getters, setters
}
</code></pre>
<ol start="6">
    <li><strong>Repository Interfaces</strong>:</li>
</ol>
<pre><code class="language-java">// Primary database repository
package com.example.primary.repository;

@Repository
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    // methods
}

// Secondary database repository
package com.example.secondary.repository;

@Repository
public interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {
    // methods
}
</code></pre>
<ol start="7">
    <li><strong>Service Layer</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional(&quot;primaryTransactionManager&quot;)  // Specify which transaction manager to use
    public User saveUser(User user) {
        return userRepository.save(user);
    }
}

@Service
public class ProductService {
    private final ProductRepository productRepository;

    public ProductService(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    @Transactional(&quot;secondaryTransactionManager&quot;)  // Specify which transaction manager to use
    public Product saveProduct(Product product) {
        return productRepository.save(product);
    }
}
</code></pre>
<p><strong>Alternative Approach Using AbstractRoutingDataSource</strong>:</p>
<p>For dynamic data source switching (like multi-tenancy):</p>
<pre><code class="language-java">public class TenantRoutingDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return TenantContext.getCurrentTenant();
    }
}

@Configuration
public class MultiTenantDataSourceConfig {

    @Bean
    public DataSource dataSource() {
        Map&lt;Object, Object&gt; dataSources = new HashMap&lt;&gt;();
        dataSources.put(&quot;tenant1&quot;, tenant1DataSource());
        dataSources.put(&quot;tenant2&quot;, tenant2DataSource());

        TenantRoutingDataSource routingDataSource = new TenantRoutingDataSource();
        routingDataSource.setTargetDataSources(dataSources);
        routingDataSource.setDefaultTargetDataSource(tenant1DataSource());

        return routingDataSource;
    }

    @Bean
    @ConfigurationProperties(&quot;spring.datasource.tenant1&quot;)
    public DataSource tenant1DataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @ConfigurationProperties(&quot;spring.datasource.tenant2&quot;)
    public DataSource tenant2DataSource() {
        return DataSourceBuilder.create().build();
    }
}
</code></pre>
<p><strong>Best Practices for Multiple Data Sources:</strong></p>
<ol>
    <li><p><strong>Use @Primary</strong>: Always mark one data source configuration as primary to avoid ambiguity</p>
    </li>
    <li><p><strong>Package Organization</strong>: Keep entities and repositories for different data sources in separate packages</p>
    </li>
    <li><p><strong>Transaction Management</strong>: Be explicit about which transaction manager to use with <code>@Transactional</code></p>
    </li>
    <li><p><strong>Connection Pool Configuration</strong>: Configure connection pools separately for each data source</p>
    </li>
    <li><p><strong>Health Checks</strong>: Configure health indicators for each data source</p>
    </li>
    <li><p><strong>Avoid Cross-Database Joins</strong>: Since they&#39;re separate databases, design your domain to avoid joining across them</p>
    </li>
    <li><p><strong>Testing</strong>: Test each data source configuration separately and also test their interaction</p>
    </li>
    <li><p><strong>Monitoring</strong>: Set up monitoring metrics for each data source</p>
    </li>
</ol>
<h3 id="41-how-do-you-integrate-nosql-databases-like-mongodb-with-spring-boot">41. How do you integrate NoSQL databases like MongoDB with Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot provides seamless integration with NoSQL databases like MongoDB through its auto-configuration and starter dependencies. This allows developers to quickly set up and use MongoDB in their applications without extensive configuration.</p>
<p><strong>1. Basic MongoDB Integration:</strong></p>
<p>Add dependency:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Configure connection in application.properties:</p>
<pre><code class="language-properties"># MongoDB Configuration
spring.data.mongodb.host=localhost
spring.data.mongodb.port=27017
spring.data.mongodb.database=mydb
spring.data.mongodb.username=user
spring.data.mongodb.password=secret

# For MongoDB URI style connection
#spring.data.mongodb.uri=mongodb://user:secret@localhost:27017/mydb
</code></pre>
<p><strong>2. Document Class:</strong></p>
<pre><code class="language-java">@Document(collection = &quot;products&quot;)
public class Product {
    @Id
    private String id;

    private String name;

    private BigDecimal price;

    @Field(&quot;product_description&quot;)
    private String description;

    @CreatedDate
    private Date createdAt;

    @LastModifiedDate
    private Date updatedAt;

    // getters and setters
}
</code></pre>
<p><strong>3. Spring Data MongoDB Repository:</strong></p>
<pre><code class="language-java">public interface ProductRepository extends MongoRepository&lt;Product, String&gt; {
    // Finder methods
    List&lt;Product&gt; findByNameContaining(String name);

    Optional&lt;Product&gt; findByName(String name);

    List&lt;Product&gt; findByPriceLessThan(BigDecimal price);

    // Custom query
    @Query(&quot;{ &#39;price&#39; : { $lt: ?0 }, &#39;name&#39;: { $regex: ?1, $options: &#39;i&#39; }}&quot;)
    List&lt;Product&gt; findCheapProductsWithName(BigDecimal price, String name);

    // Pageable and sorted queries
    Page&lt;Product&gt; findByNameContaining(String name, Pageable pageable);
}
</code></pre>
<p><strong>4. Enable MongoDB Auditing:</strong></p>
<pre><code class="language-java">@Configuration
@EnableMongoAuditing
public class MongoConfig {
    // Additional MongoDB configuration if needed
}
</code></pre>
<p><strong>5. Service Layer:</strong></p>
<pre><code class="language-java">@Service
public class ProductService {
    private final ProductRepository productRepository;

    public ProductService(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    public Product saveProduct(Product product) {
        return productRepository.save(product);
    }

    public List&lt;Product&gt; findProducts(String nameFilter, BigDecimal maxPrice, int page, int size) {
        PageRequest pageRequest = PageRequest.of(page, size, Sort.by(&quot;price&quot;).ascending());

        if (nameFilter != null &amp;&amp; maxPrice != null) {
            return productRepository.findCheapProductsWithName(maxPrice, nameFilter);
        } else if (nameFilter != null) {
            return productRepository.findByNameContaining(nameFilter, pageRequest).getContent();
        } else if (maxPrice != null) {
            return productRepository.findByPriceLessThan(maxPrice);
        } else {
            return productRepository.findAll(pageRequest).getContent();
        }
    }
}
</code></pre>
<p><strong>6. MongoTemplate for Advanced Operations:</strong></p>
<pre><code class="language-java">@Service
public class AdvancedProductService {
    private final MongoTemplate mongoTemplate;

    public AdvancedProductService(MongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    public List&lt;Product&gt; findComplexQuery(String namePattern,
                                         BigDecimal minPrice,
                                         BigDecimal maxPrice) {
        Query query = new Query();

        if (namePattern != null) {
            query.addCriteria(Criteria.where(&quot;name&quot;).regex(namePattern, &quot;i&quot;));
        }

        if (minPrice != null &amp;&amp; maxPrice != null) {
            query.addCriteria(
                Criteria.where(&quot;price&quot;).gte(minPrice).lte(maxPrice)
            );
        } else if (minPrice != null) {
            query.addCriteria(Criteria.where(&quot;price&quot;).gte(minPrice));
        } else if (maxPrice != null) {
            query.addCriteria(Criteria.where(&quot;price&quot;).lte(maxPrice));
        }

        query.with(Sort.by(Sort.Direction.ASC, &quot;price&quot;));

        return mongoTemplate.find(query, Product.class);
    }

    public void updateAllPrices(BigDecimal priceIncrease) {
        Query query = new Query();
        Update update = new Update().inc(&quot;price&quot;, priceIncrease);

        UpdateResult result = mongoTemplate.updateMulti(
            query, update, Product.class
        );

        System.out.println(&quot;Documents updated: &quot; + result.getModifiedCount());
    }

    public List&lt;CategoryCount&gt; getProductCountsByPriceRange() {
        TypedAggregation&lt;Product&gt; aggregation = Aggregation.newAggregation(
            Product.class,
            Aggregation.project(&quot;price&quot;),
            Aggregation.match(Criteria.where(&quot;price&quot;).exists(true)),
            Aggregation.bucket(&quot;price&quot;)
                .withBoundaries(0, 10, 50, 100, 1000)
                .withDefaultBucket(&quot;Other&quot;)
                .andOutputCount().as(&quot;count&quot;)
        );

        AggregationResults&lt;CategoryCount&gt; results = mongoTemplate.aggregate(
            aggregation, CategoryCount.class
        );

        return results.getMappedResults();
    }
}

public class CategoryCount {
    private String id;
    private int count;
    // getters and setters
}
</code></pre>
<p><strong>7. Integration with MongoDB Transactions:</strong></p>
<p>MongoDB 4.0+ supports multi-document transactions:</p>
<pre><code class="language-java">@Service
public class OrderService {
    private final MongoTemplate mongoTemplate;
    private final MongoDatabaseFactory dbFactory;

    public OrderService(MongoTemplate mongoTemplate, MongoDatabaseFactory dbFactory) {
        this.mongoTemplate = mongoTemplate;
        this.dbFactory = dbFactory;
    }

    public void createOrderWithItems(Order order, List&lt;OrderItem&gt; items) {
        // Get a client session
        ClientSession session = dbFactory.getSession(ClientSessionOptions.builder().build());

        // Start a transaction
        session.startTransaction();

        try {
            // Save the order
            mongoTemplate.insert(order, session);

            // Set order reference and save items
            items.forEach(item -&gt; item.setOrderId(order.getId()));
            mongoTemplate.insertAll(items, session);

            // Commit the transaction
            session.commitTransaction();
        } catch (Exception e) {
            // Abort the transaction on error
            session.abortTransaction();
            throw e;
        } finally {
            session.close();
        }
    }
}
</code></pre>
<p><strong>8. Testing with Embedded MongoDB:</strong></p>
<p>For unit testing, add embedded MongoDB:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;de.flapdoodle.embed&lt;/groupId&gt;
    &lt;artifactId&gt;de.flapdoodle.embed.mongo&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>Write tests:</p>
<pre><code class="language-java">@DataMongoTest
class ProductRepositoryTest {
    @Autowired
    private ProductRepository productRepository;

    @BeforeEach
    void setup() {
        productRepository.deleteAll();

        productRepository.save(new Product(null, &quot;Product A&quot;, new BigDecimal(&quot;19.99&quot;), &quot;Description A&quot;));
        productRepository.save(new Product(null, &quot;Product B&quot;, new BigDecimal(&quot;29.99&quot;), &quot;Description B&quot;));
    }

    @Test
    void testFindByNameContaining() {
        List&lt;Product&gt; products = productRepository.findByNameContaining(&quot;Product&quot;);

        assertEquals(2, products.size());
    }

    @Test
    void testFindByPriceLessThan() {
        List&lt;Product&gt; products = productRepository.findByPriceLessThan(new BigDecimal(&quot;25.00&quot;));

        assertEquals(1, products.size());
        assertEquals(&quot;Product A&quot;, products.get(0).getName());
    }
}
</code></pre>
<p><strong>9. Advanced Configuration:</strong></p>
<p>For more complex scenarios:</p>
<pre><code class="language-java">@Configuration
public class AdvancedMongoConfig {

    @Bean
    public MongoClient mongoClient() {
        MongoClientSettings settings = MongoClientSettings.builder()
            .applyConnectionString(new ConnectionString(&quot;mongodb://localhost:27017&quot;))
            .applyToConnectionPoolSettings(builder -&gt;
                builder.maxSize(100).minSize(10))
            .applyToSocketSettings(builder -&gt;
                builder.connectTimeout(5, TimeUnit.SECONDS))
            .retryWrites(true)
            .build();

        return MongoClients.create(settings);
    }

    @Bean
    public MongoDatabaseFactory mongoDatabaseFactory(MongoClient mongoClient) {
        return new SimpleMongoClientDatabaseFactory(mongoClient, &quot;mydb&quot;);
    }

    @Bean
    public MongoTemplate mongoTemplate(MongoDatabaseFactory mongoDatabaseFactory) {
        MongoTemplate template = new MongoTemplate(mongoDatabaseFactory);

        // Custom converters if needed
        MappingMongoConverter converter = (MappingMongoConverter) template.getConverter();
        converter.setCustomConversions(customConversions());
        converter.afterPropertiesSet();

        return template;
    }

    @Bean
    public CustomConversions customConversions() {
        return new CustomConversions(MongoCustomConversions.DEFAULT_CONVERTERS);
    }
}
</code></pre>
<p><strong>10. Multi-Database MongoDB Configuration:</strong></p>
<pre><code class="language-java">@Configuration
public class MultiMongoConfig {

    @Primary
    @Bean(name = &quot;primaryMongoTemplate&quot;)
    public MongoTemplate primaryMongoTemplate() {
        return new MongoTemplate(
            MongoClients.create(&quot;mongodb://localhost:27017&quot;),
            &quot;primaryDb&quot;
        );
    }

    @Bean(name = &quot;secondaryMongoTemplate&quot;)
    public MongoTemplate secondaryMongoTemplate() {
        return new MongoTemplate(
            MongoClients.create(&quot;mongodb://localhost:27017&quot;),
            &quot;secondaryDb&quot;
        );
    }
}
</code></pre>
<p>Spring Boot&#39;s MongoDB integration is comprehensive and allows for everything from simple CRUD operations to complex aggregations and transactions, making it suitable for a wide range of NoSQL database use cases.</p>
<h3 id="42-how-do-you-handle-database-migrations-in-spring-boot">42. How do you handle database migrations in Spring Boot?</h3>
<p><strong>Answer:</strong> Database migrations in Spring Boot are typically handled using tools like Flyway or Liquibase, which provide version control for database schemas. These tools ensure consistent, repeatable, and automated database schema evolution across different environments.</p>
<p><strong>1. Using Flyway for Database Migrations:</strong></p>
<p>Add the dependency:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;
    &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Configure in application.properties:</p>
<pre><code class="language-properties"># Basic configuration
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true

# Optional settings
spring.flyway.schemas=public
spring.flyway.table=flyway_schema_history
spring.flyway.validate-on-migrate=true
spring.flyway.clean-disabled=true
</code></pre>
<p>Create migration scripts following the naming convention:</p>
<pre><code>V1__Create_users_table.sql
V2__Add_email_column.sql
V2.1__Add_indexes.sql
</code></pre>
<p>Example migration scripts:</p>
<pre><code class="language-sql">-- V1__Create_users_table.sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(100) NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- V2__Add_email_column.sql
ALTER TABLE users ADD COLUMN email VARCHAR(255);
CREATE UNIQUE INDEX idx_users_email ON users(email);
</code></pre>
<p>Programmatically control Flyway:</p>
<pre><code class="language-java">@Component
public class FlywayMigrationInitializer {

    private final Flyway flyway;

    public FlywayMigrationInitializer(Flyway flyway) {
        this.flyway = flyway;
    }

    @PostConstruct
    public void migrateFlyway() {
        flyway.migrate();
    }
}
</code></pre>
<p><strong>2. Using Liquibase for Database Migrations:</strong></p>
<p>Add the dependency:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.liquibase&lt;/groupId&gt;
    &lt;artifactId&gt;liquibase-core&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Configure in application.properties:</p>
<pre><code class="language-properties"># Basic configuration
spring.liquibase.enabled=true
spring.liquibase.change-log=classpath:db/changelog/db.changelog-master.xml

# Optional settings
spring.liquibase.contexts=development
spring.liquibase.default-schema=public
spring.liquibase.drop-first=false
spring.liquibase.parameters.author=dev-team
</code></pre>
<p>Create a master changelog:</p>
<pre><code class="language-xml">&lt;!-- db.changelog-master.xml --&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;databaseChangeLog
    xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog
                        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.5.xsd&quot;&gt;

    &lt;include file=&quot;db/changelog/changes/01-create-users-table.xml&quot;/&gt;
    &lt;include file=&quot;db/changelog/changes/02-add-email-column.xml&quot;/&gt;
    &lt;include file=&quot;db/changelog/changes/03-create-orders-table.xml&quot;/&gt;
&lt;/databaseChangeLog&gt;
</code></pre>
<p>Example changelog files:</p>
<pre><code class="language-xml">&lt;!-- 01-create-users-table.xml --&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;databaseChangeLog
    xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog
                        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.5.xsd&quot;&gt;

    &lt;changeSet id=&quot;1&quot; author=&quot;${author}&quot;&gt;
        &lt;createTable tableName=&quot;users&quot;&gt;
            &lt;column name=&quot;id&quot; type=&quot;BIGINT&quot; autoIncrement=&quot;true&quot;&gt;
                &lt;constraints primaryKey=&quot;true&quot; nullable=&quot;false&quot;/&gt;
            &lt;/column&gt;
            &lt;column name=&quot;username&quot; type=&quot;VARCHAR(100)&quot;&gt;
                &lt;constraints nullable=&quot;false&quot;/&gt;
            &lt;/column&gt;
            &lt;column name=&quot;password&quot; type=&quot;VARCHAR(255)&quot;&gt;
                &lt;constraints nullable=&quot;false&quot;/&gt;
            &lt;/column&gt;
            &lt;column name=&quot;created_at&quot; type=&quot;TIMESTAMP&quot; defaultValueComputed=&quot;CURRENT_TIMESTAMP&quot;/&gt;
        &lt;/createTable&gt;
    &lt;/changeSet&gt;
&lt;/databaseChangeLog&gt;

&lt;!-- 02-add-email-column.xml --&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;databaseChangeLog
    xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog
                        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.5.xsd&quot;&gt;

    &lt;changeSet id=&quot;2&quot; author=&quot;${author}&quot;&gt;
        &lt;addColumn tableName=&quot;users&quot;&gt;
            &lt;column name=&quot;email&quot; type=&quot;VARCHAR(255)&quot;/&gt;
        &lt;/addColumn&gt;

        &lt;createIndex tableName=&quot;users&quot; indexName=&quot;idx_users_email&quot;&gt;
            &lt;column name=&quot;email&quot;/&gt;
            &lt;constraints unique=&quot;true&quot;/&gt;
        &lt;/createIndex&gt;
    &lt;/changeSet&gt;
&lt;/databaseChangeLog&gt;
</code></pre>
<p>Using SQL format with Liquibase:</p>
<pre><code class="language-xml">&lt;!-- db.changelog-master.xml --&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;databaseChangeLog
    xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog
                        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.5.xsd&quot;&gt;

    &lt;includeAll path=&quot;db/changelog/changes/sql/&quot; relativeToChangelogFile=&quot;false&quot;/&gt;
&lt;/databaseChangeLog&gt;
</code></pre>
<p>SQL migration files:</p>
<pre><code class="language-sql">-- 01_create_users_table.sql
--liquibase formatted sql
--changeset author:1
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(100) NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
--rollback DROP TABLE users;
</code></pre>
<p><strong>3. Handling Multiple Environments:</strong></p>
<p>With Flyway:</p>
<pre><code class="language-properties"># Development
spring.flyway.locations=classpath:db/migration,classpath:db/migration/dev

# Production
spring.flyway.locations=classpath:db/migration,classpath:db/migration/prod
</code></pre>
<p>With Liquibase contexts:</p>
<pre><code class="language-xml">&lt;changeSet id=&quot;3&quot; author=&quot;developer&quot; context=&quot;dev,qa&quot;&gt;
    &lt;insert tableName=&quot;users&quot;&gt;
        &lt;column name=&quot;username&quot; value=&quot;testuser&quot;/&gt;
        &lt;column name=&quot;password&quot; value=&quot;password&quot;/&gt;
    &lt;/insert&gt;
&lt;/changeSet&gt;
</code></pre>
<p>And activate specific contexts:</p>
<pre><code class="language-properties">spring.liquibase.contexts=dev
</code></pre>
<p><strong>4. Handling Special Cases:</strong></p>
<p>Database-specific migrations with Flyway:</p>
<pre><code>V1__Create_tables.sql          # Default script
V1__Create_tables_mysql.sql    # MySQL-specific version
V1__Create_tables_postgres.sql # PostgreSQL-specific version
</code></pre>
<p>Conditional execution with Liquibase:</p>
<pre><code class="language-xml">&lt;changeSet id=&quot;4&quot; author=&quot;developer&quot;&gt;
    &lt;preConditions onFail=&quot;MARK_RAN&quot;&gt;
        &lt;not&gt;
            &lt;tableExists tableName=&quot;audit_logs&quot;/&gt;
        &lt;/not&gt;
    &lt;/preConditions&gt;

    &lt;createTable tableName=&quot;audit_logs&quot;&gt;
        &lt;!-- columns --&gt;
    &lt;/createTable&gt;
&lt;/changeSet&gt;
</code></pre>
<p><strong>5. Java-based Migrations:</strong></p>
<p>With Flyway:</p>
<pre><code class="language-java">@Component
public class V3__UpdateUserData implements SpringJdbcMigration {

    @Override
    public void migrate(JdbcTemplate jdbcTemplate) throws Exception {
        jdbcTemplate.update(
            &quot;UPDATE users SET status = &#39;ACTIVE&#39; WHERE created_at &gt; ?&quot;,
            LocalDate.now().minusMonths(3)
        );
    }
}
</code></pre>
<p>With Liquibase:</p>
<pre><code class="language-java">public class AddDefaultUsers implements CustomTaskChange {

    @Override
    public void execute(Database database) throws CustomChangeException {
        try {
            JdbcConnection connection = (JdbcConnection) database.getConnection();

            PreparedStatement stmt = connection.prepareStatement(
                &quot;INSERT INTO users (username, email, password) VALUES (?, ?, ?)&quot;
            );

            stmt.setString(1, &quot;admin&quot;);
            stmt.setString(2, &quot;admin@example.com&quot;);
            stmt.setString(3, &quot;$2a$10$...&quot;);  // Encoded password
            stmt.executeUpdate();

            stmt.close();
        } catch (Exception e) {
            throw new CustomChangeException(&quot;Error adding default users&quot;, e);
        }
    }

    // Other required methods...
}
</code></pre>
<p><strong>6. Best Practices:</strong></p>
<ol>
    <li><p><strong>Version Control</strong>: Keep migration scripts in version control along with application code</p>
    </li>
    <li><p><strong>Repeatable Migrations</strong>:</p>
        <ul>
            <li>Flyway: Use <code>R__description.sql</code> for repeatable scripts that run after versioned migrations</li>
            <li>Liquibase: Use <code>runAlways=&quot;true&quot;</code> in changesets</li>
        </ul>
    </li>
    <li><p><strong>Idempotent Changes</strong>: Design migrations to be safely re-runnable</p>
    </li>
    <li><p><strong>Testing</strong>: Test migrations on a copy of production data before deploying</p>
    </li>
    <li><p><strong>Rollback Planning</strong>: Include rollback instructions</p>
        <ul>
            <li>Flyway: Requires manual implementation using callbacks</li>
            <li>Liquibase: Supports automatic rollbacks with <code>&lt;rollback&gt;</code> tags</li>
        </ul>
    </li>
    <li><p><strong>Baseline Existing Databases</strong>: Use baseline features for existing databases</p>
    </li>
    <li><p><strong>Gradual Schema Changes</strong>: Follow patterns for zero-downtime schema changes</p>
        <pre><code>1. Add new nullable column
2. Deploy code that writes to both old and new structures
3. Migrate existing data
4. Deploy code that reads from new structure
5. Remove old structure
</code></pre>
    </li>
    <li><p><strong>Validate Migrations</strong>: Enable validation to ensure consistency</p>
    </li>
    <li><p><strong>Separate DDL and DML</strong>: Keep schema changes separate from data changes when possible</p>
    </li>
    <li><p><strong>Documentation</strong>: Document complex migrations and their purpose</p>
    </li>
</ol>
<p>Database migration tools in Spring Boot provide a structured approach to schema evolution, making database changes more reliable, auditable, and repeatable across all environments.</p>
<h2 id="section-5-building-rest-apis-with-spring-boot-1">Section 5: Building REST APIs with Spring Boot</h2>
<h3 id="43-how-do-you-create-a-restful-web-service-with-spring-boot">43. How do you create a RESTful web service with Spring Boot?</h3>
<p><strong>Answer:</strong> Creating a RESTful web service with Spring Boot is straightforward due to its auto-configuration capabilities and built-in support for Spring MVC. Here&#39;s a comprehensive guide to building RESTful APIs with Spring Boot:</p>
<p><strong>1. Set up the project with the required dependencies:</strong></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>2. Create a model class to represent resources:</strong></p>
<pre><code class="language-java">public class Product {
    private Long id;
    private String name;
    private String description;
    private BigDecimal price;

    // Constructors, getters, setters
}
</code></pre>
<p><strong>3. Create a REST controller to handle HTTP requests:</strong></p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    // GET all products
    @GetMapping
    public List&lt;Product&gt; getAllProducts() {
        return productService.findAllProducts();
    }

    // GET a product by ID
    @GetMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;Product&gt; getProductById(@PathVariable Long id) {
        return productService.findProductById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    // CREATE a new product
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Product createProduct(@RequestBody @Valid Product product) {
        return productService.saveProduct(product);
    }

    // UPDATE an existing product
    @PutMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;Product&gt; updateProduct(@PathVariable Long id,
                                               @RequestBody @Valid Product product) {
        return productService.findProductById(id)
                .map(existingProduct -&gt; {
                    product.setId(id);
                    return ResponseEntity.ok(productService.saveProduct(product));
                })
                .orElse(ResponseEntity.notFound().build());
    }

    // DELETE a product
    @DeleteMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;Void&gt; deleteProduct(@PathVariable Long id) {
        return productService.findProductById(id)
                .map(product -&gt; {
                    productService.deleteProductById(id);
                    return ResponseEntity.noContent().&lt;Void&gt;build();
                })
                .orElse(ResponseEntity.notFound().build());
    }

    // Search products
    @GetMapping(&quot;/search&quot;)
    public List&lt;Product&gt; searchProducts(@RequestParam(required = false) String name,
                                      @RequestParam(required = false) BigDecimal minPrice,
                                      @RequestParam(required = false) BigDecimal maxPrice) {
        return productService.searchProducts(name, minPrice, maxPrice);
    }
}
</code></pre>
<p><strong>4. Create a service layer to handle business logic:</strong></p>
<pre><code class="language-java">@Service
public class ProductService {

    private final ProductRepository productRepository;

    public ProductService(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    public List&lt;Product&gt; findAllProducts() {
        return productRepository.findAll();
    }

    public Optional&lt;Product&gt; findProductById(Long id) {
        return productRepository.findById(id);
    }

    public Product saveProduct(Product product) {
        return productRepository.save(product);
    }

    public void deleteProductById(Long id) {
        productRepository.deleteById(id);
    }

    public List&lt;Product&gt; searchProducts(String name, BigDecimal minPrice, BigDecimal maxPrice) {
        // Implementation of search logic
        return productRepository.search(name, minPrice, maxPrice);
    }
}
</code></pre>
<p><strong>5. Configure application properties:</strong></p>
<pre><code class="language-properties"># Server port
server.port=8080

# Context path
server.servlet.context-path=/

# JSON serialization
spring.jackson.serialization.write-dates-as-timestamps=false
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss

# Logging
logging.level.org.springframework.web=INFO
</code></pre>
<p><strong>6. Add input validation:</strong></p>
<pre><code class="language-java">public class Product {
    private Long id;

    @NotBlank(message = &quot;Name is required&quot;)
    @Size(min = 2, max = 100, message = &quot;Name must be between 2 and 100 characters&quot;)
    private String name;

    @Size(max = 500, message = &quot;Description cannot exceed 500 characters&quot;)
    private String description;

    @NotNull(message = &quot;Price is required&quot;)
    @DecimalMin(value = &quot;0.01&quot;, message = &quot;Price must be greater than 0&quot;)
    private BigDecimal price;

    // Constructors, getters, setters
}
</code></pre>
<p><strong>7. Add error handling:</strong></p>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleResourceNotFound(ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            LocalDateTime.now()
        );
        return new ResponseEntity&lt;&gt;(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
        ex.getBindingResult().getAllErrors().forEach(error -&gt; {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        ErrorResponse error = new ErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            &quot;Validation Error&quot;,
            LocalDateTime.now(),
            errors
        );
        return new ResponseEntity&lt;&gt;(error, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            &quot;An unexpected error occurred&quot;,
            LocalDateTime.now()
        );
        return new ResponseEntity&lt;&gt;(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

public class ErrorResponse {
    private int status;
    private String message;
    private LocalDateTime timestamp;
    private Map&lt;String, String&gt; errors;

    // Constructors, getters, setters
}

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
</code></pre>
<p><strong>8. Add pagination and sorting:</strong></p>
<pre><code class="language-java">@GetMapping
public Page&lt;Product&gt; getAllProducts(
        @RequestParam(defaultValue = &quot;0&quot;) int page,
        @RequestParam(defaultValue = &quot;10&quot;) int size,
        @RequestParam(defaultValue = &quot;id&quot;) String sortBy,
        @RequestParam(defaultValue = &quot;asc&quot;) String direction) {

    Sort.Direction sortDirection = direction.equalsIgnoreCase(&quot;asc&quot;) ?
            Sort.Direction.ASC : Sort.Direction.DESC;

    PageRequest pageRequest = PageRequest.of(page, size, sortDirection, sortBy);

    return productService.findAllProducts(pageRequest);
}
</code></pre>
<p><strong>9. Implement HATEOAS (Hypermedia as the Engine of Application State):</strong></p>
<p>Add dependency:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Enhance the controller:</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    @GetMapping(&quot;/{id}&quot;)
    public EntityModel&lt;Product&gt; getProductById(@PathVariable Long id) {
        Product product = productService.findProductById(id)
                .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Product not found with id: &quot; + id));

        return EntityModel.of(product,
                linkTo(methodOn(ProductController.class).getProductById(id)).withSelfRel(),
                linkTo(methodOn(ProductController.class).getAllProducts(0, 10, &quot;id&quot;, &quot;asc&quot;))
                        .withRel(&quot;products&quot;));
    }

    @GetMapping
    public CollectionModel&lt;EntityModel&lt;Product&gt;&gt; getAllProducts(
            @RequestParam(defaultValue = &quot;0&quot;) int page,
            @RequestParam(defaultValue = &quot;10&quot;) int size,
            @RequestParam(defaultValue = &quot;id&quot;) String sortBy,
            @RequestParam(defaultValue = &quot;asc&quot;) String direction) {

        Page&lt;Product&gt; productPage = productService.findAllProducts(
            PageRequest.of(page, size,
                direction.equalsIgnoreCase(&quot;asc&quot;) ? Sort.Direction.ASC : Sort.Direction.DESC,
                sortBy)
        );

        List&lt;EntityModel&lt;Product&gt;&gt; products = productPage.getContent().stream()
                .map(product -&gt; EntityModel.of(product,
                        linkTo(methodOn(ProductController.class).getProductById(product.getId()))
                                .withSelfRel()))
                .collect(Collectors.toList());

        return CollectionModel.of(products,
                linkTo(methodOn(ProductController.class).getAllProducts(page, size, sortBy, direction))
                        .withSelfRel());
    }
}
</code></pre>
<p><strong>10. Add Content Negotiation:</strong></p>
<pre><code class="language-java">@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
        configurer
            .defaultContentType(MediaType.APPLICATION_JSON)
            .favorParameter(true)
            .parameterName(&quot;format&quot;)
            .ignoreAcceptHeader(false)
            .useRegisteredExtensionsOnly(false)
            .mediaType(&quot;json&quot;, MediaType.APPLICATION_JSON)
            .mediaType(&quot;xml&quot;, MediaType.APPLICATION_XML);
    }
}
</code></pre>
<p>Add XML support:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>11. Secure the API:</strong></p>
<p>Add dependency:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Basic configuration:</p>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeRequests()
                .antMatchers(HttpMethod.GET, &quot;/api/products/**&quot;).permitAll()
                .antMatchers(&quot;/api/**&quot;).authenticated()
                .anyRequest().permitAll()
            .and()
            .httpBasic();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
            .withUser(&quot;admin&quot;)
            .password(passwordEncoder().encode(&quot;password&quot;))
            .authorities(&quot;ADMIN&quot;);
    }
}
</code></pre>
<p><strong>12. Document the API with Springdoc-OpenAPI:</strong></p>
<p>Add dependency:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;
    &lt;artifactId&gt;springdoc-openapi-ui&lt;/artifactId&gt;
    &lt;version&gt;1.6.9&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Configure OpenAPI:</p>
<pre><code class="language-java">@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title(&quot;Product API&quot;)
                        .version(&quot;1.0&quot;)
                        .description(&quot;Documentation for Product REST API&quot;)
                        .contact(new Contact()
                                .name(&quot;API Support&quot;)
                                .email(&quot;support@example.com&quot;))
                );
    }
}
</code></pre>
<p>Annotate controller:</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
@Tag(name = &quot;Product Management&quot;, description = &quot;Operations pertaining to products&quot;)
public class ProductController {

    @Operation(summary = &quot;Get a product by ID&quot;,
               description = &quot;Returns a single product by ID&quot;)
    @ApiResponses(value = {
        @ApiResponse(responseCode = &quot;200&quot;,
                    description = &quot;Successfully retrieved product&quot;,
                    content = {@Content(mediaType = &quot;application/json&quot;,
                              schema = @Schema(implementation = Product.class))}),
        @ApiResponse(responseCode = &quot;404&quot;,
                    description = &quot;Product not found&quot;,
                    content = @Content)
    })
    @GetMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;Product&gt; getProductById(@PathVariable Long id) {
        // implementation
    }

    // Other methods with OpenAPI annotations
}
</code></pre>
<p><strong>13. Rate Limiting:</strong></p>
<p>Add Bucket4j dependency:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.vladimir-bukhtoyarov&lt;/groupId&gt;
    &lt;artifactId&gt;bucket4j-core&lt;/artifactId&gt;
    &lt;version&gt;4.10.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Implement rate limiting:</p>
<pre><code class="language-java">@Component
public class RateLimitingInterceptor implements HandlerInterceptor {

    private final Bucket bucket;

    public RateLimitingInterceptor() {
        Bandwidth limit = Bandwidth.classic(20, Refill.greedy(20, Duration.ofMinutes(1)));
        this.bucket = Bucket.builder().addLimit(limit).build();
    }

    @Override
    public boolean preHandle(HttpServletRequest request,
                           HttpServletResponse response,
                           Object handler) throws Exception {
        if (bucket.tryConsume(1)) {
            return true;
        } else {
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            response.getWriter().write(&quot;Too many requests - please try again later.&quot;);
            return false;
        }
    }
}

@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    private final RateLimitingInterceptor rateLimitingInterceptor;

    public WebMvcConfig(RateLimitingInterceptor rateLimitingInterceptor) {
        this.rateLimitingInterceptor = rateLimitingInterceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(rateLimitingInterceptor)
                .addPathPatterns(&quot;/api/**&quot;);
    }
}
</code></pre>
<p>These comprehensive steps cover the creation of a full-featured RESTful API with Spring Boot, including basic CRUD operations, validation, error handling, pagination, security, documentation, and advanced features like HATEOAS and rate limiting.</p>
<h3 id="44-what-are-the-differences-between-requestparam-and-pathvariable-annotations">44. What are the differences between @RequestParam and @PathVariable annotations?</h3>
<p><strong>Answer:</strong> <code>@RequestParam</code> and <code>@PathVariable</code> are both annotations used in Spring Boot to extract values from HTTP requests, but they serve different purposes and operate on different parts of the URL.</p>
<p><strong>@PathVariable:</strong></p>
<ol>
    <li><strong>Purpose</strong>: Extracts values from the URI path</li>
    <li><strong>Location</strong>: Used for template variables in the request URI path</li>
    <li><strong>URI Pattern</strong>: Example: <code>/users/{id}/orders/{orderId}</code></li>
    <li><strong>Parameter Style</strong>: Values are part of the URL path itself</li>
    <li><strong>Optional</strong>: Not optional by default, but can be configured</li>
    <li><strong>Default Value</strong>: Not applicable (though can be handled through the required attribute)</li>
    <li><strong>URL Encoding</strong>: Values are not URL encoded as they&#39;re part of the path</li>
    <li><strong>Use Case</strong>: Resource identification, hierarchical relationships</li>
</ol>
<p><strong>@RequestParam:</strong></p>
<ol>
    <li><strong>Purpose</strong>: Extracts values from query string parameters</li>
    <li><strong>Location</strong>: Used for query parameters in the request URL</li>
    <li><strong>URI Pattern</strong>: Example: <code>/users?id=123&amp;sort=asc</code></li>
    <li><strong>Parameter Style</strong>: Key-value pairs after the <code>?</code> in the URL</li>
    <li><strong>Optional</strong>: Optional by default in Spring 5+ (required=false is default)</li>
    <li><strong>Default Value</strong>: Can specify default value</li>
    <li><strong>URL Encoding</strong>: Values are typically URL encoded</li>
    <li><strong>Use Case</strong>: Filtering, sorting, pagination, optional parameters</li>
</ol>
<p><strong>Code Examples:</strong></p>
<p>Using @PathVariable:</p>
<pre><code class="language-java">@GetMapping(&quot;/users/{id}&quot;)
public ResponseEntity&lt;User&gt; getUserById(@PathVariable Long id) {
    // Retrieves the user with the specified id
    return userService.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
}

// Multiple path variables
@GetMapping(&quot;/users/{userId}/orders/{orderId}&quot;)
public Order getOrderForUser(
        @PathVariable Long userId,
        @PathVariable Long orderId) {
    return orderService.findOrderForUser(userId, orderId);
}

// Optional path variable (Spring 4.3.3+)
@GetMapping({&quot;/users/{id}&quot;, &quot;/users&quot;})
public List&lt;User&gt; getUserOrUsers(@PathVariable(required = false) Long id) {
    if (id != null) {
        return Collections.singletonList(userService.findById(id).orElse(null));
    } else {
        return userService.findAll();
    }
}

// Custom name
@GetMapping(&quot;/orders/{orderIdentifier}&quot;)
public Order getOrderById(@PathVariable(&quot;orderIdentifier&quot;) String orderId) {
    return orderService.findByOrderId(orderId);
}

// With type conversion
@GetMapping(&quot;/users/{id}/status/{active}&quot;)
public List&lt;User&gt; getUsersByStatus(
        @PathVariable Long id,
        @PathVariable boolean active) {
    // Spring automatically converts &quot;true&quot; or &quot;false&quot; to boolean
    return userService.findByIdAndStatus(id, active);
}
</code></pre>
<p>Using @RequestParam:</p>
<pre><code class="language-java">@GetMapping(&quot;/users&quot;)
public List&lt;User&gt; getUsers(@RequestParam(required = false) String name) {
    if (name != null) {
        return userService.findByName(name);
    } else {
        return userService.findAll();
    }
}

// Default values
@GetMapping(&quot;/products&quot;)
public List&lt;Product&gt; getProducts(
        @RequestParam(defaultValue = &quot;0&quot;) int page,
        @RequestParam(defaultValue = &quot;10&quot;) int size,
        @RequestParam(defaultValue = &quot;id&quot;) String sortBy) {
    return productService.findPaginated(page, size, sortBy);
}

// Multiple values
@GetMapping(&quot;/products/filter&quot;)
public List&lt;Product&gt; filterProducts(
        @RequestParam(required = false) List&lt;String&gt; categories) {
    return productService.findByCategories(categories);
}

// Map of values
@GetMapping(&quot;/products/search&quot;)
public List&lt;Product&gt; searchProducts(@RequestParam Map&lt;String, String&gt; params) {
    return productService.searchWithParams(params);
}

// Custom parameter name
@GetMapping(&quot;/users/search&quot;)
public List&lt;User&gt; searchUsers(@RequestParam(&quot;q&quot;) String searchTerm) {
    return userService.search(searchTerm);
}

// Value conversion
@GetMapping(&quot;/events&quot;)
public List&lt;Event&gt; getEvents(
        @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
        @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
    return eventService.findByDateRange(startDate, endDate != null ? endDate : LocalDate.now());
}
</code></pre>
<p><strong>Combining both annotations:</strong></p>
<pre><code class="language-java">@GetMapping(&quot;/users/{id}/orders&quot;)
public List&lt;Order&gt; getUserOrders(
        @PathVariable Long id,
        @RequestParam(defaultValue = &quot;0&quot;) int page,
        @RequestParam(defaultValue = &quot;10&quot;) int size,
        @RequestParam(defaultValue = &quot;createdAt&quot;) String sortBy,
        @RequestParam(defaultValue = &quot;desc&quot;) String direction) {

    Sort.Direction sortDirection = direction.equalsIgnoreCase(&quot;asc&quot;) ?
            Sort.Direction.ASC : Sort.Direction.DESC;

    PageRequest pageRequest = PageRequest.of(page, size, Sort.by(sortDirection, sortBy));

    return orderService.findByUserId(id, pageRequest).getContent();
}
</code></pre>
<p><strong>URL Examples:</strong></p>
<ul>
    <li><code>/users/42</code> - The path variable &quot;id&quot; has value &quot;42&quot;</li>
    <li><code>/users?id=42</code> - The request parameter &quot;id&quot; has value &quot;42&quot;</li>
    <li><code>/users/42/orders/123</code> - Path variables &quot;id&quot; = &quot;42&quot; and &quot;orderId&quot; = &quot;123&quot;</li>
    <li><code>/users?active=true&amp;role=admin</code> - Request parameters &quot;active&quot; = &quot;true&quot; and &quot;role&quot; = &quot;admin&quot;</li>
</ul>
<p><strong>Key Differences in Summary:</strong></p>
<ol>
    <li><p><strong>Usage</strong>: Path variables are part of the URL path structure defining the resource being requested, while request parameters provide optional arguments, filtering, or modifiers for the resource.</p>
    </li>
    <li><p><strong>Requirement</strong>: Path variables are typically mandatory (the endpoint won&#39;t match without them), while request parameters are generally optional.</p>
    </li>
    <li><p><strong>RESTful Design</strong>: Path variables align better with RESTful resource identification, while request parameters work well for filtering and optional modifiers.</p>
    </li>
    <li><p><strong>URL Generation</strong>: URLs with path variables are more bookmark-friendly and can be more SEO-friendly.</p>
    </li>
    <li><p><strong>Cacheability</strong>: URLs with path variables can be more easily cached by intermediate proxies.</p>
    </li>
</ol>
<p><strong>Best Practices:</strong></p>
<ul>
    <li>Use path variables for identifying resources or essential parts of the resource hierarchy</li>
    <li>Use request parameters for filtering, sorting, pagination, or optional parameters</li>
    <li>Don&#39;t put sensitive information in either (use POST body or headers instead)</li>
    <li>Keep URLs clean and meaningful - don&#39;t overuse either technique</li>
</ul>
<h3 id="45-how-do-you-handle-exceptions-in-spring-boot-rest-apis">45. How do you handle exceptions in Spring Boot REST APIs?</h3>
<p><strong>2. @ControllerAdvice / @RestControllerAdvice Global Level :</strong></p>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {

    // Previous handlers...

    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ErrorResponse handleGenericException(Exception ex) {
        return new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            &quot;An unexpected error occurred&quot;,
            LocalDateTime.now()
        );
    }

    // Handle validation exceptions from @Valid annotation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ErrorResponse handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();

        ex.getBindingResult().getAllErrors().forEach(error -&gt; {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        return new ErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            &quot;Validation Failed&quot;,
            LocalDateTime.now(),
            errors
        );
    }

    // Handle access denied exceptions
    @ExceptionHandler(AccessDeniedException.class)
    @ResponseStatus(HttpStatus.FORBIDDEN)
    public ErrorResponse handleAccessDeniedException() {
        return new ErrorResponse(
            HttpStatus.FORBIDDEN.value(),
            &quot;Access denied&quot;,
            LocalDateTime.now()
        );
    }
}
</code></pre>
<p><strong>3. ResponseStatusException Approach:</strong></p>
<p>For simpler scenarios or one-off exceptions:</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {

    @GetMapping(&quot;/{id}&quot;)
    public Product getProductById(@PathVariable Long id) {
        return productRepository.findById(id)
            .orElseThrow(() -&gt; new ResponseStatusException(
                HttpStatus.NOT_FOUND, &quot;Product not found with id: &quot; + id));
    }

    @PostMapping
    public Product createProduct(@RequestBody Product product) {
        if (product.getPrice().compareTo(BigDecimal.ZERO) &lt;= 0) {
            throw new ResponseStatusException(
                HttpStatus.BAD_REQUEST, &quot;Price must be greater than zero&quot;);
        }
        return productRepository.save(product);
    }
}
</code></pre>
<p><strong>4. Custom Exception Classes:</strong></p>
<p>Creating domain-specific exceptions enhances code readability:</p>
<pre><code class="language-java">public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

public class InvalidDataException extends RuntimeException {
    public InvalidDataException(String message) {
        super(message);
    }
}

// Usage
@Service
public class UserService {
    public User findById(Long id) {
        return userRepository.findById(id)
            .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;User not found with id: &quot; + id));
    }
}
</code></pre>
<p><strong>5. Standardized Error Response Format:</strong></p>
<p>Creating a consistent error response structure:</p>
<pre><code class="language-java">public class ErrorResponse {
    private int status;
    private String message;
    private LocalDateTime timestamp;
    private Map&lt;String, String&gt; errors;

    // Constructors
    public ErrorResponse(int status, String message, LocalDateTime timestamp) {
        this.status = status;
        this.message = message;
        this.timestamp = timestamp;
    }

    public ErrorResponse(int status, String message, LocalDateTime timestamp, Map&lt;String, String&gt; errors) {
        this(status, message, timestamp);
        this.errors = errors;
    }

    // Getters and setters
}
</code></pre>
<p><strong>6. Custom Error Attributes with ErrorController:</strong></p>
<p>For customizing Whitelabel Error Page:</p>
<pre><code class="language-java">@Component
public class CustomErrorAttributes extends DefaultErrorAttributes {

    @Override
    public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) {
        Map&lt;String, Object&gt; errorAttributes = super.getErrorAttributes(webRequest, options);

        errorAttributes.put(&quot;timestamp&quot;, LocalDateTime.now());
        errorAttributes.put(&quot;custom&quot;, &quot;Custom error information&quot;);

        // Remove unwanted attributes
        errorAttributes.remove(&quot;trace&quot;);

        return errorAttributes;
    }
}

@RestController
@RequestMapping(&quot;${server.error.path:${error.path:/error}}&quot;)
public class CustomErrorController implements ErrorController {

    private final ErrorAttributes errorAttributes;

    public CustomErrorController(ErrorAttributes errorAttributes) {
        this.errorAttributes = errorAttributes;
    }

    @RequestMapping
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; handleError(WebRequest webRequest) {
        Map&lt;String, Object&gt; errors = errorAttributes.getErrorAttributes(
            webRequest,
            ErrorAttributeOptions.defaults()
        );

        HttpStatus status = HttpStatus.valueOf((Integer) errors.get(&quot;status&quot;));

        return new ResponseEntity&lt;&gt;(errors, status);
    }
}
</code></pre>
<p><strong>7. Spring Boot Properties for Error Handling:</strong></p>
<p>Configure error handling behavior in application.properties:</p>
<pre><code class="language-properties"># Disable including stacktrace in error response
server.error.include-stacktrace=never

# Control exception details inclusion
server.error.include-exception=false
server.error.include-message=always
server.error.include-binding-errors=always

# Custom error path
server.error.path=/api/errors
</code></pre>
<p><strong>8. Exception Handling with @Valid and Validation:</strong></p>
<p>Handling validation exceptions with standard JSR-380 annotations:</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/users&quot;)
public class UserController {

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public User createUser(@Valid @RequestBody User user) {
        return userService.createUser(user);
    }
}

public class User {
    @Id
    private Long id;

    @NotBlank(message = &quot;Username is required&quot;)
    @Size(min = 4, max = 50, message = &quot;Username must be between 4 and 50 characters&quot;)
    private String username;

    @NotBlank(message = &quot;Email is required&quot;)
    @Email(message = &quot;Email must be valid&quot;)
    private String email;

    @NotNull(message = &quot;Birth date is required&quot;)
    @Past(message = &quot;Birth date must be in the past&quot;)
    private LocalDate birthDate;

    // getters and setters
}
</code></pre>
<p><strong>9. Service Layer Exceptions:</strong></p>
<p>Proper exception propagation through service layer:</p>
<pre><code class="language-java">@Service
@Transactional
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;

    public UserServiceImpl(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public User createUser(User user) {
        if (userRepository.existsByEmail(user.getEmail())) {
            throw new DuplicateResourceException(&quot;Email already in use: &quot; + user.getEmail());
        }

        try {
            return userRepository.save(user);
        } catch (DataIntegrityViolationException e) {
            throw new InvalidDataException(&quot;Failed to create user due to data integrity violation&quot;, e);
        }
    }
}
</code></pre>
<p><strong>10. Logging Exceptions:</strong></p>
<p>Best practice is to log exceptions while handling them:</p>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ErrorResponse handleGenericException(Exception ex) {
        logger.error(&quot;Unhandled exception occurred&quot;, ex);

        return new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            &quot;An unexpected error occurred. Please try again later.&quot;,
            LocalDateTime.now()
        );
    }

    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ErrorResponse handleResourceNotFoundException(ResourceNotFoundException ex) {
        logger.warn(&quot;Resource not found: {}&quot;, ex.getMessage());

        return new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            LocalDateTime.now()
        );
    }

    // Other exception handlers
}
</code></pre>
<p><strong>Best Practices for Exception Handling:</strong></p>
<ol>
    <li><strong>Be Specific</strong>: Use specific exception types for different error scenarios</li>
    <li><strong>Hide Implementation Details</strong>: Don&#39;t expose sensitive error details to clients</li>
    <li><strong>Consistent Format</strong>: Use a standard error response format across the API</li>
    <li><strong>Appropriate Status Codes</strong>: Use HTTP status codes correctly (e.g., 404 for not found, 400 for bad request)</li>
    <li><strong>Log Exceptions</strong>: Always log exceptions for troubleshooting, especially for 5xx errors</li>
    <li><strong>Validation</strong>: Use Bean Validation for input validation with clear messages</li>
    <li><strong>Security Awareness</strong>: Don&#39;t expose stack traces or sensitive data in error responses</li>
    <li><strong>Business Logic</strong>: Separate business logic exceptions from technical exceptions</li>
    <li><strong>Documentation</strong>: Document possible error responses in API documentation</li>
    <li><strong>Testing</strong>: Test your exception handling with unit and integration tests</li>
</ol>
<h3 id="46-how-do-you-implement-input-validation-in-spring-boot-rest-apis">46. How do you implement input validation in Spring Boot REST APIs?</h3>
<p><strong>Answer:</strong> Spring Boot provides several mechanisms for input validation in REST APIs, making it easy to ensure that incoming data meets your application&#39;s requirements before processing. Here&#39;s a comprehensive overview of input validation approaches in Spring Boot:</p>
<p><strong>1. Bean Validation (JSR-380) with Hibernate Validator:</strong></p>
<p>Spring Boot includes Hibernate Validator, an implementation of the Bean Validation API (JSR-380), which allows for declarative validation.</p>
<p>Add the dependency (usually included in spring-boot-starter-web):</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>2. Validating Request Bodies:</strong></p>
<p>Annotate your model classes with validation constraints:</p>
<pre><code class="language-java">public class UserDto {
    @NotNull(message = &quot;ID cannot be null&quot;)
    private Long id;

    @NotBlank(message = &quot;Name is required&quot;)
    @Size(min = 2, max = 100, message = &quot;Name must be between 2 and 100 characters&quot;)
    private String name;

    @NotBlank(message = &quot;Email is required&quot;)
    @Email(message = &quot;Email should be valid&quot;)
    private String email;

    @NotNull(message = &quot;Age is required&quot;)
    @Min(value = 18, message = &quot;Age should not be less than 18&quot;)
    @Max(value = 150, message = &quot;Age should not be greater than 150&quot;)
    private Integer age;

    @Past(message = &quot;Birth date must be in the past&quot;)
    private LocalDate birthDate;

    @Pattern(regexp = &quot;^\\+(?:[0-9] ?){6,14}[0-9]$&quot;, message = &quot;Phone number must be in international format&quot;)
    private String phoneNumber;

    // getters and setters
}
</code></pre>
<p>Enable validation in controller:</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/users&quot;)
public class UserController {

    @PostMapping
    public ResponseEntity&lt;UserDto&gt; createUser(@Valid @RequestBody UserDto userDto) {
        // The @Valid annotation triggers validation
        // If validation fails, MethodArgumentNotValidException is thrown
        UserDto savedUser = userService.createUser(userDto);
        return new ResponseEntity&lt;&gt;(savedUser, HttpStatus.CREATED);
    }

    @PutMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;UserDto&gt; updateUser(
            @PathVariable Long id,
            @Valid @RequestBody UserDto userDto) {
        return ResponseEntity.ok(userService.updateUser(id, userDto));
    }
}
</code></pre>
<p><strong>3. Validating Path Variables and Request Parameters:</strong></p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/users&quot;)
public class UserController {

    @GetMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;UserDto&gt; getUserById(
            @PathVariable @Min(1) Long id) {
        return ResponseEntity.ok(userService.getUserById(id));
    }

    @GetMapping
    public ResponseEntity&lt;Page&lt;UserDto&gt;&gt; getUsers(
            @RequestParam @Min(0) int page,
            @RequestParam @Min(1) @Max(100) int size) {
        return ResponseEntity.ok(userService.getUsers(page, size));
    }

    @GetMapping(&quot;/search&quot;)
    public ResponseEntity&lt;List&lt;UserDto&gt;&gt; searchUsers(
            @RequestParam(required = false) @Size(min = 2) String name,
            @RequestParam(required = false) @Min(18) Integer minAge,
            @RequestParam(required = false) @Max(150) Integer maxAge) {
        return ResponseEntity.ok(userService.searchUsers(name, minAge, maxAge));
    }
}
</code></pre>
<p><strong>4. Common Validation Annotations:</strong></p>
<p>Basic constraints:</p>
<ul>
    <li><code>@NotNull</code>: Element must not be null</li>
    <li><code>@NotEmpty</code>: Collection, map, array, or string must not be null or empty</li>
    <li><code>@NotBlank</code>: String must not be null and trim length &gt; 0</li>
    <li><code>@Size(min=, max=)</code>: Size must be between given bounds (strings, collections, arrays)</li>
    <li><code>@Min(value)</code>: Number must be greater than or equal to value</li>
    <li><code>@Max(value)</code>: Number must be less than or equal to value</li>
</ul>
<p>String constraints:</p>
<ul>
    <li><code>@Pattern(regexp=)</code>: String must match regular expression</li>
    <li><code>@Email</code>: String must be well-formed email</li>
    <li><code>@URL</code>: String must be well-formed URL</li>
</ul>
<p>Temporal constraints:</p>
<ul>
    <li><code>@Past</code>: Date must be in the past</li>
    <li><code>@PastOrPresent</code>: Date must be in the past or present</li>
    <li><code>@Future</code>: Date must be in the future</li>
    <li><code>@FutureOrPresent</code>: Date must be in the future or present</li>
</ul>
<p>Number constraints:</p>
<ul>
    <li><code>@Positive</code>: Number must be positive</li>
    <li><code>@PositiveOrZero</code>: Number must be positive or zero</li>
    <li><code>@Negative</code>: Number must be negative</li>
    <li><code>@NegativeOrZero</code>: Number must be negative or zero</li>
    <li><code>@Digits(integer=, fraction=)</code>: Number format with max digits</li>
</ul>
<p><strong>5. Custom Validation Annotations:</strong></p>
<p>Create your own custom validation annotations:</p>
<pre><code class="language-java">// Define annotation
@Documented
@Constraint(validatedBy = AdultValidator.class)
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Adult {
    String message() default &quot;User must be an adult&quot;;
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}

// Implement validator
public class AdultValidator implements ConstraintValidator&lt;Adult, LocalDate&gt; {

    @Override
    public void initialize(Adult constraintAnnotation) {}

    @Override
    public boolean isValid(LocalDate birthDate, ConstraintValidatorContext context) {
        if (birthDate == null) {
            return true; // Let @NotNull handle this
        }

        return Period.between(birthDate, LocalDate.now()).getYears() &gt;= 18;
    }
}

// Use in model
public class UserDto {
    @NotNull(message = &quot;Birth date is required&quot;)
    @Adult(message = &quot;User must be 18 years or older&quot;)
    private LocalDate birthDate;

    // other fields, getters and setters
}
</code></pre>
<p><strong>6. Class-Level Validation:</strong></p>
<p>Validate relationships between fields:</p>
<pre><code class="language-java">@PasswordMatches(message = &quot;Password and confirmation must match&quot;)
public class RegistrationDto {
    @NotBlank(message = &quot;Username is required&quot;)
    private String username;

    @NotBlank(message = &quot;Password is required&quot;)
    private String password;

    @NotBlank(message = &quot;Confirm password is required&quot;)
    private String confirmPassword;

    // getters and setters
}

// Custom validator
@Documented
@Constraint(validatedBy = PasswordMatchesValidator.class)
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface PasswordMatches {
    String message() default &quot;Passwords don&#39;t match&quot;;
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}

public class PasswordMatchesValidator implements ConstraintValidator&lt;PasswordMatches, Object&gt; {

    @Override
    public void initialize(PasswordMatches constraintAnnotation) {}

    @Override
    public boolean isValid(Object obj, ConstraintValidatorContext context) {
        RegistrationDto user = (RegistrationDto) obj;
        return user.getPassword().equals(user.getConfirmPassword());
    }
}
</code></pre>
<p><strong>7. Handling Validation Errors:</strong></p>
<p>Create a custom exception handler to format validation errors:</p>
<pre><code class="language-java">@RestControllerAdvice
public class ValidationExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ValidationErrorResponse handleValidationExceptions(MethodArgumentNotValidException ex) {
        ValidationErrorResponse errors = new ValidationErrorResponse();

        ex.getBindingResult().getAllErrors().forEach(error -&gt; {
            String fieldName = error instanceof FieldError ?
                ((FieldError) error).getField() : error.getObjectName();

            String errorMessage = error.getDefaultMessage();
            errors.addError(fieldName, errorMessage);
        });

        return errors;
    }

    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ValidationErrorResponse handleConstraintViolation(ConstraintViolationException ex) {
        ValidationErrorResponse errors = new ValidationErrorResponse();

        ex.getConstraintViolations().forEach(violation -&gt; {
            String fieldName = getPropertyName(violation.getPropertyPath());
            String errorMessage = violation.getMessage();
            errors.addError(fieldName, errorMessage);
        });

        return errors;
    }

    private String getPropertyName(Path path) {
        String pathStr = path.toString();
        int lastDotIndex = pathStr.lastIndexOf(&#39;.&#39;);
        return lastDotIndex &gt; 0 ? pathStr.substring(lastDotIndex + 1) : pathStr;
    }
}

public class ValidationErrorResponse {
    private List&lt;FieldError&gt; errors = new ArrayList&lt;&gt;();

    public void addError(String field, String message) {
        errors.add(new FieldError(field, message));
    }

    public List&lt;FieldError&gt; getErrors() {
        return errors;
    }

    public static class FieldError {
        private final String field;
        private final String message;

        public FieldError(String field, String message) {
            this.field = field;
            this.message = message;
        }

        // getters
    }
}
</code></pre>
<p><strong>8. Programmatic Validation:</strong></p>
<p>Validate objects programmatically:</p>
<pre><code class="language-java">@Service
public class ValidationService {

    private final Validator validator;

    public ValidationService(Validator validator) {
        this.validator = validator;
    }

    public &lt;T&gt; void validate(T object) {
        Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(object);

        if (!violations.isEmpty()) {
            throw new ConstraintViolationException(violations);
        }
    }

    public &lt;T&gt; List&lt;String&gt; getValidationErrors(T object) {
        return validator.validate(object).stream()
            .map(ConstraintViolation::getMessage)
            .collect(Collectors.toList());
    }
}
</code></pre>
<p><strong>9. Group Validation:</strong></p>
<p>Apply different validation rules based on context:</p>
<pre><code class="language-java">// Define validation groups
public interface OnCreate {}
public interface OnUpdate {}

// Use groups in annotations
public class ProductDto {
    @Null(groups = OnCreate.class, message = &quot;ID must be null for new products&quot;)
    @NotNull(groups = OnUpdate.class, message = &quot;ID is required for updates&quot;)
    private Long id;

    @NotBlank(message = &quot;Name is required&quot;)
    private String name;

    // other fields, getters and setters
}

// In controller
@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {

    @PostMapping
    public ResponseEntity&lt;ProductDto&gt; createProduct(
            @Validated(OnCreate.class) @RequestBody ProductDto productDto) {
        return new ResponseEntity&lt;&gt;(productService.createProduct(productDto), HttpStatus.CREATED);
    }

    @PutMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;ProductDto&gt; updateProduct(
            @PathVariable Long id,
            @Validated(OnUpdate.class) @RequestBody ProductDto productDto) {
        return ResponseEntity.ok(productService.updateProduct(id, productDto));
    }
}
</code></pre>
<p><strong>10. Service-Level Validation:</strong></p>
<p>Validating in service layer for complex business rules:</p>
<pre><code class="language-java">@Service
@Validated
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;

    public UserServiceImpl(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDto createUser(@Valid UserDto userDto) {
        // Additional business validation
        if (userRepository.existsByEmail(userDto.getEmail())) {
            throw new ResourceAlreadyExistsException(&quot;Email already in use&quot;);
        }

        // Processing after validation passes
        User user = mapToEntity(userDto);
        User savedUser = userRepository.save(user);
        return mapToDto(savedUser);
    }

    @Override
    public List&lt;UserDto&gt; findUsersByAgeRange(
            @Min(0) int minAge,
            @Max(150) int maxAge) {
        // Method parameters are validated
        if (minAge &gt; maxAge) {
            throw new IllegalArgumentException(&quot;Min age cannot be greater than max age&quot;);
        }

        return userRepository.findByAgeBetween(minAge, maxAge).stream()
                .map(this::mapToDto)
                .collect(Collectors.toList());
    }

    // mapping methods
}
</code></pre>
<p><strong>Best Practices for Validation:</strong></p>
<ol>
    <li><strong>Layer Appropriately</strong>: Use Bean Validation for basic data integrity, business rules in service layer</li>
    <li><strong>Clear Messages</strong>: Provide clear, user-friendly error messages</li>
    <li><strong>Internationalization</strong>: Support i18n for validation messages</li>
    <li><strong>Don&#39;t Trust the Frontend</strong>: Always validate on the backend regardless of frontend validation</li>
    <li><strong>Security Awareness</strong>: Validate inputs against injection attacks (SQL, XSS)</li>
    <li><strong>Performance</strong>: Be mindful of complex validations&#39; performance impact</li>
    <li><strong>Test</strong>: Write tests for validation logic including both positive and negative cases</li>
    <li><strong>Document</strong>: Document validation constraints in API documentation</li>
    <li><strong>Reuse</strong>: Create custom constraints for commonly used validations</li>
    <li><strong>Consistent Responses</strong>: Standardize validation error formats for better client handling</li>
</ol>
<p>Combining these techniques results in robust validation that helps maintain data integrity while providing good user experience through meaningful error messages.</p>
<h3 id="47-how-do-you-implement-pagination-and-sorting-in-spring-boot-rest-apis">47. How do you implement pagination and sorting in Spring Boot REST APIs?</h3>
<p><strong>Answer:</strong> Spring Boot provides built-in support for implementing pagination and sorting in REST APIs through Spring Data&#39;s powerful abstractions. This allows developers to efficiently handle large data sets by returning manageable chunks of data and controlling the order in which records are returned.</p>
<p><strong>1. Basic Pagination and Sorting with Spring Data:</strong></p>
<p>Spring Boot&#39;s pagination support centers around the <code>Pageable</code> interface and <code>Page</code> return type:</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {

    private final ProductRepository productRepository;

    public ProductController(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    @GetMapping
    public Page&lt;Product&gt; getProducts(
            @RequestParam(defaultValue = &quot;0&quot;) int page,
            @RequestParam(defaultValue = &quot;10&quot;) int size,
            @RequestParam(defaultValue = &quot;id&quot;) String sort) {

        return productRepository.findAll(
            PageRequest.of(page, size, Sort.by(sort))
        );
    }
}
</code></pre>
<p>Repository interface:</p>
<pre><code class="language-java">public interface ProductRepository extends PagingAndSortingRepository&lt;Product, Long&gt; {
    // Spring Data automatically implements pagination and sorting
    // for the findAll method
}
</code></pre>
<p><strong>2. Advanced Sorting with Multiple Properties and Direction:</strong></p>
<pre><code class="language-java">@GetMapping
public Page&lt;Product&gt; getProducts(
        @RequestParam(defaultValue = &quot;0&quot;) int page,
        @RequestParam(defaultValue = &quot;10&quot;) int size,
        @RequestParam(defaultValue = &quot;id&quot;) String[] sort,
        @RequestParam(defaultValue = &quot;asc&quot;) String direction) {

    Sort.Direction dir = direction.equalsIgnoreCase(&quot;desc&quot;) ?
            Sort.Direction.DESC : Sort.Direction.ASC;

    return productRepository.findAll(
        PageRequest.of(page, size, Sort.by(dir, sort))
    );
}
</code></pre>
<p><strong>3. Custom Request Parameters with Method Arguments:</strong></p>
<pre><code class="language-java">@GetMapping
public Page&lt;Product&gt; getProducts(Pageable pageable) {
    // Spring automatically converts query parameters to a Pageable object
    // page=0&amp;size=20&amp;sort=name,desc&amp;sort=price,asc
    return productRepository.findAll(pageable);
}
</code></pre>
<p><strong>4. Custom Pagination Configuration:</strong></p>
<pre><code class="language-java">@Configuration
public class WebConfig {

    @Bean
    public PageableHandlerMethodArgumentResolver pageableResolver() {
        PageableHandlerMethodArgumentResolver resolver = new PageableHandlerMethodArgumentResolver();
        resolver.setFallbackPageable(PageRequest.of(0, 20));
        resolver.setMaxPageSize(100);
        resolver.setOneIndexedParameters(true);  // Use 1-based page indexing
        resolver.setPageParameterName(&quot;page&quot;);
        resolver.setSizeParameterName(&quot;size&quot;);
        resolver.setSortParameter(&quot;order&quot;);
        return resolver;
    }

    @Bean
    public WebMvcConfigurer webMvcConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addArgumentResolvers(
                    List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {
                argumentResolvers.add(pageableResolver());
            }
        };
    }
}
</code></pre>
<p><strong>5. Pagination with Custom Query Methods:</strong></p>
<pre><code class="language-java">public interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {
    Page&lt;Product&gt; findByCategory(String category, Pageable pageable);

    Page&lt;Product&gt; findByPriceGreaterThan(BigDecimal price, Pageable pageable);

    @Query(&quot;SELECT p FROM Product p WHERE p.name LIKE %:keyword% OR p.description LIKE %:keyword%&quot;)
    Page&lt;Product&gt; search(@Param(&quot;keyword&quot;) String keyword, Pageable pageable);
}
</code></pre>
<p>Usage in controller:</p>
<pre><code class="language-java">@GetMapping(&quot;/search&quot;)
public Page&lt;Product&gt; searchProducts(
        @RequestParam String keyword,
        @PageableDefault(page = 0, size = 20) Pageable pageable) {
    return productRepository.search(keyword, pageable);
}
</code></pre>
<p><strong>6. Building Response with Pagination Metadata:</strong></p>
<p>For more control over the response format:</p>
<pre><code class="language-java">@GetMapping
public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getProducts(
        @RequestParam(defaultValue = &quot;0&quot;) int page,
        @RequestParam(defaultValue = &quot;10&quot;) int size,
        @RequestParam(defaultValue = &quot;id&quot;) String sort) {

    Pageable paging = PageRequest.of(page, size, Sort.by(sort));
    Page&lt;Product&gt; pageProducts = productRepository.findAll(paging);

    List&lt;Product&gt; products = pageProducts.getContent();

    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();
    response.put(&quot;products&quot;, products);
    response.put(&quot;currentPage&quot;, pageProducts.getNumber());
    response.put(&quot;totalItems&quot;, pageProducts.getTotalElements());
    response.put(&quot;totalPages&quot;, pageProducts.getTotalPages());
    response.put(&quot;isFirst&quot;, pageProducts.isFirst());
    response.put(&quot;isLast&quot;, pageProducts.isLast());
    response.put(&quot;hasNext&quot;, pageProducts.hasNext());
    response.put(&quot;hasPrevious&quot;, pageProducts.hasPrevious());

    return ResponseEntity.ok(response);
}
</code></pre>
<p><strong>7. Using Spring HATEOAS for Self-Describing Pagination:</strong></p>
<p>Add dependency:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Create HATEOAS links:</p>
<pre><code class="language-java">@GetMapping
public ResponseEntity&lt;PagedModel&lt;EntityModel&lt;Product&gt;&gt;&gt; getProducts(
        @PageableDefault(size = 10) Pageable pageable,
        PagedResourcesAssembler&lt;Product&gt; assembler) {

    Page&lt;Product&gt; page = productRepository.findAll(pageable);

    return ResponseEntity.ok(
        assembler.toModel(
            page,
            product -&gt; EntityModel.of(
                product,
                linkTo(methodOn(ProductController.class).getProduct(product.getId())).withSelfRel()
            )
        )
    );
}
</code></pre>
<p>Sample response with HATEOAS:</p>
<pre><code class="language-json">{
  &quot;_embedded&quot;: {
    &quot;products&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Product A&quot;,
        &quot;price&quot;: 29.99,
        &quot;_links&quot;: {
          &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/api/products/1&quot;
          }
        }
      },
      // More products...
    ]
  },
  &quot;_links&quot;: {
    &quot;first&quot;: {
      &quot;href&quot;: &quot;http://localhost:8080/api/products?page=0&amp;size=10&quot;
    },
    &quot;self&quot;: {
      &quot;href&quot;: &quot;http://localhost:8080/api/products?page=0&amp;size=10&quot;
    },
    &quot;next&quot;: {
      &quot;href&quot;: &quot;http://localhost:8080/api/products?page=1&amp;size=10&quot;
    },
    &quot;last&quot;: {
      &quot;href&quot;: &quot;http://localhost:8080/api/products?page=4&amp;size=10&quot;
    }
  },
  &quot;page&quot;: {
    &quot;size&quot;: 10,
    &quot;totalElements&quot;: 42,
    &quot;totalPages&quot;: 5,
    &quot;number&quot;: 0
  }
}
</code></pre>
<p><strong>8. Dynamic Sorting with Multiple Criteria:</strong></p>
<pre><code class="language-java">@GetMapping
public Page&lt;Product&gt; getProducts(
        @RequestParam(defaultValue = &quot;0&quot;) int page,
        @RequestParam(defaultValue = &quot;10&quot;) int size,
        @RequestParam(required = false) String[] sort) {

    Pageable pageable;

    if (sort == null || sort.length == 0) {
        // Default sort by id
        pageable = PageRequest.of(page, size, Sort.by(&quot;id&quot;));
    } else {
        List&lt;Sort.Order&gt; orders = new ArrayList&lt;&gt;();

        // Parse each sort parameter (e.g., &quot;name,desc&quot;, &quot;price,asc&quot;)
        for (String sortParam : sort) {
            String[] parts = sortParam.split(&quot;,&quot;);
            String property = parts[0];

            Sort.Direction direction = (parts.length &gt; 1 &amp;&amp; parts[1].equalsIgnoreCase(&quot;desc&quot;)) ?
                    Sort.Direction.DESC : Sort.Direction.ASC;

            orders.add(new Sort.Order(direction, property));
        }

        pageable = PageRequest.of(page, size, Sort.by(orders));
    }

    return productRepository.findAll(pageable);
}
</code></pre>
<p><strong>9. Custom PagedResponse Class for Standardization:</strong></p>
<pre><code class="language-java">public class PagedResponse&lt;T&gt; {
    private List&lt;T&gt; content;
    private int page;
    private int size;
    private long totalElements;
    private int totalPages;
    private boolean last;
    private boolean first;
    private boolean hasNext;
    private boolean hasPrevious;

    // Constructor, getters and setters

    public static &lt;T&gt; PagedResponse&lt;T&gt; from(Page&lt;T&gt; page) {
        PagedResponse&lt;T&gt; response = new PagedResponse&lt;&gt;();
        response.setContent(page.getContent());
        response.setPage(page.getNumber());
        response.setSize(page.getSize());
        response.setTotalElements(page.getTotalElements());
        response.setTotalPages(page.getTotalPages());
        response.setLast(page.isLast());
        response.setFirst(page.isFirst());
        response.setHasNext(page.hasNext());
        response.setHasPrevious(page.hasPrevious());
        return response;
    }
}
</code></pre>
<p>Usage:</p>
<pre><code class="language-java">@GetMapping
public PagedResponse&lt;ProductDto&gt; getProducts(
        @RequestParam(defaultValue = &quot;0&quot;) int page,
        @RequestParam(defaultValue = &quot;10&quot;) int size,
        @RequestParam(defaultValue = &quot;id&quot;) String sort) {

    Page&lt;Product&gt; productPage = productRepository.findAll(
        PageRequest.of(page, size, Sort.by(sort))
    );

    List&lt;ProductDto&gt; productDtos = productPage.getContent()
        .stream()
        .map(this::mapToDto)
        .collect(Collectors.toList());

    PagedResponse&lt;ProductDto&gt; response = PagedResponse.from(new PageImpl&lt;&gt;(
        productDtos,
        productPage.getPageable(),
        productPage.getTotalElements()
    ));

    return response;
}
</code></pre>
<p><strong>10. Handling Pagination with Filtering/Searching:</strong></p>
<pre><code class="language-java">@GetMapping
public Page&lt;Product&gt; getProducts(
        @RequestParam(required = false) String category,
        @RequestParam(required = false) BigDecimal minPrice,
        @RequestParam(required = false) BigDecimal maxPrice,
        @RequestParam(required = false) String keyword,
        @RequestParam(defaultValue = &quot;0&quot;) int page,
        @RequestParam(defaultValue = &quot;10&quot;) int size,
        @RequestParam(defaultValue = &quot;id&quot;) String sort) {

    Pageable pageable = PageRequest.of(page, size, Sort.by(sort));

    if (keyword != null) {
        return productRepository.search(keyword, pageable);
    } else if (category != null) {
        return productRepository.findByCategory(category, pageable);
    } else if (minPrice != null &amp;&amp; maxPrice != null) {
        return productRepository.findByPriceBetween(minPrice, maxPrice, pageable);
    } else if (minPrice != null) {
        return productRepository.findByPriceGreaterThanEqual(minPrice, pageable);
    } else if (maxPrice != null) {
        return productRepository.findByPriceLessThanEqual(maxPrice, pageable);
    } else {
        return productRepository.findAll(pageable);
    }
}
</code></pre>
<p><strong>11. Using Specifications for Dynamic Filtering with Pagination:</strong></p>
<pre><code class="language-java">@GetMapping
public Page&lt;Product&gt; getProductsWithFilters(
        @RequestParam(required = false) String name,
        @RequestParam(required = false) String category,
        @RequestParam(required = false) BigDecimal minPrice,
        @RequestParam(required = false) BigDecimal maxPrice,
        Pageable pageable) {

    Specification&lt;Product&gt; spec = Specification.where(null);

    if (name != null) {
        spec = spec.and((root, query, cb) -&gt;
            cb.like(cb.lower(root.get(&quot;name&quot;)), &quot;%&quot; + name.toLowerCase() + &quot;%&quot;));
    }

    if (category != null) {
        spec = spec.and((root, query, cb) -&gt;
            cb.equal(root.get(&quot;category&quot;), category));
    }

    if (minPrice != null) {
        spec = spec.and((root, query, cb) -&gt;
            cb.greaterThanOrEqualTo(root.get(&quot;price&quot;), minPrice));
    }

    if (maxPrice != null) {
        spec = spec.and((root, query, cb) -&gt;
            cb.lessThanOrEqualTo(root.get(&quot;price&quot;), maxPrice));
    }

    return productRepository.findAll(spec, pageable);
}
</code></pre>
<p><strong>12. Pagination in Native Queries:</strong></p>
<pre><code class="language-java">public interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {
    @Query(value = &quot;SELECT * FROM products p WHERE p.price &gt; :price&quot;,
           countQuery = &quot;SELECT COUNT(*) FROM products p WHERE p.price &gt; :price&quot;,
           nativeQuery = true)
    Page&lt;Product&gt; findExpensiveProducts(@Param(&quot;price&quot;) BigDecimal price, Pageable pageable);
}
</code></pre>
<p><strong>Best Practices for Pagination and Sorting:</strong></p>
<ol>
    <li><strong>Consistent Defaults</strong>: Always provide sensible defaults for page size and sort fields</li>
    <li><strong>Page Size Limits</strong>: Enforce maximum page sizes to prevent performance issues</li>
    <li><strong>Performance</strong>: Use indexed columns for sorting to avoid poor database performance</li>
    <li><strong>Caching</strong>: Consider caching paginated results for frequently accessed pages</li>
    <li><strong>Total Count</strong>: For very large datasets, consider options to avoid expensive count queries</li>
    <li><strong>Backend Control</strong>: Don&#39;t rely solely on frontend pagination for security or performance</li>
    <li><strong>HATEOAS Links</strong>: Include navigation links to improve API discoverability</li>
    <li><strong>Clear Documentation</strong>: Document pagination and sorting parameters</li>
    <li><strong>Consistent Response Format</strong>: Use a consistent structure for paginated responses</li>
    <li><strong>Testing</strong>: Test edge cases like empty result sets, first/last page, etc.</li>
</ol>
<p>Effective pagination and sorting implementation helps improve API usability and performance by allowing clients to retrieve and display data in manageable chunks and in the most useful order for their specific use case.</p>
<h3 id="48-what-is-spring-hateoas-and-how-do-you-use-it-in-a-spring-boot-application">48. What is Spring HATEOAS and how do you use it in a Spring Boot application?</h3>
<p><strong>Answer:</strong> Spring HATEOAS (Hypermedia as the Engine of Application State) is a Spring project that helps create REST representations that follow the HATEOAS principle, one of the key constraints of the REST architectural style. It allows you to build hypermedia-driven RESTful web services where clients interact with the application through hypermedia links provided in the response.</p>
<p><strong>1. Core Concepts of Spring HATEOAS:</strong></p>
<ul>
    <li><strong>Hypermedia Controls</strong>: Links embedded in responses that guide clients to available actions</li>
    <li><strong>Link Relation Types</strong>: Standard relation types like &quot;self&quot;, &quot;next&quot;, &quot;prev&quot; that describe the link&#39;s purpose</li>
    <li><strong>Resource Models</strong>: Representations containing both data and related links</li>
    <li><strong>Discoverability</strong>: Allowing clients to navigate the API without hard-coding URLs</li>
</ul>
<p><strong>2. Adding Spring HATEOAS to a Spring Boot Application:</strong></p>
<p>Add the dependency:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>3. Basic Usage with EntityModel:</strong></p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    @GetMapping(&quot;/{id}&quot;)
    public EntityModel&lt;Product&gt; getProduct(@PathVariable Long id) {
        Product product = productService.findById(id);

        return EntityModel.of(product,
                linkTo(methodOn(ProductController.class).getProduct(id)).withSelfRel(),
                linkTo(methodOn(ProductController.class).getAllProducts()).withRel(&quot;products&quot;));
    }

    @GetMapping
    public CollectionModel&lt;EntityModel&lt;Product&gt;&gt; getAllProducts() {
        List&lt;Product&gt; products = productService.findAll();

        List&lt;EntityModel&lt;Product&gt;&gt; productModels = products.stream()
                .map(product -&gt; EntityModel.of(product,
                        linkTo(methodOn(ProductController.class).getProduct(product.getId())).withSelfRel(),
                        linkTo(methodOn(ProductController.class).getAllProducts()).withRel(&quot;products&quot;)))
                .collect(Collectors.toList());

        return CollectionModel.of(productModels,
                linkTo(methodOn(ProductController.class).getAllProducts()).withSelfRel());
    }
}
</code></pre>
<p><strong>4. Response Structure:</strong></p>
<p>The response from the <code>getProduct</code> method would look like:</p>
<pre><code class="language-json">{
  &quot;id&quot;: 1,
  &quot;name&quot;: &quot;Laptop&quot;,
  &quot;price&quot;: 999.99,
  &quot;description&quot;: &quot;High-performance laptop&quot;,
  &quot;_links&quot;: {
    &quot;self&quot;: {
      &quot;href&quot;: &quot;http://localhost:8080/api/products/1&quot;
    },
    &quot;products&quot;: {
      &quot;href&quot;: &quot;http://localhost:8080/api/products&quot;
    }
  }
}
</code></pre>
<p>And the <code>getAllProducts</code> response:</p>
<pre><code class="language-json">{
  &quot;_embedded&quot;: {
    &quot;productList&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Laptop&quot;,
        &quot;price&quot;: 999.99,
        &quot;_links&quot;: {
          &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/api/products/1&quot;
          },
          &quot;products&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/api/products&quot;
          }
        }
      },
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Phone&quot;,
        &quot;price&quot;: 499.99,
        &quot;_links&quot;: {
          &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/api/products/2&quot;
          },
          &quot;products&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/api/products&quot;
          }
        }
      }
    ]
  },
  &quot;_links&quot;: {
    &quot;self&quot;: {
      &quot;href&quot;: &quot;http://localhost:8080/api/products&quot;
    }
  }
}
</code></pre>
<p><strong>5. Creating a RepresentationModel for DTOs:</strong></p>
<pre><code class="language-java">public class ProductModel extends RepresentationModel&lt;ProductModel&gt; {
    private Long id;
    private String name;
    private BigDecimal price;
    private String description;

    // Constructors, getters, setters

    public static ProductModel fromEntity(Product product) {
        ProductModel model = new ProductModel();
        model.setId(product.getId());
        model.setName(product.getName());
        model.setPrice(product.getPrice());
        model.setDescription(product.getDescription());
        return model;
    }
}
</code></pre>
<p>Using the model:</p>
<pre><code class="language-java">@GetMapping(&quot;/{id}&quot;)
public ProductModel getProduct(@PathVariable Long id) {
    Product product = productService.findById(id);

    ProductModel productModel = ProductModel.fromEntity(product);
    productModel.add(linkTo(methodOn(ProductController.class).getProduct(id)).withSelfRel());
    productModel.add(linkTo(methodOn(ProductController.class).getAllProducts()).withRel(&quot;products&quot;));

    // Add conditional links
    if (product.getInventory() &gt; 0) {
        productModel.add(linkTo(methodOn(OrderController.class).createOrder(null))
                .withRel(&quot;order&quot;));
    }

    return productModel;
}
</code></pre>
<p><strong>6. Working with Collections of Resources:</strong></p>
<pre><code class="language-java">@GetMapping
public CollectionModel&lt;ProductModel&gt; getAllProducts() {
    List&lt;Product&gt; products = productService.findAll();

    List&lt;ProductModel&gt; productModels = products.stream()
            .map(product -&gt; {
                ProductModel model = ProductModel.fromEntity(product);
                model.add(linkTo(methodOn(ProductController.class)
                        .getProduct(product.getId())).withSelfRel());
                return model;
            })
            .collect(Collectors.toList());

    return CollectionModel.of(
            productModels,
            linkTo(methodOn(ProductController.class).getAllProducts()).withSelfRel(),
            linkTo(methodOn(CategoryController.class).getAllCategories()).withRel(&quot;categories&quot;)
    );
}
</code></pre>
<p><strong>7. Using Assemblers for Clean Code:</strong></p>
<p>Create a model assembler:</p>
<pre><code class="language-java">@Component
public class ProductModelAssembler implements RepresentationModelAssembler&lt;Product, ProductModel&gt; {

    @Override
    public ProductModel toModel(Product product) {
        ProductModel productModel = ProductModel.fromEntity(product);

        productModel.add(linkTo(methodOn(ProductController.class)
                .getProduct(product.getId())).withSelfRel());

        productModel.add(linkTo(methodOn(ProductController.class)
                .getAllProducts()).withRel(&quot;products&quot;));

        // Add links to related resources
        productModel.add(linkTo(methodOn(CategoryController.class)
                .getCategory(product.getCategory().getId())).withRel(&quot;category&quot;));

        // Add conditional links
        if (product.getInventory() &gt; 0) {
            productModel.add(linkTo(methodOn(OrderController.class)
                    .createOrder(null)).withRel(&quot;order&quot;));
        }

        return productModel;
    }

    @Override
    public CollectionModel&lt;ProductModel&gt; toCollectionModel(
            Iterable&lt;? extends Product&gt; products) {

        CollectionModel&lt;ProductModel&gt; productModels =
                RepresentationModelAssembler.super.toCollectionModel(products);

        productModels.add(linkTo(methodOn(ProductController.class)
                .getAllProducts()).withSelfRel());

        return productModels;
    }
}
</code></pre>
<p>Using the assembler in controllers:</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {

    private final ProductService productService;
    private final ProductModelAssembler assembler;

    public ProductController(ProductService productService, ProductModelAssembler assembler) {
        this.productService = productService;
        this.assembler = assembler;
    }

    @GetMapping(&quot;/{id}&quot;)
    public ProductModel getProduct(@PathVariable Long id) {
        return assembler.toModel(productService.findById(id));
    }

    @GetMapping
    public CollectionModel&lt;ProductModel&gt; getAllProducts() {
        return assembler.toCollectionModel(productService.findAll());
    }
}
</code></pre>
<p><strong>8. Pagination with HATEOAS:</strong></p>
<pre><code class="language-java">@GetMapping
public PagedModel&lt;EntityModel&lt;Product&gt;&gt; getProducts(
        @RequestParam(defaultValue = &quot;0&quot;) int page,
        @RequestParam(defaultValue = &quot;10&quot;) int size,
        PagedResourcesAssembler&lt;Product&gt; pagedAssembler) {

    Page&lt;Product&gt; productPage = productService.findAll(PageRequest.of(page, size));

    return pagedAssembler.toModel(
            productPage,
            product -&gt; EntityModel.of(
                    product,
                    linkTo(methodOn(ProductController.class).getProduct(product.getId())).withSelfRel()
            )
    );
}
</code></pre>
<p>Response with pagination:</p>
<pre><code class="language-json">{
  &quot;_embedded&quot;: {
    &quot;productList&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Product A&quot;,
        &quot;_links&quot;: {
          &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/api/products/1&quot;
          }
        }
      },
      // More products...
    ]
  },
  &quot;_links&quot;: {
    &quot;first&quot;: {
      &quot;href&quot;: &quot;http://localhost:8080/api/products?page=0&amp;size=10&quot;
    },
    &quot;self&quot;: {
      &quot;href&quot;: &quot;http://localhost:8080/api/products?page=0&amp;size=10&quot;
    },
    &quot;next&quot;: {
      &quot;href&quot;: &quot;http://localhost:8080/api/products?page=1&amp;size=10&quot;
    },
    &quot;last&quot;: {
      &quot;href&quot;: &quot;http://localhost:8080/api/products?page=5&amp;size=10&quot;
    }
  },
  &quot;page&quot;: {
    &quot;size&quot;: 10,
    &quot;totalElements&quot;: 56,
    &quot;totalPages&quot;: 6,
    &quot;number&quot;: 0
  }
}
</code></pre>
<p><strong>9. Affordances - Adding Potential Actions:</strong></p>
<pre><code class="language-java">@GetMapping(&quot;/{id}&quot;)
public EntityModel&lt;Product&gt; getProduct(@PathVariable Long id) {
    Product product = productService.findById(id);

    return EntityModel.of(product)
            .add(linkTo(methodOn(ProductController.class).getProduct(id))
                    .withSelfRel()
                    .andAffordance(afford(methodOn(ProductController.class).updateProduct(id, null)))
                    .andAffordance(afford(methodOn(ProductController.class).deleteProduct(id))))
            .add(linkTo(methodOn(ProductController.class).getAllProducts())
                    .withRel(&quot;products&quot;));
}
</code></pre>
<p>This adds information about what actions can be performed with this resource.</p>
<p><strong>10. Custom Link Relations:</strong></p>
<pre><code class="language-java">// Define custom link relations
public class CustomLinkRelations {
    public static final String PRODUCTS = &quot;products&quot;;
    public static final String CATEGORIES = &quot;categories&quot;;
    public static final String NEXT_PAGE = &quot;nextPage&quot;;
    public static final String PREVIOUS_PAGE = &quot;previousPage&quot;;
    public static final String ORDER = &quot;order&quot;;
}

// Use in controllers
@GetMapping(&quot;/{id}&quot;)
public EntityModel&lt;Product&gt; getProduct(@PathVariable Long id) {
    Product product = productService.findById(id);

    EntityModel&lt;Product&gt; model = EntityModel.of(product);
    model.add(linkTo(methodOn(ProductController.class).getProduct(id)).withSelfRel());
    model.add(linkTo(methodOn(ProductController.class).getAllProducts())
            .withRel(CustomLinkRelations.PRODUCTS));

    return model;
}
</code></pre>
<p><strong>11. Handling Link Creation for Related Resources:</strong></p>
<pre><code class="language-java">@GetMapping(&quot;/{id}&quot;)
public EntityModel&lt;Product&gt; getProduct(@PathVariable Long id) {
    Product product = productService.findById(id);

    EntityModel&lt;Product&gt; model = EntityModel.of(product);

    // Self link
    model.add(linkTo(methodOn(ProductController.class).getProduct(id)).withSelfRel());

    // Collection link
    model.add(linkTo(methodOn(ProductController.class).getAllProducts()).withRel(&quot;products&quot;));

    // Category link
    model.add(linkTo(methodOn(CategoryController.class)
            .getCategory(product.getCategory().getId())).withRel(&quot;category&quot;));

    // Reviews link
    model.add(linkTo(methodOn(ReviewController.class)
            .getReviewsForProduct(id)).withRel(&quot;reviews&quot;));

    // Supplier link
    model.add(linkTo(methodOn(SupplierController.class)
            .getSupplier(product.getSupplier().getId())).withRel(&quot;supplier&quot;));

    return model;
}
</code></pre>
<p><strong>12. VndErrors for Error Responses:</strong></p>
<pre><code class="language-java">@ExceptionHandler(ProductNotFoundException.class)
@ResponseStatus(HttpStatus.NOT_FOUND)
public ProblemDetail handleProductNotFound(ProductNotFoundException ex) {
    ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(
            HttpStatus.NOT_FOUND, ex.getMessage());

    problemDetail.setTitle(&quot;Product Not Found&quot;);
    problemDetail.setType(URI.create(&quot;https://api.example.com/errors/not-found&quot;));
    problemDetail.setProperty(&quot;timestamp&quot;, LocalDateTime.now());

    return problemDetail;
}
</code></pre>
<p><strong>Best Practices for Using Spring HATEOAS:</strong></p>
<ol>
    <li><strong>Consistent Link Relations</strong>: Use standard link relations (self, next, prev) where appropriate</li>
    <li><strong>Documentation</strong>: Document your link relations and their meanings</li>
    <li><strong>Resource Models</strong>: Create dedicated resource models separate from entity models</li>
    <li><strong>Link URI Templates</strong>: Use URI templates for query parameters when applicable</li>
    <li><strong>Assemblers</strong>: Use model assemblers for clean, reusable code</li>
    <li><strong>Content Negotiation</strong>: Support different media types (e.g., HAL, JSON, XML)</li>
    <li><strong>Don&#39;t Overdo It</strong>: Only include links that are truly useful to API consumers</li>
    <li><strong>Testing</strong>: Write tests specifically for verifying link generation</li>
    <li><strong>Versioning</strong>: Consider how API versioning affects hypermedia links</li>
    <li><strong>Pagination Links</strong>: Always include navigation links for paginated resources</li>
</ol>
<p>Spring HATEOAS helps create truly RESTful APIs that allow clients to interact with the application through hypermedia controls, making your APIs more discoverable, self-documenting, and flexible to change.</p>
<h3 id="49-how-do-you-implement-cross-origin-resource-sharing-cors-in-spring-boot">49. How do you implement Cross-Origin Resource Sharing (CORS) in Spring Boot?</h3>
<p><strong>Answer:</strong> Cross-Origin Resource Sharing (CORS) is a security feature implemented by browsers that restricts web pages from making requests to a domain different from the one that served the original page. Spring Boot provides several ways to configure CORS support, allowing controlled access to your REST APIs from different origins.</p>
<p><strong>1. Controller-Level CORS Configuration:</strong></p>
<p>You can enable CORS for specific controller methods using the <code>@CrossOrigin</code> annotation:</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {

    // Enable CORS for this specific method
    @CrossOrigin(origins = &quot;http://example.com&quot;)
    @GetMapping(&quot;/{id}&quot;)
    public Product getProduct(@PathVariable Long id) {
        return productService.findById(id);
    }

    // Enable CORS with more options
    @CrossOrigin(
        origins = {&quot;http://example.com&quot;, &quot;https://example.com&quot;},
        methods = {RequestMethod.GET, RequestMethod.POST},
        allowedHeaders = {&quot;Authorization&quot;, &quot;Content-Type&quot;},
        exposedHeaders = {&quot;X-Custom-Header&quot;},
        allowCredentials = &quot;true&quot;,
        maxAge = 3600
    )
    @PostMapping
    public Product createProduct(@RequestBody Product product) {
        return productService.save(product);
    }
}
</code></pre>
<p><strong>2. Controller-Class Level CORS Configuration:</strong></p>
<p>Apply CORS to all methods in a controller:</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/users&quot;)
@CrossOrigin(origins = &quot;http://example.com&quot;)
public class UserController {

    @GetMapping(&quot;/{id}&quot;)
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }

    @PostMapping
    public User createUser(@RequestBody User user) {
        return userService.save(user);
    }

    // This method overrides the class-level configuration
    @CrossOrigin(origins = &quot;*&quot;)
    @PutMapping(&quot;/{id}&quot;)
    public User updateUser(@PathVariable Long id, @RequestBody User user) {
        return userService.update(id, user);
    }
}
</code></pre>
<p><strong>3. Global CORS Configuration (Java Configuration):</strong></p>
<p>Configure CORS globally using WebMvcConfigurer:</p>
<pre><code class="language-java">@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping(&quot;/api/**&quot;)
                .allowedOrigins(&quot;http://example.com&quot;, &quot;https://example.org&quot;)
                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)
                .allowedHeaders(&quot;Authorization&quot;, &quot;Content-Type&quot;, &quot;X-Requested-With&quot;)
                .exposedHeaders(&quot;Custom-Header&quot;)
                .allowCredentials(true)
                .maxAge(3600);

        // Different configuration for specific endpoints
        registry.addMapping(&quot;/public/**&quot;)
                .allowedOrigins(&quot;*&quot;)
                .allowedMethods(&quot;GET&quot;)
                .maxAge(1800);
    }
}
</code></pre>
<p><strong>4. Global CORS Configuration with Spring Security:</strong></p>
<p>When using Spring Security, you need to configure CORS at the security level as well:</p>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))
            .authorizeHttpRequests(auth -&gt; {
                auth.requestMatchers(&quot;/api/public/**&quot;).permitAll();
                auth.requestMatchers(&quot;/api/**&quot;).authenticated();
            });

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList(&quot;http://example.com&quot;));
        configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;));
        configuration.setAllowedHeaders(Arrays.asList(&quot;Authorization&quot;, &quot;Content-Type&quot;, &quot;X-Requested-With&quot;));
        configuration.setExposedHeaders(Arrays.asList(&quot;Custom-Header&quot;));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration(&quot;/**&quot;, configuration);
        return source;
    }
}
</code></pre>
<p><strong>5. CORS Configuration in application.properties/yml:</strong></p>
<p>Spring Boot 2.4+ allows configuring CORS in application properties:</p>
<pre><code class="language-properties"># Global CORS settings
spring.web.cors.allowed-origins=http://example.com,https://example.org
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE
spring.web.cors.allowed-headers=Authorization,Content-Type
spring.web.cors.exposed-headers=Custom-Header
spring.web.cors.allow-credentials=true
spring.web.cors.max-age=3600
</code></pre>
<p>Or in YAML format:</p>
<pre><code class="language-yaml">spring:
  web:
    cors:
      allowed-origins: &quot;http://example.com,https://example.org&quot;
      allowed-methods: &quot;GET,POST,PUT,DELETE&quot;
      allowed-headers: &quot;Authorization,Content-Type&quot;
      exposed-headers: &quot;Custom-Header&quot;
      allow-credentials: true
      max-age: 3600
</code></pre>
<p><strong>6. Combining Multiple CORS Configuration Approaches:</strong></p>
<p>When you have multiple CORS configuration methods, they are applied in the following order:</p>
<ol>
    <li>Controller method-level <code>@CrossOrigin</code> annotation (most specific)</li>
    <li>Controller class-level <code>@CrossOrigin</code> annotation</li>
    <li>Global CORS configuration via <code>WebMvcConfigurer</code></li>
    <li>Global CORS configuration in application.properties/yml</li>
</ol>
<p><strong>7. Dynamic CORS Configuration:</strong></p>
<p>For cases where CORS settings need to be dynamically determined:</p>
<pre><code class="language-java">@Component
public class DynamicCorsConfigurationSource implements CorsConfigurationSource {

    private final AllowedOriginsProvider originsProvider;

    public DynamicCorsConfigurationSource(AllowedOriginsProvider originsProvider) {
        this.originsProvider = originsProvider;
    }

    @Override
    public CorsConfiguration getCorsConfiguration(HttpServletRequest request) {
        CorsConfiguration config = new CorsConfiguration();

        // Dynamically get allowed origins (maybe from database or external service)
        List&lt;String&gt; allowedOrigins = originsProvider.getAllowedOrigins();
        config.setAllowedOrigins(allowedOrigins);

        config.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;));
        config.setAllowedHeaders(Arrays.asList(&quot;*&quot;));
        config.setAllowCredentials(true);

        return config;
    }
}

@Service
public class AllowedOriginsProvider {
    // Could retrieve from database, config service, etc.
    public List&lt;String&gt; getAllowedOrigins() {
        return Arrays.asList(&quot;http://example.com&quot;, &quot;https://app.example.com&quot;);
    }
}
</code></pre>
<p><strong>8. CORS for WebFlux Applications:</strong></p>
<p>For reactive applications using Spring WebFlux:</p>
<pre><code class="language-java">@Configuration
public class CorsConfig {

    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration corsConfig = new CorsConfiguration();
        corsConfig.setAllowedOrigins(Arrays.asList(&quot;http://example.com&quot;));
        corsConfig.setMaxAge(3600L);
        corsConfig.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;));
        corsConfig.setAllowedHeaders(Arrays.asList(&quot;Authorization&quot;, &quot;Content-Type&quot;));

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration(&quot;/**&quot;, corsConfig);

        return new CorsWebFilter(source);
    }
}
</code></pre>
<p><strong>9. CORS Filter for Legacy Applications:</strong></p>
<p>For applications that need to support older Spring versions or have special requirements:</p>
<pre><code class="language-java">@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class CustomCorsFilter implements Filter {

    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        HttpServletResponse response = (HttpServletResponse) res;
        HttpServletRequest request = (HttpServletRequest) req;

        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://example.com&quot;);
        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, PUT, DELETE, OPTIONS&quot;);
        response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);
        response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Authorization, Content-Type, Accept&quot;);
        response.setHeader(&quot;Access-Control-Expose-Headers&quot;, &quot;Custom-Header&quot;);
        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);

        if (&quot;OPTIONS&quot;.equalsIgnoreCase(request.getMethod())) {
            response.setStatus(HttpServletResponse.SC_OK);
        } else {
            chain.doFilter(req, res);
        }
    }
}
</code></pre>
<p><strong>10. Testing CORS Configuration:</strong></p>
<p>Simple test for CORS configuration:</p>
<pre><code class="language-java">@SpringBootTest
@AutoConfigureMockMvc
public class CorsTests {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testCorsHeaders() throws Exception {
        mockMvc.perform(options(&quot;/api/products&quot;)
                .header(&quot;Origin&quot;, &quot;http://example.com&quot;)
                .header(&quot;Access-Control-Request-Method&quot;, &quot;GET&quot;))
                .andExpect(status().isOk())
                .andExpect(header().string(&quot;Access-Control-Allow-Origin&quot;, &quot;http://example.com&quot;))
                .andExpect(header().string(&quot;Access-Control-Allow-Methods&quot;, containsString(&quot;GET&quot;)))
                .andExpect(header().exists(&quot;Access-Control-Max-Age&quot;));
    }
}
</code></pre>
<p><strong>11. Advanced Use Cases:</strong></p>
<p><strong>Variable Origins Based on Environment:</strong></p>
<pre><code class="language-java">@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Value(&quot;${cors.allowed-origins}&quot;)
    private String[] allowedOrigins;

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping(&quot;/api/**&quot;)
                .allowedOrigins(allowedOrigins)
                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)
                .allowCredentials(true);
    }
}
</code></pre>
<p><strong>Environment-specific configuration:</strong></p>
<pre><code class="language-properties"># Development
cors.allowed-origins=http://localhost:3000,http://localhost:4200

# Production
cors.allowed-origins=https://app.example.com,https://admin.example.com
</code></pre>
<p><strong>Best Practices for CORS Configuration:</strong></p>
<ol>
    <li><strong>Be Specific</strong>: Limit allowed origins to trusted domains rather than using wildcard <code>*</code></li>
    <li><strong>Restrict Methods</strong>: Only allow necessary HTTP methods</li>
    <li><strong>Consider Credentials</strong>: Set <code>allowCredentials</code> to <code>true</code> only if you need to support cookies or authentication</li>
    <li><strong>Headers Control</strong>: Be explicit about which headers are allowed and exposed</li>
    <li><strong>Security-First</strong>: Combine CORS with proper authentication and authorization</li>
    <li><strong>Testing</strong>: Test CORS configurations in different browsers</li>
    <li><strong>Logging</strong>: Log CORS errors during development to troubleshoot issues</li>
    <li><strong>Environment Separation</strong>: Use different CORS settings for development and production</li>
    <li><strong>API Gateway</strong>: Consider handling CORS at the API gateway level for microservices</li>
    <li><strong>Documentation</strong>: Document CORS settings for frontend developers</li>
</ol>
<p>By properly implementing CORS in your Spring Boot application, you can securely allow web applications from different domains to interact with your API while maintaining control over which origins have access and what actions they can perform.</p>
<h3 id="50-explain-content-negotiation-in-spring-boot-rest-apis">50. Explain content negotiation in Spring Boot REST APIs.</h3>
<p><strong>Answer:</strong> Content negotiation is a mechanism in HTTP that allows a client and server to agree on the most appropriate format or representation of a resource. In Spring Boot REST APIs, content negotiation enables returning the same resource in different formats (like</p>
<h2 id="rest-apis-and-security">REST APIs and Security</h2>
<h3 id="50-explain-content-negotiation-in-spring-boot-rest-apis-1">50. Explain content negotiation in Spring Boot REST APIs.</h3>
<p>Content negotiation allows a REST API to serve different representations of the same resource (JSON, XML, etc.) based on client preferences. Spring Boot supports this through:</p>
<ul>
    <li><strong>HTTP headers</strong>: Using Accept header (<code>Accept: application/json</code>)</li>
    <li><strong>URL parameters</strong>: Using format parameter (<code>?format=json</code>)</li>
    <li><strong>Path extensions</strong>: Using file extensions (<code>/products.json</code>)</li>
</ul>
<p>Implementation methods:</p>
<pre><code class="language-java">// Configuration
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
        configurer
            .favorParameter(true)
            .parameterName(&quot;format&quot;)
            .defaultContentType(MediaType.APPLICATION_JSON)
            .mediaType(&quot;json&quot;, MediaType.APPLICATION_JSON)
            .mediaType(&quot;xml&quot;, MediaType.APPLICATION_XML);
    }
}

// Controller supporting multiple formats
@GetMapping(value = &quot;/products&quot;,
    produces = { MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE })
public List&lt;Product&gt; getProducts() {
    return productService.findAll();
}
</code></pre>
<h3 id="51-what-is-the-difference-between-controller-and-restcontroller">51. What is the difference between @Controller and @RestController?</h3>
<ul>
    <li><strong>@Controller</strong>: Traditional Spring MVC controller that returns view names</li>
    <li><strong>@RestController</strong>: Combines @Controller and @ResponseBody - automatically serializes return values to HTTP response body</li>
    <li><strong>@Controller</strong> needs @ResponseBody on each method to return data directly</li>
    <li><strong>@RestController</strong> is specialized for RESTful web services</li>
    <li><strong>@Controller</strong> typically works with ModelAndView</li>
    <li><strong>@RestController</strong> typically returns domain objects which are serialized to JSON/XML</li>
</ul>
<h3 id="52-how-do-you-secure-a-rest-api-in-spring-boot">52. How do you secure a REST API in Spring Boot?</h3>
<p>Spring Boot provides multiple ways to secure REST APIs:</p>
<ol>
    <li><strong>Spring Security dependency</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Basic Authentication</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -&gt; {
                auth.requestMatchers(&quot;/public/**&quot;).permitAll();
                auth.requestMatchers(&quot;/api/**&quot;).authenticated();
            })
            .httpBasic(Customizer.withDefaults());
        return http.build();
    }
}
</code></pre>
<ol start="3">
    <li><strong>JWT Authentication</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthFilter;

    // Configure JWT filter in filter chain
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
            .authorizeHttpRequests(...)
        return http.build();
    }
}
</code></pre>
<ol start="4">
    <li><strong>OAuth2</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class OAuth2SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(Customizer.withDefaults()))
            .authorizeHttpRequests(auth -&gt; {
                auth.requestMatchers(&quot;/api/**&quot;).authenticated();
            });
        return http.build();
    }
}
</code></pre>
<h3 id="53-what-is-spring-boot-actuator-and-how-can-it-be-used-to-monitor-an-application">53. What is Spring Boot Actuator and how can it be used to monitor an application?</h3>
<p>Spring Boot Actuator provides production-ready features for monitoring and managing applications through HTTP endpoints or JMX.</p>
<p>Key features:</p>
<ul>
    <li>Health checks (<code>/actuator/health</code>)</li>
    <li>Metrics (<code>/actuator/metrics</code>)</li>
    <li>Environment info (<code>/actuator/env</code>)</li>
    <li>Logging control (<code>/actuator/loggers</code>)</li>
    <li>Thread dumps (<code>/actuator/threaddump</code>)</li>
    <li>HTTP trace (<code>/actuator/httptrace</code>)</li>
</ul>
<p>Implementation:</p>
<pre><code class="language-xml">&lt;!-- Dependency --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># Configuration
management.endpoints.web.exposure.include=health,info,metrics,loggers
management.endpoint.health.show-details=always
management.info.env.enabled=true
</code></pre>
<pre><code class="language-java">// Custom health indicator
@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    @Override
    public Health health() {
        if (isDatabaseHealthy()) {
            return Health.up()
                .withDetail(&quot;database&quot;, &quot;Available&quot;)
                .build();
        } else {
            return Health.down()
                .withDetail(&quot;database&quot;, &quot;Unavailable&quot;)
                .build();
        }
    }
}
</code></pre>
<h3 id="54-what-is-spring-security-how-do-you-integrate-it-with-spring-boot">54. What is Spring Security? How do you integrate it with Spring Boot?</h3>
<p>Spring Security is a powerful authentication and access-control framework integrated with Spring Boot applications.</p>
<p>Integration:</p>
<ol>
    <li>Add dependency:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li>Configure security:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -&gt; csrf.disable())
            .authorizeHttpRequests(auth -&gt; {
                auth.requestMatchers(&quot;/public/**&quot;).permitAll();
                auth.requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;);
                auth.anyRequest().authenticated();
            })
            .formLogin(form -&gt; form
                .loginPage(&quot;/login&quot;)
                .permitAll()
            );
        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.builder()
            .username(&quot;user&quot;)
            .password(passwordEncoder().encode(&quot;password&quot;))
            .roles(&quot;USER&quot;)
            .build();

        UserDetails admin = User.builder()
            .username(&quot;admin&quot;)
            .password(passwordEncoder().encode(&quot;admin&quot;))
            .roles(&quot;USER&quot;, &quot;ADMIN&quot;)
            .build();

        return new InMemoryUserDetailsManager(user, admin);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
</code></pre>
<h3 id="55-what-are-the-different-authentication-methods-in-spring-security">55. What are the different authentication methods in Spring Security?</h3>
<ol>
    <li><p><strong>Form-based Authentication</strong>: Username/password submitted through a form</p>
        <pre><code class="language-java">http.formLogin(form -&gt; form.loginPage(&quot;/login&quot;).permitAll());
</code></pre>
    </li>
    <li><p><strong>HTTP Basic Authentication</strong>: Credentials in HTTP header</p>
        <pre><code class="language-java">http.httpBasic(Customizer.withDefaults());
</code></pre>
    </li>
    <li><p><strong>JWT Authentication</strong>: Token-based using JSON Web Tokens</p>
        <pre><code class="language-java">http.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
</code></pre>
    </li>
    <li><p><strong>OAuth2/OpenID Connect</strong>: Standards-based token authentication</p>
        <pre><code class="language-java">http.oauth2Login(oauth2 -&gt; oauth2.loginPage(&quot;/oauth_login&quot;));
</code></pre>
    </li>
    <li><p><strong>Remember-Me Authentication</strong>: Cookie-based for persistent sessions</p>
        <pre><code class="language-java">http.rememberMe(remember -&gt; remember.key(&quot;uniqueKey&quot;).tokenValiditySeconds(86400));
</code></pre>
    </li>
    <li><p><strong>LDAP Authentication</strong>: Directory service authentication</p>
        <pre><code class="language-java">http.ldapAuthentication(ldap -&gt; ldap.userDnPatterns(&quot;uid={0},ou=people&quot;));
</code></pre>
    </li>
    <li><p><strong>Custom Authentication</strong>: Implement AuthenticationProvider</p>
        <pre><code class="language-java">@Component
public class CustomAuthProvider implements AuthenticationProvider {
    @Override
    public Authentication authenticate(Authentication authentication) {
        // Custom authentication logic
    }
}
</code></pre>
    </li>
</ol>
<h3 id="56-how-do-you-implement-jwt-authentication-in-spring-boot">56. How do you implement JWT authentication in Spring Boot?</h3>
<p>JWT authentication implementation steps:</p>
<ol>
    <li><strong>Add dependencies</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;
    &lt;version&gt;0.11.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;
    &lt;version&gt;0.11.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;
    &lt;version&gt;0.11.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Create JWT utility class</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class JwtUtils {
    @Value(&quot;${jwt.secret}&quot;)
    private String secret;

    @Value(&quot;${jwt.expiration}&quot;)
    private long expirationMs;

    public String generateToken(UserDetails userDetails) {
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();

        return Jwts.builder()
            .setClaims(claims)
            .setSubject(userDetails.getUsername())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expirationMs))
            .signWith(Keys.hmacShaKeyFor(secret.getBytes()), SignatureAlgorithm.HS512)
            .compact();
    }

    public boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token);
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    private &lt;T&gt; T extractClaim(String token, Function&lt;Claims, T&gt; claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(Keys.hmacShaKeyFor(secret.getBytes()))
            .build()
            .parseClaimsJws(token)
            .getBody();
    }

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Create JWT filter</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtUtils jwtUtils;
    private final UserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtUtils jwtUtils, UserDetailsService userDetailsService) {
        this.jwtUtils = jwtUtils;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        final String authHeader = request.getHeader(&quot;Authorization&quot;);

        if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {
            filterChain.doFilter(request, response);
            return;
        }

        final String jwt = authHeader.substring(7);
        final String username = jwtUtils.extractUsername(jwt);

        if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);

            if (jwtUtils.validateToken(jwt, userDetails)) {
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                    userDetails, null, userDetails.getAuthorities());

                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        filterChain.doFilter(request, response);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Configure security</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthFilter) {
        this.jwtAuthFilter = jwtAuthFilter;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeHttpRequests()
                .requestMatchers(&quot;/auth/**&quot;).permitAll()
                .anyRequest().authenticated()
            .and()
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
</code></pre>
<ol start="5">
    <li><strong>Authentication controller</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/auth&quot;)
public class AuthController {
    private final AuthenticationManager authenticationManager;
    private final UserDetailsService userDetailsService;
    private final JwtUtils jwtUtils;

    // Constructor injection

    @PostMapping(&quot;/login&quot;)
    public ResponseEntity&lt;JwtResponse&gt; login(@RequestBody LoginRequest request) {
        Authentication authentication = authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())
        );

        SecurityContextHolder.getContext().setAuthentication(authentication);
        UserDetails userDetails = userDetailsService.loadUserByUsername(request.getUsername());

        String jwt = jwtUtils.generateToken(userDetails);

        return ResponseEntity.ok(new JwtResponse(jwt));
    }
}
</code></pre>
<h3 id="57-how-do-you-handle-versioning-in-restful-apis">57. How do you handle versioning in RESTful APIs?</h3>
<p>RESTful API versioning strategies:</p>
<ol>
    <li><strong>URI Versioning</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/v1&quot;)
public class ProductControllerV1 {
    @GetMapping(&quot;/products/{id}&quot;)
    public ProductV1 getProductV1(@PathVariable Long id) {
        // Return v1 representation
    }
}

@RestController
@RequestMapping(&quot;/api/v2&quot;)
public class ProductControllerV2 {
    @GetMapping(&quot;/products/{id}&quot;)
    public ProductV2 getProductV2(@PathVariable Long id) {
        // Return v2 representation
    }
}
</code></pre>
<ol start="2">
    <li><strong>Request Parameter Versioning</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @GetMapping(value = &quot;/{id}&quot;, params = &quot;version=1&quot;)
    public ProductV1 getProductV1(@PathVariable Long id) {
        // Return v1 representation
    }

    @GetMapping(value = &quot;/{id}&quot;, params = &quot;version=2&quot;)
    public ProductV2 getProductV2(@PathVariable Long id) {
        // Return v2 representation
    }
}
</code></pre>
<ol start="3">
    <li><strong>Header Versioning</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @GetMapping(value = &quot;/{id}&quot;, headers = &quot;X-API-VERSION=1&quot;)
    public ProductV1 getProductV1(@PathVariable Long id) {
        // Return v1 representation
    }

    @GetMapping(value = &quot;/{id}&quot;, headers = &quot;X-API-VERSION=2&quot;)
    public ProductV2 getProductV2(@PathVariable Long id) {
        // Return v2 representation
    }
}
</code></pre>
<ol start="4">
    <li><strong>Media Type Versioning (Content Negotiation)</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @GetMapping(value = &quot;/{id}&quot;,
               produces = &quot;application/vnd.company.app-v1+json&quot;)
    public ProductV1 getProductV1(@PathVariable Long id) {
        // Return v1 representation
    }

    @GetMapping(value = &quot;/{id}&quot;,
               produces = &quot;application/vnd.company.app-v2+json&quot;)
    public ProductV2 getProductV2(@PathVariable Long id) {
        // Return v2 representation
    }
}
</code></pre>
<h3 id="58-what-is-spring-boot-devtools-and-how-does-it-help-in-development">58. What is Spring Boot DevTools and how does it help in development?</h3>
<p>Spring Boot DevTools is a set of tools that enhances developer productivity:</p>
<ol>
    <li><strong>Automatic restart</strong>: Restarts application when classpath changes</li>
    <li><strong>LiveReload</strong>: Automatically refreshes browser when resources change</li>
    <li><strong>Property defaults</strong>: Development-friendly property defaults</li>
    <li><strong>Remote debug support</strong>: Enable debugging on remote applications</li>
</ol>
<p>Implementation:</p>
<pre><code class="language-xml">&lt;!-- Add dependency --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># Configuration
spring.devtools.restart.enabled=true
spring.devtools.restart.exclude=static/**,public/**
spring.devtools.livereload.enabled=true
spring.devtools.restart.poll-interval=2s
spring.devtools.restart.quiet-period=1s
</code></pre>
<p>Key benefits:</p>
<ul>
    <li>Faster development cycle</li>
    <li>Better productivity</li>
    <li>No manual restarts</li>
    <li>Browser auto-refresh</li>
    <li>Enhanced development experience</li>
</ul>
<h3 id="59-how-do-you-test-spring-boot-applications">59. How do you test Spring Boot applications?</h3>
<p>Spring Boot provides comprehensive testing support:</p>
<ol>
    <li><strong>Unit Testing</strong>: Using JUnit and Mockito</li>
</ol>
<pre><code class="language-java">@ExtendWith(MockitoExtension.class)
public class UserServiceTest {
    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    public void whenGetUserById_thenReturnUser() {
        User user = new User(1L, &quot;John&quot;);
        when(userRepository.findById(1L)).thenReturn(Optional.of(user));

        User found = userService.getUserById(1L);
        assertEquals(&quot;John&quot;, found.getName());
    }
}
</code></pre>
<ol start="2">
    <li><strong>Integration Testing</strong>: Using @SpringBootTest</li>
</ol>
<pre><code class="language-java">@SpringBootTest
public class UserControllerIntegrationTest {
    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    public void whenGetUserById_thenReturnUser() {
        ResponseEntity&lt;User&gt; response = restTemplate.getForEntity(&quot;/api/users/1&quot;, User.class);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(&quot;John&quot;, response.getBody().getName());
    }
}
</code></pre>
<ol start="3">
    <li><strong>Web Layer Testing</strong>: Using @WebMvcTest</li>
</ol>
<pre><code class="language-java">@WebMvcTest(UserController.class)
public class UserControllerTest {
    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;

    @Test
    public void whenGetUser_thenReturnJson() throws Exception {
        User user = new User(1L, &quot;John&quot;);
        when(userService.getUserById(1L)).thenReturn(user);

        mockMvc.perform(get(&quot;/api/users/1&quot;))
            .andExpect(status().isOk())
            .andExpect(jsonPath(&quot;$.name&quot;).value(&quot;John&quot;));
    }
}
</code></pre>
<ol start="4">
    <li><strong>Data Layer Testing</strong>: Using @DataJpaTest</li>
</ol>
<pre><code class="language-java">@DataJpaTest
public class UserRepositoryTest {
    @Autowired
    private UserRepository userRepository;

    @Test
    public void whenFindByName_thenReturnUser() {
        User user = new User(null, &quot;John&quot;);
        userRepository.save(user);

        User found = userRepository.findByName(&quot;John&quot;).get();
        assertEquals(&quot;John&quot;, found.getName());
    }
}
</code></pre>
<ol start="5">
    <li><strong>Test Slices</strong>:</li>
</ol>
<ul>
    <li>@WebMvcTest - web layer only</li>
    <li>@DataJpaTest - repository layer only</li>
    <li>@JsonTest - JSON serialization/deserialization</li>
    <li>@RestClientTest - REST client testing</li>
</ul>
<h3 id="60-how-do-you-document-restful-services-in-spring-boot">60. How do you document RESTful services in Spring Boot?</h3>
<p>Spring Boot integrates well with API documentation tools:</p>
<ol>
    <li><strong>SpringDoc OpenAPI (Swagger)</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;
    &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class OpenApiConfig {
    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
            .info(new Info()
                .title(&quot;Product API&quot;)
                .version(&quot;1.0&quot;)
                .description(&quot;Documentation for Product REST API&quot;));
    }
}
</code></pre>
<p>Annotation-based documentation:</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
@Tag(name = &quot;Product Controller&quot;, description = &quot;Product management endpoints&quot;)
public class ProductController {

    @Operation(summary = &quot;Get a product by ID&quot;,
              description = &quot;Returns a single product by ID&quot;)
    @ApiResponses(value = {
        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Product found&quot;),
        @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Product not found&quot;)
    })
    @GetMapping(&quot;/{id}&quot;)
    public Product getProduct(@Parameter(description = &quot;Product ID&quot;) @PathVariable Long id) {
        return productService.getProduct(id);
    }

    // Other endpoints
}
</code></pre>
<p>Access Swagger UI at: <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p>
<ol start="2">
    <li><strong>Spring REST Docs</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt;
    &lt;artifactId&gt;spring-restdocs-mockmvc&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@WebMvcTest(ProductController.class)
@AutoConfigureRestDocs(outputDir = &quot;target/generated-snippets&quot;)
public class ProductControllerTest {
    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private ProductService productService;

    @Test
    public void getProductShouldReturnProduct() throws Exception {
        when(productService.getProduct(1L)).thenReturn(new Product(1L, &quot;Laptop&quot;));

        mockMvc.perform(get(&quot;/api/products/1&quot;))
            .andExpect(status().isOk())
            .andDo(document(&quot;get-product&quot;,
                pathParameters(
                    parameterWithName(&quot;id&quot;).description(&quot;Product ID&quot;)
                ),
                responseFields(
                    fieldWithPath(&quot;id&quot;).description(&quot;Product ID&quot;),
                    fieldWithPath(&quot;name&quot;).description(&quot;Product name&quot;)
                )
            ));
    }
}
</code></pre>
<h2 id="testing-and-advanced-topics">Testing and Advanced Topics</h2>
<h3 id="61-how-do-you-implement-caching-in-spring-boot">61. How do you implement caching in Spring Boot?</h3>
<p>Spring Boot provides easy integration with caching frameworks:</p>
<ol>
    <li><strong>Add dependency</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Enable caching</strong>:</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
@EnableCaching
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Use caching annotations</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class ProductService {
    @Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;)
    public Product getProduct(Long id) {
        // Method will be executed only if result not in cache
        return productRepository.findById(id).orElse(null);
    }

    @CacheEvict(value = &quot;products&quot;, key = &quot;#product.id&quot;)
    public void updateProduct(Product product) {
        productRepository.save(product);
    }

    @CachePut(value = &quot;products&quot;, key = &quot;#product.id&quot;)
    public Product saveProduct(Product product) {
        return productRepository.save(product);
    }

    @CacheEvict(value = &quot;products&quot;, allEntries = true)
    public void clearCache() {
        // Clear entire cache
    }
}
</code></pre>
<ol start="4">
    <li><strong>Configure cache provider</strong> (e.g., Caffeine):</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;
    &lt;artifactId&gt;caffeine&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager(&quot;products&quot;);
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .expireAfterWrite(60, TimeUnit.MINUTES)
            .maximumSize(100));
        return cacheManager;
    }
}
</code></pre>
<h3 id="62-how-do-you-implement-websockets-in-spring-boot">62. How do you implement WebSockets in Spring Boot?</h3>
<p>WebSockets provide full-duplex communication channels over a single TCP connection:</p>
<ol>
    <li><strong>Add dependency</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Configure WebSocket</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker(&quot;/topic&quot;);  // Destination prefix for messages to clients
        registry.setApplicationDestinationPrefixes(&quot;/app&quot;);  // Prefix for client-to-server messages
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint(&quot;/ws&quot;)
                .setAllowedOrigins(&quot;*&quot;)
                .withSockJS();  // Fallback options
    }
}
</code></pre>
<ol start="3">
    <li><strong>Create controllers for handling messages</strong>:</li>
</ol>
<pre><code class="language-java">@Controller
public class ChatController {
    @MessageMapping(&quot;/chat.sendMessage&quot;)  // Client sends to /app/chat.sendMessage
    @SendTo(&quot;/topic/public&quot;)            // Server broadcasts to /topic/public
    public ChatMessage sendMessage(@Payload ChatMessage chatMessage) {
        return chatMessage;
    }

    @MessageMapping(&quot;/chat.addUser&quot;)
    @SendTo(&quot;/topic/public&quot;)
    public ChatMessage addUser(@Payload ChatMessage chatMessage,
                            SimpMessageHeaderAccessor headerAccessor) {
        // Add username to WebSocket session
        headerAccessor.getSessionAttributes().put(&quot;username&quot;, chatMessage.getSender());
        return chatMessage;
    }
}
</code></pre>
<ol start="4">
    <li><strong>Configure event listeners</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class WebSocketEventListener {
    @Autowired
    private SimpMessageSendingOperations messagingTemplate;

    @EventListener
    public void handleWebSocketConnectListener(SessionConnectedEvent event) {
        logger.info(&quot;Received a new web socket connection&quot;);
    }

    @EventListener
    public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {
        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());
        String username = (String) headerAccessor.getSessionAttributes().get(&quot;username&quot;);

        if (username != null) {
            logger.info(&quot;User Disconnected : &quot; + username);

            ChatMessage chatMessage = new ChatMessage();
            chatMessage.setType(ChatMessage.MessageType.LEAVE);
            chatMessage.setSender(username);

            messagingTemplate.convertAndSend(&quot;/topic/public&quot;, chatMessage);
        }
    }
}
</code></pre>
<ol start="5">
    <li><strong>JavaScript client example</strong>:</li>
</ol>
<pre><code class="language-javascript">const socket = new SockJS(&#39;/ws&#39;);
const stompClient = Stomp.over(socket);

stompClient.connect({}, function(frame) {
    console.log(&#39;Connected: &#39; + frame);

    stompClient.subscribe(&#39;/topic/public&#39;, function(message) {
        // Handle incoming message
    });

    // Send message
    stompClient.send(&quot;/app/chat.sendMessage&quot;,
        {},
        JSON.stringify({sender: username, content: message, type: &#39;CHAT&#39;})
    );
});
</code></pre>
<h3 id="63-how-do-you-implement-asynchronous-processing-in-spring-boot">63. How do you implement asynchronous processing in Spring Boot?</h3>
<p>Spring Boot provides several ways to implement asynchronous processing:</p>
<ol>
    <li><strong>@Async annotation</strong>:</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
@EnableAsync
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

@Service
public class EmailService {
    @Async
    public CompletableFuture&lt;Boolean&gt; sendEmail(String to, String subject, String content) {
        // Long-running operation
        return CompletableFuture.completedFuture(true);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Configure thread pool</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class AsyncConfig implements AsyncConfigurer {
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix(&quot;MyAsync-&quot;);
        executor.initialize();
        return executor;
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new SimpleAsyncUncaughtExceptionHandler();
    }
}
</code></pre>
<ol start="3">
    <li><strong>Using CompletableFuture</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api&quot;)
public class AsyncController {
    private final AsyncService asyncService;

    @GetMapping(&quot;/process&quot;)
    public CompletableFuture&lt;String&gt; processAsync() {
        return CompletableFuture.supplyAsync(() -&gt; {
            // Async processing
            return &quot;Process completed&quot;;
        });
    }

    @GetMapping(&quot;/combined&quot;)
    public CompletableFuture&lt;String&gt; combined() {
        CompletableFuture&lt;String&gt; task1 = asyncService.task1();
        CompletableFuture&lt;String&gt; task2 = asyncService.task2();

        return CompletableFuture.allOf(task1, task2)
            .thenApply(v -&gt; task1.join() + &quot; &amp; &quot; + task2.join());
    }
}
</code></pre>
<ol start="4">
    <li><strong>Exception handling</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class CustomAsyncExceptionHandler implements AsyncUncaughtExceptionHandler {
    @Override
    public void handleUncaughtException(Throwable ex, Method method, Object... params) {
        System.out.println(&quot;Exception: &quot; + ex.getMessage());
        System.out.println(&quot;Method name: &quot; + method.getName());
    }
}
</code></pre>
<h3 id="64-how-do-you-implement-scheduling-in-spring-boot">64. How do you implement scheduling in Spring Boot?</h3>
<p>Spring Boot makes it easy to schedule tasks:</p>
<ol>
    <li><strong>Enable scheduling</strong>:</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
@EnableScheduling
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Define scheduled tasks</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ScheduledTasks {
    // Run every 5 seconds
    @Scheduled(fixedRate = 5000)
    public void reportCurrentTime() {
        System.out.println(&quot;Current time: &quot; + new Date());
    }

    // Run 5 seconds after previous execution completes
    @Scheduled(fixedDelay = 5000)
    public void processQueues() {
        System.out.println(&quot;Processing queues&quot;);
    }

    // Run with initial delay, then fixed rate
    @Scheduled(initialDelay = 10000, fixedRate = 5000)
    public void delayedStart() {
        System.out.println(&quot;Delayed start task&quot;);
    }

    // Run with cron expression (2:15 AM every day)
    @Scheduled(cron = &quot;0 15 2 * * ?&quot;)
    public void scheduledBackup() {
        System.out.println(&quot;Running backup&quot;);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Configure scheduler</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class SchedulingConfig implements SchedulingConfigurer {
    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
        scheduler.setPoolSize(10);
        scheduler.setThreadNamePrefix(&quot;scheduled-task-&quot;);
        scheduler.initialize();
        taskRegistrar.setTaskScheduler(scheduler);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Dynamic scheduling</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class DynamicScheduler {
    private final TaskScheduler taskScheduler;
    private ScheduledFuture&lt;?&gt; scheduledTask;

    public DynamicScheduler(TaskScheduler taskScheduler) {
        this.taskScheduler = taskScheduler;
    }

    public void startSchedule(int interval) {
        cancelSchedule(); // Cancel any existing task

        scheduledTask = taskScheduler.scheduleAtFixedRate(
            () -&gt; System.out.println(&quot;Dynamic task executed&quot;),
            interval * 1000
        );
    }

    public void cancelSchedule() {
        if (scheduledTask != null) {
            scheduledTask.cancel(true);
        }
    }
}
</code></pre>
<h3 id="65-what-is-spring-boot-admin-how-do-you-set-it-up">65. What is Spring Boot Admin? How do you set it up?</h3>
<p>Spring Boot Admin is a web application for managing and monitoring Spring Boot applications:</p>
<ol>
    <li><strong>Server setup</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;!-- Admin server dependencies --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;
    &lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableAdminServer
public class AdminServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(AdminServerApplication.class, args);
    }
}
</code></pre>
<pre><code class="language-properties"># Admin server properties
server.port=8080
spring.application.name=admin-server
</code></pre>
<ol start="2">
    <li><strong>Client setup</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;!-- Admin client dependency --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;
    &lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># Admin client properties
spring.application.name=my-application
spring.boot.admin.client.url=http://localhost:8080
spring.boot.admin.client.instance.name=${spring.application.name}
spring.boot.admin.client.instance.prefer-ip=true

# Enable all actuator endpoints
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always
</code></pre>
<ol start="3">
    <li><strong>Securing Admin Server</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -&gt;
                auth.anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults())
            .csrf().disable();
        return http.build();
    }
}
</code></pre>
<pre><code class="language-properties"># Credentials
spring.security.user.name=admin
spring.security.user.password=admin

# Client credentials for secured server
spring.boot.admin.client.username=admin
spring.boot.admin.client.password=admin
</code></pre>
<h3 id="66-how-do-you-deploy-a-spring-boot-application">66. How do you deploy a Spring Boot application?</h3>
<p>Several approaches to deploy Spring Boot applications:</p>
<ol>
    <li><strong>JAR Deployment</strong>:</li>
</ol>
<pre><code class="language-bash"># Build JAR
./mvnw clean package

# Run JAR
java -jar target/myapp-0.0.1-SNAPSHOT.jar
</code></pre>
<ol start="2">
    <li><strong>WAR Deployment</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;packaging&gt;war&lt;/packaging&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
public class Application extends SpringBootServletInitializer {
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(Application.class);
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Docker Deployment</strong>:</li>
</ol>
<pre><code class="language-dockerfile">FROM openjdk:17-jdk-slim
VOLUME /tmp
COPY target/*.jar app.jar
ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
</code></pre>
<pre><code class="language-bash"># Build image
docker build -t myapp .

# Run container
docker run -p 8080:8080 myapp
</code></pre>
<ol start="4">
    <li><strong>Cloud Deployment</strong> (e.g., AWS Elastic Beanstalk):</li>
</ol>
<pre><code># Create application.properties for the environment
spring.datasource.url=${DB_URL}
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}
</code></pre>
<ol start="5">
    <li><strong>Using Profiles for Different Environments</strong>:</li>
</ol>
<pre><code class="language-properties"># application-dev.properties
server.port=8080
logging.level.root=DEBUG

# application-prod.properties
server.port=80
logging.level.root=WARN
</code></pre>
<pre><code class="language-bash"># Run with specific profile
java -jar app.jar --spring.profiles.active=prod
</code></pre>
<ol start="6">
    <li><strong>Systemd Service</strong> (Linux):</li>
</ol>
<pre><code>[Unit]
Description=My Spring Boot Application
After=syslog.target

[Service]
User=myapp
WorkingDirectory=/opt/myapp
ExecStart=/usr/bin/java -jar app.jar
SuccessExitStatus=143

[Install]
WantedBy=multi-user.target
</code></pre>
<h3 id="67-what-is-spring-boots-support-for-reactive-programming">67. What is Spring Boot&#39;s support for reactive programming?</h3>
<p>Spring Boot supports reactive programming primarily through Spring WebFlux:</p>
<ol>
    <li><strong>Add dependencies</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Create reactive REST controller</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    private final ProductRepository productRepository;

    public ProductController(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    @GetMapping
    public Flux&lt;Product&gt; getAllProducts() {
        return productRepository.findAll();
    }

    @GetMapping(&quot;/{id}&quot;)
    public Mono&lt;Product&gt; getProductById(@PathVariable String id) {
        return productRepository.findById(id)
                .switchIfEmpty(Mono.error(new ResourceNotFoundException()));
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;Product&gt; createProduct(@RequestBody Product product) {
        return productRepository.save(product);
    }

    @DeleteMapping(&quot;/{id}&quot;)
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public Mono&lt;Void&gt; deleteProduct(@PathVariable String id) {
        return productRepository.deleteById(id);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Reactive repository</strong> (using MongoDB):</li>
</ol>
<pre><code class="language-java">public interface ProductRepository extends ReactiveMongoRepository&lt;Product, String&gt; {
    Flux&lt;Product&gt; findByCategory(String category);
    Mono&lt;Product&gt; findByName(String name);
}
</code></pre>
<ol start="4">
    <li><strong>Reactive WebClient</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class ProductService {
    private final WebClient webClient;

    public ProductService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder
                .baseUrl(&quot;https://external-api.com&quot;)
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

    public Flux&lt;Product&gt; getExternalProducts() {
        return webClient.get()
                .uri(&quot;/products&quot;)
                .retrieve()
                .bodyToFlux(Product.class);
    }

    public Mono&lt;Product&gt; getExternalProductById(String id) {
        return webClient.get()
                .uri(&quot;/products/{id}&quot;, id)
                .retrieve()
                .bodyToMono(Product.class);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Reactive operations</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class InventoryService {
    private final ProductRepository productRepository;
    private final PriceService priceService;

    public Mono&lt;Product&gt; getProductWithCurrentPrice(String id) {
        return productRepository.findById(id)
                .flatMap(product -&gt;
                    priceService.getCurrentPrice(product.getSku())
                        .map(price -&gt; {
                            product.setPrice(price);
                            return product;
                        })
                );
    }

    public Flux&lt;Product&gt; getAvailableProducts() {
        return productRepository.findAll()
                .filter(product -&gt; product.getStock() &gt; 0)
                .sort((p1, p2) -&gt; p1.getName().compareTo(p2.getName()))
                .take(10);
    }
}
</code></pre>
<h3 id="68-how-do-you-implement-internationalization-i18n-in-spring-boot">68. How do you implement internationalization (i18n) in Spring Boot?</h3>
<p>Spring Boot supports internationalization out-of-the-box:</p>
<ol>
    <li><strong>Create message files</strong>:</li>
</ol>
<pre><code class="language-properties"># messages.properties (default)
welcome.message=Welcome
app.lang.title=Language

# messages_fr.properties
welcome.message=Bienvenue
app.lang.title=Langue

# messages_es.properties
welcome.message=Bienvenido
app.lang.title=Idioma
</code></pre>
<ol start="2">
    <li><strong>Configure message source</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class MessageConfig {
    @Bean
    public MessageSource messageSource() {
        ReloadableResourceBundleMessageSource messageSource =
            new ReloadableResourceBundleMessageSource();
        messageSource.setBasename(&quot;classpath:messages&quot;);
        messageSource.setDefaultEncoding(&quot;UTF-8&quot;);
        return messageSource;
    }

    @Bean
    public LocaleResolver localeResolver() {
        SessionLocaleResolver resolver = new SessionLocaleResolver();
        resolver.setDefaultLocale(Locale.US);
        return resolver;
    }

    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor() {
        LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();
        interceptor.setParamName(&quot;lang&quot;);
        return interceptor;
    }

    @Bean
    public WebMvcConfigurer webMvcConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addInterceptors(InterceptorRegistry registry) {
                registry.addInterceptor(localeChangeInterceptor());
            }
        };
    }
}
</code></pre>
<ol start="3">
    <li><strong>Use in controllers</strong>:</li>
</ol>
<pre><code class="language-java">@Controller
public class HomeController {
    private final MessageSource messageSource;

    public HomeController(MessageSource messageSource) {
        this.messageSource = messageSource;
    }

    @GetMapping(&quot;/&quot;)
    public String home(Model model, Locale locale) {
        model.addAttribute(&quot;welcomeMessage&quot;,
            messageSource.getMessage(&quot;welcome.message&quot;, null, locale));
        return &quot;home&quot;;
    }

    // For REST APIs
    @GetMapping(&quot;/api/welcome&quot;)
    @ResponseBody
    public Map&lt;String, String&gt; getWelcomeMessage(Locale locale) {
        String message = messageSource.getMessage(&quot;welcome.message&quot;, null, locale);
        return Collections.singletonMap(&quot;message&quot;, message);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Use in templates</strong> (Thymeleaf):</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;title th:text=&quot;#{app.title}&quot;&gt;App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1 th:text=&quot;#{welcome.message}&quot;&gt;Welcome&lt;/h1&gt;
    &lt;div&gt;
        &lt;a href=&quot;?lang=en&quot;&gt;English&lt;/a&gt;
        &lt;a href=&quot;?lang=fr&quot;&gt;Français&lt;/a&gt;
        &lt;a href=&quot;?lang=es&quot;&gt;Español&lt;/a&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="5">
    <li><strong>Date and number formatting</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class FormatConfig {
    @Bean
    public LocaleContextHolder localeContextHolder() {
        return new LocaleContextHolder();
    }

    @Bean
    public LocalDateTimeFormat localDateTimeFormat() {
        return new LocalDateTimeFormat();
    }
}

@Controller
public class FormatExampleController {
    @GetMapping(&quot;/format-example&quot;)
    public String formatExample(Model model, Locale locale) {
        NumberFormat numberFormat = NumberFormat.getCurrencyInstance(locale);
        DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.DEFAULT, locale);

        model.addAttribute(&quot;price&quot;, numberFormat.format(1234.56));
        model.addAttribute(&quot;today&quot;, dateFormat.format(new Date()));

        return &quot;format-example&quot;;
    }
}
</code></pre>
<h3 id="69-how-do-you-implement-file-uploaddownload-in-spring-boot">69. How do you implement file upload/download in Spring Boot?</h3>
<p>File upload and download implementation in Spring Boot:</p>
<ol>
    <li><strong>Configure upload limits</strong>:</li>
</ol>
<pre><code class="language-properties"># Maximum file size
spring.servlet.multipart.max-file-size=10MB
# Maximum request size
spring.servlet.multipart.max-request-size=10MB
</code></pre>
<ol start="2">
    <li><strong>File upload controller</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/files&quot;)
public class FileController {
    private final String uploadDir = &quot;uploads/&quot;;

    @PostMapping(&quot;/upload&quot;)
    public ResponseEntity&lt;FileResponse&gt; uploadFile(@RequestParam(&quot;file&quot;) MultipartFile file) {
        try {
            // Create directory if it doesn&#39;t exist
            File directory = new File(uploadDir);
            if (!directory.exists()) {
                directory.mkdirs();
            }

            // Generate unique filename
            String fileName = UUID.randomUUID().toString() + &quot;_&quot; + file.getOriginalFilename();
            Path filePath = Paths.get(uploadDir + fileName);

            // Save file
            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);

            FileResponse response = new FileResponse(
                fileName,
                file.getContentType(),
                file.getSize()
            );

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping(&quot;/download/{fileName}&quot;)
    public ResponseEntity&lt;Resource&gt; downloadFile(@PathVariable String fileName) {
        try {
            Path filePath = Paths.get(uploadDir + fileName);
            Resource resource = new UrlResource(filePath.toUri());

            if (resource.exists()) {
                return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=\&quot;&quot; + resource.getFilename() + &quot;\&quot;&quot;)
                    .body(resource);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}
</code></pre>
<ol start="3">
    <li><strong>Handle multiple files</strong>:</li>
</ol>
<pre><code class="language-java">@PostMapping(&quot;/upload-multiple&quot;)
public ResponseEntity&lt;List&lt;FileResponse&gt;&gt; uploadMultipleFiles(
        @RequestParam(&quot;files&quot;) MultipartFile[] files) {

    List&lt;FileResponse&gt; responses = new ArrayList&lt;&gt;();

    Arrays.asList(files).forEach(file -&gt; {
        try {
            String fileName = UUID.randomUUID() + &quot;_&quot; + file.getOriginalFilename();
            Path filePath = Paths.get(uploadDir + fileName);

            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);

            responses.add(new FileResponse(
                fileName,
                file.getContentType(),
                file.getSize()
            ));
        } catch (Exception e) {
            // Handle exception
        }
    });

    return ResponseEntity.ok(responses);
}
</code></pre>
<ol start="4">
    <li><strong>File storage service</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class FileStorageService {
    private final Path fileStorageLocation;

    @Autowired
    public FileStorageService(@Value(&quot;${file.upload-dir:uploads}&quot;) String uploadDir) {
        this.fileStorageLocation = Paths.get(uploadDir)
            .toAbsolutePath().normalize();

        try {
            Files.createDirectories(this.fileStorageLocation);
        } catch (Exception ex) {
            throw new RuntimeException(&quot;Could not create the directory&quot;, ex);
        }
    }

    public String storeFile(MultipartFile file) {
        // Normalize file name
        String fileName = StringUtils.cleanPath(file.getOriginalFilename());

        try {
            // Check for invalid characters
            if (fileName.contains(&quot;..&quot;)) {
                throw new RuntimeException(&quot;Invalid path sequence in filename&quot;);
            }

            String uniqueFileName = UUID.randomUUID().toString() + &quot;_&quot; + fileName;
            Path targetLocation = this.fileStorageLocation.resolve(uniqueFileName);
            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);

            return uniqueFileName;
        } catch (IOException ex) {
            throw new RuntimeException(&quot;Could not store file&quot;, ex);
        }
    }

    public Resource loadFileAsResource(String fileName) {
        try {
            Path filePath = this.fileStorageLocation.resolve(fileName).normalize();
            Resource resource = new UrlResource(filePath.toUri());

            if (resource.exists()) {
                return resource;
            } else {
                throw new RuntimeException(&quot;File not found: &quot; + fileName);
            }
        } catch (Exception ex) {
            throw new RuntimeException(&quot;File not found: &quot; + fileName, ex);
        }
    }
}
</code></pre>
<ol start="5">
    <li><strong>Progress tracking</strong> (with JavaScript frontend):</li>
</ol>
<pre><code class="language-javascript">function uploadFile() {
    const file = document.getElementById(&#39;fileInput&#39;).files[0];
    const formData = new FormData();
    formData.append(&#39;file&#39;, file);

    const xhr = new XMLHttpRequest();
    xhr.open(&#39;POST&#39;, &#39;/api/files/upload&#39;, true);

    xhr.upload.onprogress = function(e) {
        if (e.lengthComputable) {
            const percentComplete = (e.loaded / e.total) * 100;
            document.getElementById(&#39;progress&#39;).style.width = percentComplete + &#39;%&#39;;
        }
    };

    xhr.onload = function() {
        if (xhr.status === 200) {
            console.log(&#39;Upload complete&#39;);
        }
    };

    xhr.send(formData);
}
</code></pre>
<h3 id="70-what-is-spring-boots-support-for-messaging">70. What is Spring Boot&#39;s support for messaging?</h3>
<p>Spring Boot supports several messaging solutions:</p>
<ol>
    <li><strong>JMS (Java Message Service)</strong> with ActiveMQ:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableJms
public class JmsConfig {
    @Bean
    public Queue queue() {
        return new ActiveMQQueue(&quot;orders.queue&quot;);
    }
}

@Component
public class MessageSender {
    private final JmsTemplate jmsTemplate;
    private final Queue queue;

    public MessageSender(JmsTemplate jmsTemplate, Queue queue) {
        this.jmsTemplate = jmsTemplate;
        this.queue = queue;
    }

    public void sendMessage(Order order) {
        jmsTemplate.convertAndSend(queue, order);
    }
}

@Component
public class OrderReceiver {
    @JmsListener(destination = &quot;orders.queue&quot;)
    public void receiveOrder(Order order) {
        System.out.println(&quot;Received order: &quot; + order);
        // Process the order
    }
}
</code></pre>
<ol start="2">
    <li><strong>RabbitMQ</strong> with AMQP:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class RabbitMQConfig {
    @Bean
    public Queue ordersQueue() {
        return new Queue(&quot;orders.queue&quot;, false);
    }

    @Bean
    public DirectExchange exchange() {
        return new DirectExchange(&quot;orders.exchange&quot;);
    }

    @Bean
    public Binding binding(Queue queue, DirectExchange exchange) {
        return BindingBuilder.bind(queue)
                .to(exchange)
                .with(&quot;orders.routing.key&quot;);
    }
}

@Component
public class OrderSender {
    private final RabbitTemplate rabbitTemplate;

    public OrderSender(RabbitTemplate rabbitTemplate) {
        this.rabbitTemplate = rabbitTemplate;
    }

    public void sendOrder(Order order) {
        rabbitTemplate.convertAndSend(&quot;orders.exchange&quot;, &quot;orders.routing.key&quot;, order);
    }
}

@Component
public class OrderReceiver {
    @RabbitListener(queues = &quot;orders.queue&quot;)
    public void receiveOrder(Order order) {
        System.out.println(&quot;Received order: &quot; + order);
        // Process the order
    }
}
</code></pre>
<ol start="3">
    <li><strong>Kafka</strong> support:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class KafkaConfig {
    @Bean
    public ProducerFactory&lt;String, Order&gt; producerFactory() {
        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();
        config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;);
        config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return new DefaultKafkaProducerFactory&lt;&gt;(config);
    }

    @Bean
    public KafkaTemplate&lt;String, Order&gt; kafkaTemplate() {
        return new KafkaTemplate&lt;&gt;(producerFactory());
    }

    @Bean
    public ConsumerFactory&lt;String, Order&gt; consumerFactory() {
        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();
        config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;);
        config.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;orders-group&quot;);
        config.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        config.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
        return new DefaultKafkaConsumerFactory&lt;&gt;(config,
                new StringDeserializer(),
                new JsonDeserializer&lt;&gt;(Order.class));
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory&lt;String, Order&gt; kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory&lt;String, Order&gt; factory =
                new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
        factory.setConsumerFactory(consumerFactory());
        return factory;
    }
}

@Service
public class OrderProducer {
    private final KafkaTemplate&lt;String, Order&gt; kafkaTemplate;

    public OrderProducer(KafkaTemplate&lt;String, Order&gt; kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    public void sendOrder(Order order) {
        kafkaTemplate.send(&quot;orders&quot;, order);
    }
}

@Service
public class OrderConsumer {
    @KafkaListener(topics = &quot;orders&quot;, groupId = &quot;orders-group&quot;)
    public void consume(Order order) {
        System.out.println(&quot;Received order: &quot; + order);
        // Process the order
    }
}
</code></pre>
<ol start="4">
    <li><strong>Spring Integration</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-integration&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableIntegration
public class IntegrationConfig {
    @Bean
    public DirectChannel ordersChannel() {
        return new DirectChannel();
    }

    @Bean
    public IntegrationFlow orderFlow() {
        return IntegrationFlows.from(&quot;ordersChannel&quot;)
                .filter(Order.class, order -&gt; order.getAmount() &gt; 0)
                .transform(Order.class, this::enrichOrder)
                .handle(this::processOrder)
                .get();
    }

    private Order enrichOrder(Order order) {
        order.setProcessedTime(LocalDateTime.now());
        return order;
    }

    private void processOrder(Order order) {
        System.out.println(&quot;Processing order: &quot; + order);
    }
}

@Service
public class OrderGateway {
    @Autowired
    private MessageChannel ordersChannel;

    public void sendOrder(Order order) {
        ordersChannel.send(MessageBuilder.withPayload(order).build());
    }
}
</code></pre>
<h2 id="microservices-and-cloud-integration">Microservices and Cloud Integration</h2>
<h3 id="71-what-are-spring-boot-profiles">71. What are Spring Boot Profiles?</h3>
<p>Spring profiles provide a way to segregate parts of application configuration and make them available only in certain environments.</p>
<p><strong>Key features:</strong></p>
<ul>
    <li>Configure environment-specific properties</li>
    <li>Activate different beans based on environment</li>
    <li>Enable different behaviors in various environments</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><code class="language-properties"># application-dev.properties
server.port=8080
logging.level.root=DEBUG

# application-prod.properties
server.port=80
logging.level.root=WARN
</code></pre>
<pre><code class="language-java">// Profile-specific beans
@Configuration
@Profile(&quot;dev&quot;)
public class DevConfig {
    @Bean
    public DataSource dataSource() {
        // Return in-memory database
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
}

@Configuration
@Profile(&quot;prod&quot;)
public class ProdConfig {
    @Bean
    public DataSource dataSource() {
        // Return production datasource
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl(&quot;jdbc:mysql://prod-db:3306/myapp&quot;);
        return ds;
    }
}
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash"># Run with specific profile
java -jar app.jar --spring.profiles.active=dev

# Multiple profiles
java -jar app.jar --spring.profiles.active=dev,local

# Using environment variable
export SPRING_PROFILES_ACTIVE=prod
java -jar app.jar
</code></pre>
<pre><code class="language-java">// Programmatically
SpringApplication app = new SpringApplication(Application.class);
app.setAdditionalProfiles(&quot;dev&quot;);
app.run(args);
</code></pre>
<h3 id="72-how-do-you-implement-microservices-using-spring-boot">72. How do you implement microservices using Spring Boot?</h3>
<p>Spring Boot is well-suited for microservices architecture:</p>
<ol>
    <li><strong>Service Discovery</strong> with Eureka:</li>
</ol>
<pre><code class="language-xml">&lt;!-- Eureka Server --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;!-- Eureka Client --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient
public class ServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceApplication.class, args);
    }
}
</code></pre>
<ol start="2">
    <li><strong>API Gateway</strong> with Spring Cloud Gateway:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient
public class GatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}
</code></pre>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://USER-SERVICE
          predicates:
            - Path=/api/users/**
        - id: order-service
          uri: lb://ORDER-SERVICE
          predicates:
            - Path=/api/orders/**
</code></pre>
<ol start="3">
    <li><strong>Circuit Breaker</strong> with Resilience4j:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-circuitbreaker-resilience4j&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@RestController
public class ServiceController {
    private final WebClient.Builder webClientBuilder;
    private final CircuitBreakerFactory circuitBreakerFactory;

    @GetMapping(&quot;/orders/{id}&quot;)
    public ResponseEntity&lt;Order&gt; getOrder(@PathVariable String id) {
        CircuitBreaker circuitBreaker = circuitBreakerFactory.create(&quot;orderService&quot;);

        Order order = circuitBreaker.run(
            () -&gt; webClientBuilder.build()
                .get()
                .uri(&quot;http://ORDER-SERVICE/orders/{id}&quot;, id)
                .retrieve()
                .bodyToMono(Order.class)
                .block(),
            throwable -&gt; fallbackOrder(id, throwable)
        );

        return ResponseEntity.ok(order);
    }

    private Order fallbackOrder(String id, Throwable t) {
        return new Order(id, &quot;Fallback order&quot;, Collections.emptyList());
    }
}
</code></pre>
<ol start="4">
    <li><strong>Configuration Server</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;!-- Config Server --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;!-- Config Client --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties">spring.config.import=optional:configserver:http://config-server:8888
spring.application.name=order-service
</code></pre>
<ol start="5">
    <li><strong>Distributed Tracing</strong> with Spring Cloud Sleuth and Zipkin:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-sleuth-zipkin&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties">spring.zipkin.base-url=http://zipkin:9411
spring.sleuth.sampler.probability=1.0
</code></pre>
<h3 id="73-what-is-spring-cloud-config-how-does-it-work-with-spring-boot">73. What is Spring Cloud Config? How does it work with Spring Boot?</h3>
<p>Spring Cloud Config provides server and client-side support for externalized configuration in a distributed system:</p>
<ol>
    <li><strong>Config Server</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
</code></pre>
<pre><code class="language-properties"># Server configuration
server.port=8888
spring.cloud.config.server.git.uri=https://github.com/myorg/config-repo
spring.cloud.config.server.git.clone-on-start=true
spring.cloud.config.server.git.default-label=main
</code></pre>
<ol start="2">
    <li><strong>Config Client</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># Client configuration
spring.application.name=order-service
spring.config.import=optional:configserver:http://config-server:8888
spring.cloud.config.fail-fast=true
spring.cloud.config.retry.max-attempts=6
spring.cloud.config.retry.initial-interval=1000
spring.cloud.config.retry.max-interval=2000

# Enable refresh endpoint
management.endpoints.web.exposure.include=refresh
</code></pre>
<ol start="3">
    <li><strong>Configuration file structure</strong>:</li>
</ol>
<pre><code>config-repo/
  order-service.properties        # Default properties
  order-service-dev.properties    # Dev-specific properties
  order-service-prod.properties   # Prod-specific properties
</code></pre>
<ol start="4">
    <li><strong>Dynamic configuration updates</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RefreshScope  // Component will re-initialize when config changes
public class ConfigurationController {

    @Value(&quot;${app.feature.enabled:false}&quot;)
    private boolean featureEnabled;

    @Value(&quot;${app.description:Default description}&quot;)
    private String description;

    @GetMapping(&quot;/config&quot;)
    public Map&lt;String, Object&gt; getConfig() {
        Map&lt;String, Object&gt; config = new HashMap&lt;&gt;();
        config.put(&quot;featureEnabled&quot;, featureEnabled);
        config.put(&quot;description&quot;, description);
        return config;
    }
}
</code></pre>
<ol start="5">
    <li><strong>Manual refresh</strong>:</li>
</ol>
<pre><code class="language-bash"># Trigger refresh on client
curl -X POST http://localhost:8080/actuator/refresh
</code></pre>
<ol start="6">
    <li><strong>Automatic refresh with Spring Cloud Bus</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># Expose bus-refresh endpoint
management.endpoints.web.exposure.include=refresh,bus-refresh

# RabbitMQ connection (for Bus communication)
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
</code></pre>
<h3 id="74-what-is-spring-cloud-netflix-what-components-does-it-include">74. What is Spring Cloud Netflix? What components does it include?</h3>
<p>Spring Cloud Netflix integrates Netflix OSS components into the Spring ecosystem:</p>
<ol>
    <li><strong>Eureka</strong> - Service Discovery and Registration:</li>
</ol>
<pre><code class="language-xml">&lt;!-- Server --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;!-- Client --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient
public class ServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceApplication.class, args);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Ribbon</strong> - Client-Side Load Balancing:</li>
</ol>
<pre><code class="language-java">@Configuration
public class RibbonConfig {
    @Bean
    public IPing ribbonPing(IClientConfig config) {
        return new PingUrl();
    }

    @Bean
    public IRule ribbonRule(IClientConfig config) {
        return new WeightedResponseTimeRule();
    }
}
</code></pre>
<pre><code class="language-java">@LoadBalanced
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate();
}

// Usage
restTemplate.getForObject(&quot;http://USER-SERVICE/users/{id}&quot;, User.class, id);
</code></pre>
<ol start="3">
    <li><strong>Hystrix</strong> - Circuit Breaker (Note: Being replaced by Resilience4j):</li>
</ol>
<pre><code class="language-java">@HystrixCommand(fallbackMethod = &quot;getDefaultUser&quot;)
public User getUserById(String id) {
    return restTemplate.getForObject(&quot;http://USER-SERVICE/users/{id}&quot;, User.class, id);
}

public User getDefaultUser(String id) {
    return new User(id, &quot;Default User&quot;);
}
</code></pre>
<ol start="4">
    <li><strong>Zuul</strong> - API Gateway (Note: Being replaced by Spring Cloud Gateway):</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableZuulProxy
public class GatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}
</code></pre>
<pre><code class="language-properties">zuul.routes.users.path=/api/users/**
zuul.routes.users.service-id=USER-SERVICE

zuul.routes.orders.path=/api/orders/**
zuul.routes.orders.service-id=ORDER-SERVICE
</code></pre>
<h3 id="75-what-is-eureka-in-spring-cloud-how-do-you-implement-service-discovery">75. What is Eureka in Spring Cloud? How do you implement service discovery?</h3>
<p>Eureka is a service discovery server and client for locating services in a microservices architecture:</p>
<ol>
    <li><strong>Set up Eureka Server</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
</code></pre>
<pre><code class="language-properties"># Eureka Server configuration
server.port=8761
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.server.wait-time-in-ms-when-sync-empty=0
eureka.server.renewal-percent-threshold=0.85
</code></pre>
<ol start="2">
    <li><strong>Set up Service Registration (Eureka Client)</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient  // or @EnableEurekaClient
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}
</code></pre>
<pre><code class="language-properties"># Client configuration
spring.application.name=user-service
server.port=8080
eureka.client.service-url.defaultZone=http://eureka-server:8761/eureka/
eureka.instance.prefer-ip-address=true
eureka.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}
</code></pre>
<ol start="3">
    <li><strong>Service Discovery and Load Balanced REST Client</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class RestTemplateConfig {
    @Bean
    @LoadBalanced  // Enables client-side load balancing
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
</code></pre>
<pre><code class="language-java">@Service
public class OrderService {
    private final RestTemplate restTemplate;

    public OrderService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public User getUserForOrder(Long userId) {
        // Service name (not hostname) is used in URL
        return restTemplate.getForObject(&quot;http://user-service/users/{id}&quot;, User.class, userId);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Using DiscoveryClient Directly</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class UserServiceLookup {
    private final DiscoveryClient discoveryClient;
    private final RestTemplate plainRestTemplate;  // Not load-balanced

    public User getUserById(Long id) {
        // Get instances of user-service
        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;user-service&quot;);

        if (instances != null &amp;&amp; !instances.isEmpty()) {
            // Choose an instance (simple round-robin)
            ServiceInstance instance = instances.get(0);
            String url = instance.getUri().toString() + &quot;/users/&quot; + id;

            return plainRestTemplate.getForObject(url, User.class);
        }
        return null;
    }
}
</code></pre>
<ol start="5">
    <li><strong>Additional Eureka Configuration</strong>:</li>
</ol>
<pre><code class="language-properties"># Server configuration
eureka.server.enable-self-preservation=false  # For development only

# Client configuration
eureka.client.registry-fetch-interval-seconds=5
eureka.instance.lease-renewal-interval-in-seconds=10
eureka.instance.lease-expiration-duration-in-seconds=30
eureka.instance.metadata-map.zone=zone1
eureka.instance.status-page-url=https://${eureka.hostname}/info
eureka.instance.health-check-url=https://${eureka.hostname}/health
</code></pre>
<ol start="6">
    <li><strong>Securing Eureka</strong>:</li>
</ol>
<pre><code class="language-properties"># Enable authentication for Eureka server
spring.security.user.name=eureka
spring.security.user.password=password

# Client configuration for authentication
eureka.client.service-url.defaultZone=http://eureka:password@eureka-server:8761/eureka/
</code></pre>
<h3 id="76-what-are-spring-cloud-circuit-breakers-how-do-they-work">76. What are Spring Cloud Circuit Breakers? How do they work?</h3>
<p>Circuit breakers prevent cascading failures in distributed systems by failing fast and providing fallbacks:</p>
<ol>
    <li><strong>Resilience4j Circuit Breaker</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-circuitbreaker-resilience4j&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Service
public class ProductService {
    private final CircuitBreakerFactory circuitBreakerFactory;
    private final RestTemplate restTemplate;

    public ProductService(CircuitBreakerFactory circuitBreakerFactory, RestTemplate restTemplate) {
        this.circuitBreakerFactory = circuitBreakerFactory;
        this.restTemplate = restTemplate;
    }

    public Product getProductById(Long id) {
        CircuitBreaker circuitBreaker = circuitBreakerFactory.create(&quot;productService&quot;);

        return circuitBreaker.run(
            () -&gt; restTemplate.getForObject(&quot;http://product-service/products/{id}&quot;, Product.class, id),
            throwable -&gt; getDefaultProduct(id)
        );
    }

    private Product getDefaultProduct(Long id) {
        return new Product(id, &quot;Fallback Product&quot;, BigDecimal.ZERO);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Resilience4j Configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class Resilience4jConfig {
    @Bean
    public Customizer&lt;Resilience4JCircuitBreakerFactory&gt; defaultCustomizer() {
        return factory -&gt; factory.configureDefault(id -&gt; new Resilience4JConfigBuilder(id)
            .timeLimiterConfig(TimeLimiterConfig.custom()
                .timeoutDuration(Duration.ofSeconds(4))
                .build())
            .circuitBreakerConfig(CircuitBreakerConfig.custom()
                .failureRateThreshold(50)
                .waitDurationInOpenState(Duration.ofMillis(1000))
                .slidingWindowSize(10)
                .permittedNumberOfCallsInHalfOpenState(3)
                .build())
            .build());
    }
}
</code></pre>
<ol start="3">
    <li><strong>Annotation-Based Resilience4j</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt;
    &lt;artifactId&gt;resilience4j-spring-boot2&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Service
public class PaymentService {
    private final RestTemplate restTemplate;

    @CircuitBreaker(name = &quot;paymentService&quot;, fallbackMethod = &quot;processPaymentFallback&quot;)
    public PaymentResponse processPayment(PaymentRequest request) {
        return restTemplate.postForObject(&quot;http://payment-processor/process&quot;,
                                        request, PaymentResponse.class);
    }

    public PaymentResponse processPaymentFallback(PaymentRequest request, Exception e) {
        return new PaymentResponse(&quot;offline-&quot; + UUID.randomUUID().toString(),
                                 &quot;PENDING&quot;,
                                 &quot;Payment queued for processing&quot;);
    }
}
</code></pre>
<pre><code class="language-properties"># application.properties
resilience4j.circuitbreaker.instances.paymentService.registerHealthIndicator=true
resilience4j.circuitbreaker.instances.paymentService.slidingWindowSize=10
resilience4j.circuitbreaker.instances.paymentService.minimumNumberOfCalls=5
resilience4j.circuitbreaker.instances.paymentService.permittedNumberOfCallsInHalfOpenState=3
resilience4j.circuitbreaker.instances.paymentService.waitDurationInOpenState=5s
resilience4j.circuitbreaker.instances.paymentService.failureRateThreshold=50
</code></pre>
<ol start="4">
    <li><strong>Combining Circuit Breaker with Retry</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class ProductService {
    @CircuitBreaker(name = &quot;productService&quot;, fallbackMethod = &quot;getProductFallback&quot;)
    @Retry(name = &quot;productService&quot;, fallbackMethod = &quot;getProductFallback&quot;)
    public Product getProduct(Long id) {
        return restTemplate.getForObject(&quot;http://product-service/products/{id}&quot;,
                                       Product.class, id);
    }

    private Product getProductFallback(Long id, Exception e) {
        return new Product(id, &quot;Default Product&quot;, BigDecimal.ZERO);
    }
}
</code></pre>
<pre><code class="language-properties"># Retry configuration
resilience4j.retry.instances.productService.maxAttempts=3
resilience4j.retry.instances.productService.waitDuration=1s
resilience4j.retry.instances.productService.enableExponentialBackoff=true
resilience4j.retry.instances.productService.exponentialBackoffMultiplier=2
</code></pre>
<ol start="5">
    <li><strong>Circuit Breaker States</strong>:</li>
</ol>
<ul>
    <li><strong>CLOSED</strong>: Normal operation, requests pass through</li>
    <li><strong>OPEN</strong>: Circuit is broken, requests fail fast without calling service</li>
    <li><strong>HALF-OPEN</strong>: After wait duration, some requests allowed through to test if service is healthy</li>
</ul>
<ol start="6">
    <li><strong>Monitoring Circuit Breakers with Actuator</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties">management.endpoints.web.exposure.include=health,circuitbreakers
management.endpoint.health.show-details=always
management.health.circuitbreakers.enabled=true
</code></pre>
<h3 id="77-what-is-spring-cloud-gateway-how-is-it-different-from-netflix-zuul">77. What is Spring Cloud Gateway? How is it different from Netflix Zuul?</h3>
<p>Spring Cloud Gateway is a modern API gateway built on Spring WebFlux:</p>
<ol>
    <li><strong>Gateway Setup</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient
public class GatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Route Configuration in YAML</strong>:</li>
</ol>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://USER-SERVICE
          predicates:
            - Path=/api/users/**
          filters:
            - StripPrefix=1
            - AddRequestHeader=X-Request-Source, gateway

        - id: order-service
          uri: lb://ORDER-SERVICE
          predicates:
            - Path=/api/orders/**
            - Method=GET,POST
          filters:
            - StripPrefix=1
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10
                redis-rate-limiter.burstCapacity: 20
</code></pre>
<ol start="3">
    <li><strong>Java Route Configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class GatewayConfig {
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            .route(&quot;user-service&quot;, r -&gt; r
                .path(&quot;/api/users/**&quot;)
                .filters(f -&gt; f
                    .stripPrefix(1)
                    .addRequestHeader(&quot;X-Request-Source&quot;, &quot;gateway&quot;))
                .uri(&quot;lb://USER-SERVICE&quot;))
            .route(&quot;product-service&quot;, r -&gt; r
                .path(&quot;/api/products/**&quot;)
                .filters(f -&gt; f
                    .stripPrefix(1)
                    .rewritePath(&quot;/products/(?&lt;id&gt;.*)&quot;, &quot;/products/${id}&quot;))
                .uri(&quot;lb://PRODUCT-SERVICE&quot;))
            .build();
    }
}
</code></pre>
<ol start="4">
    <li><strong>Creating Custom Filters</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class LoggingFilter implements GlobalFilter {
    private final Logger logger = LoggerFactory.getLogger(LoggingFilter.class);

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        logger.info(&quot;Request path: {}&quot;, exchange.getRequest().getPath());

        return chain.filter(exchange)
            .then(Mono.fromRunnable(() -&gt; {
                HttpStatus statusCode = exchange.getResponse().getStatusCode();
                logger.info(&quot;Response status: {}&quot;, statusCode);
            }));
    }
}
</code></pre>
<ol start="5">
    <li><strong>Gateway Filter Factory</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class AuthenticationGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;AuthenticationGatewayFilterFactory.Config&gt; {

    public AuthenticationGatewayFilterFactory() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -&gt; {
            String authHeader = exchange.getRequest().getHeaders().getFirst(&quot;Authorization&quot;);

            if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {
                exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                return exchange.getResponse().setComplete();
            }

            // Validate token...

            return chain.filter(exchange);
        };
    }

    public static class Config {
        // Filter configuration properties
        private String role;

        // Getters and setters
    }
}
</code></pre>
<ol start="6">
    <li><p><strong>Key Differences from Netflix Zuul</strong>:</p>
        <ul>
            <li>Spring Cloud Gateway is built on Spring WebFlux (non-blocking)</li>
            <li>Zuul 1.x is built on Servlet API (blocking)</li>
            <li>Gateway has better performance for most use cases</li>
            <li>Gateway supports WebSocket</li>
            <li>Gateway is actively maintained while Netflix has put Zuul in maintenance mode</li>
            <li>More flexible predicate and filter system in Gateway</li>
            <li>Gateway supports reactive programming model</li>
        </ul>
    </li>
    <li><p><strong>Rate Limiting with Redis</strong>:</p>
    </li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Bean
public RedisRateLimiter redisRateLimiter() {
    return new RedisRateLimiter(10, 20);
}
</code></pre>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      routes:
        - id: rate-limited-service
          uri: lb://SERVICE
          predicates:
            - Path=/api/limited/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 1
                redis-rate-limiter.burstCapacity: 3
                key-resolver: &quot;#{@userKeyResolver}&quot;
</code></pre>
<pre><code class="language-java">@Bean
public KeyResolver userKeyResolver() {
    return exchange -&gt; Mono.just(
        Optional.ofNullable(exchange.getRequest().getHeaders().getFirst(&quot;X-User-Id&quot;))
            .orElse(&quot;anonymous&quot;)
    );
}
</code></pre>
<h3 id="78-what-is-spring-cloud-config-how-would-you-secure-sensitive-configuration-data">78. What is Spring Cloud Config? How would you secure sensitive configuration data?</h3>
<p>Spring Cloud Config provides server and client-side support for externalized configuration in a distributed system.</p>
<p><strong>Securing sensitive configuration data:</strong></p>
<ol>
    <li><strong>Using Encryption/Decryption with symmetric key</strong>:</li>
</ol>
<pre><code class="language-properties"># In bootstrap.properties on config server
encrypt.key=secretkey

# Encrypted properties in config files
spring.datasource.password={cipher}87b7349466642197fb9c05347927bb5a32b64094e7d23739cbbcc969ae3a9c20
</code></pre>
<ol start="2">
    <li><strong>Using Asymmetric Encryption (RSA keypair)</strong>:</li>
</ol>
<pre><code class="language-bash"># Generate keystore
keytool -genkeypair -alias configkey -keyalg RSA \
  -keystore config-server.jks -storepass storepass \
  -keypass keypass
</code></pre>
<pre><code class="language-properties"># In bootstrap.properties on config server
encrypt.keyStore.location=classpath:config-server.jks
encrypt.keyStore.password=storepass
encrypt.keyStore.alias=configkey
encrypt.keyStore.secret=keypass
</code></pre>
<ol start="3">
    <li><strong>Using HashiCorp Vault</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;!-- Add dependency --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-vault-config&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
</code></pre>
<pre><code class="language-properties"># Config server configuration
spring.cloud.config.server.vault.host=localhost
spring.cloud.config.server.vault.port=8200
spring.cloud.config.server.vault.scheme=http
spring.cloud.config.server.vault.authentication=token
spring.cloud.config.server.vault.token=s.Jyu8KkJl9ygj9IQmaKtoR7qA
</code></pre>
<p>Client configuration:</p>
<pre><code class="language-properties">spring.cloud.vault.token=s.Jyu8KkJl9ygj9IQmaKtoR7qA
spring.cloud.vault.scheme=http
spring.cloud.vault.application-name=${spring.application.name}
spring.cloud.vault.host=localhost
spring.cloud.vault.port=8200
</code></pre>
<ol start="4">
    <li><strong>Using AWS Parameter Store</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-aws-parameter-store-config&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># Client configuration
aws.paramstore.enabled=true
aws.paramstore.prefix=/config
aws.paramstore.name=${spring.application.name}
aws.paramstore.profile-separator=_
</code></pre>
<ol start="5">
    <li><strong>Access Control for Config Server</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeHttpRequests(auth -&gt; auth
                .requestMatchers(&quot;/encrypt/**&quot;).hasRole(&quot;ADMIN&quot;)
                .requestMatchers(&quot;/decrypt/**&quot;).hasRole(&quot;ADMIN&quot;)
                .anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public InMemoryUserDetailsManager userDetailsManager() {
        UserDetails user = User.builder()
            .username(&quot;config-user&quot;)
            .password(&quot;{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW&quot;)
            .roles(&quot;USER&quot;)
            .build();

        UserDetails admin = User.builder()
            .username(&quot;admin&quot;)
            .password(&quot;{bcrypt}$2a$10$7EoIGR.MaZJiJzOdGc.7p.9wmqKvKwZGspL5MQ8DPzMGVgU3tZW2y&quot;)
            .roles(&quot;USER&quot;, &quot;ADMIN&quot;)
            .build();

        return new InMemoryUserDetailsManager(user, admin);
    }
}
</code></pre>
<p>Client authentication:</p>
<pre><code class="language-properties">spring.cloud.config.username=config-user
spring.cloud.config.password=password
</code></pre>
<ol start="6">
    <li><strong>Git encryption tools</strong> like git-crypt:</li>
</ol>
<pre><code class="language-bash"># Initialize git-crypt in your config repository
git-crypt init

# Configure which files to encrypt in .gitattributes
echo &quot;*.properties filter=git-crypt diff=git-crypt&quot; &gt; .gitattributes
echo &quot;*.yml filter=git-crypt diff=git-crypt&quot; &gt;&gt; .gitattributes

# Add users
git-crypt add-gpg-user USER_ID
</code></pre>
<ol start="7">
    <li><strong>Environment variables and secrets mounting</strong> in containerized environments:</li>
</ol>
<pre><code class="language-yaml"># Docker Compose
services:
  config-server:
    image: config-server:latest
    environment:
      - ENCRYPT_KEY=${ENCRYPT_KEY}
      - SPRING_CLOUD_CONFIG_SERVER_GIT_USERNAME=${GIT_USERNAME}
      - SPRING_CLOUD_CONFIG_SERVER_GIT_PASSWORD=${GIT_PASSWORD}
</code></pre>
<pre><code class="language-yaml"># Kubernetes
apiVersion: v1
kind: Secret
metadata:
  name: config-server-secrets
type: Opaque
data:
  encrypt-key: c2VjcmV0a2V5
  git-username: dXNlcm5hbWU=
  git-password: cGFzc3dvcmQ=
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: config-server
spec:
  template:
    spec:
      containers:
      - name: config-server
        env:
        - name: ENCRYPT_KEY
          valueFrom:
            secretKeyRef:
              name: config-server-secrets
              key: encrypt-key
</code></pre>
<h3 id="79-what-is-spring-cloud-sleuth-how-do-you-implement-distributed-tracing">79. What is Spring Cloud Sleuth? How do you implement distributed tracing?</h3>
<p>Spring Cloud Sleuth is a distributed tracing solution for Spring Cloud applications, capturing timing data to visualize call flows:</p>
<ol>
    <li><strong>Basic Setup</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-sleuth-zipkin&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Configuration</strong>:</li>
</ol>
<pre><code class="language-properties">spring.application.name=order-service
spring.sleuth.sampler.probability=1.0
spring.zipkin.base-url=http://zipkin:9411
</code></pre>
<ol start="3">
    <li><strong>Auto-instrumentation</strong>: Sleuth automatically instruments:</li>
</ol>
<ul>
    <li>Spring MVC controllers</li>
    <li>RestTemplate</li>
    <li>WebClient</li>
    <li>Feign client</li>
    <li>Messaging (RabbitMQ, Kafka)</li>
</ul>
<ol start="4">
    <li><strong>Example tracing across microservices</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderService {
    private final RestTemplate restTemplate;
    private final Logger logger = LoggerFactory.getLogger(OrderService.class);

    public Order createOrder(OrderRequest request) {
        // Trace ID and Span ID automatically included in logs
        logger.info(&quot;Creating order for user: {}&quot;, request.getUserId());

        // Trace context propagated in HTTP headers automatically
        User user = restTemplate.getForObject(
            &quot;http://user-service/users/{id}&quot;,
            User.class,
            request.getUserId()
        );

        // Process order...
        logger.info(&quot;Order created: {}&quot;, order.getId());
        return order;
    }
}
</code></pre>
<ol start="5">
    <li><strong>Manual Span Creation</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class InventoryService {
    private final Tracer tracer;

    public boolean checkAvailability(String productId, int quantity) {
        Span newSpan = tracer.nextSpan().name(&quot;check-inventory&quot;);

        try (SpanInScope ws = tracer.withSpan(newSpan.start())) {
            newSpan.tag(&quot;product.id&quot;, productId);
            newSpan.tag(&quot;quantity&quot;, String.valueOf(quantity));

            // Complex inventory check logic
            boolean available = performInventoryCheck(productId, quantity);

            newSpan.tag(&quot;available&quot;, String.valueOf(available));
            return available;
        } finally {
            newSpan.finish();
        }
    }
}
</code></pre>
<ol start="6">
    <li><strong>Starting Zipkin Server</strong> (for visualization):</li>
</ol>
<pre><code class="language-bash"># Docker
docker run -d -p 9411:9411 openzipkin/zipkin
</code></pre>
<ol start="7">
    <li><strong>Custom Span Name</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/orders&quot;)
public class OrderController {
    @NewSpan(&quot;create-order-span&quot;)  // Custom span name
    @PostMapping
    public Order createOrder(@RequestBody OrderRequest request) {
        return orderService.createOrder(request);
    }

    @SpanName(&quot;get-order-span&quot;)  // Alternative annotation
    @GetMapping(&quot;/{id}&quot;)
    public Order getOrder(@PathVariable String id) {
        return orderService.getOrder(id);
    }
}
</code></pre>
<ol start="8">
    <li><strong>Generate Baggage (propagated metadata)</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class BaggageService {
    private final BaggageManager baggageManager;

    public void processWith(String userId) {
        // Add context that propagates across service calls
        BaggagePropagationConfig config = BaggagePropagationConfig
            .builder(BaggagePropagationConfig.SingleBaggageField
                .remote(BaggageField.create(&quot;user-id&quot;)))
            .build();

        this.baggageManager.createBaggage(&quot;user-id&quot;, userId, config);

        // Process with user context available in all downstream services
    }
}
</code></pre>
<ol start="9">
    <li><strong>Open Telemetry Migration</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;!-- Spring Cloud Sleuth with OpenTelemetry --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-sleuth-otel-autoconfigure&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;
    &lt;artifactId&gt;opentelemetry-exporter-zipkin&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># OTel configuration
spring.sleuth.otel.config.trace-id-ratio-based=1.0
spring.sleuth.otel.exporter.otlp.endpoint=http://jaeger:4317
</code></pre>
<h3 id="80-how-do-you-handle-api-versioning-in-microservices-with-spring-boot">80. How do you handle API versioning in microservices with Spring Boot?</h3>
<p>API versioning in microservices ensures backward compatibility while allowing evolution:</p>
<ol>
    <li><strong>URI Path Versioning</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/v1/products&quot;)
public class ProductControllerV1 {
    @GetMapping(&quot;/{id}&quot;)
    public ProductV1 getProductV1(@PathVariable Long id) {
        // Return v1 representation
    }
}

@RestController
@RequestMapping(&quot;/api/v2/products&quot;)
public class ProductControllerV2 {
    @GetMapping(&quot;/{id}&quot;)
    public ProductV2 getProductV2(@PathVariable Long id) {
        // Return v2 representation with enhanced fields
    }
}
</code></pre>
<ol start="2">
    <li><strong>Request Parameter Versioning</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @GetMapping(value = &quot;/{id}&quot;, params = &quot;version=1&quot;)
    public ProductV1 getProductV1(@PathVariable Long id) {
        // Return v1 representation
    }

    @GetMapping(value = &quot;/{id}&quot;, params = &quot;version=2&quot;)
    public ProductV2 getProductV2(@PathVariable Long id) {
        // Return v2 representation
    }
}
</code></pre>
<ol start="3">
    <li><strong>Header Versioning</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @GetMapping(value = &quot;/{id}&quot;, headers = &quot;X-API-VERSION=1&quot;)
    public ProductV1 getProductV1(@PathVariable Long id) {
        // Return v1 representation
    }

    @GetMapping(value = &quot;/{id}&quot;, headers = &quot;X-API-VERSION=2&quot;)
    public ProductV2 getProductV2(@PathVariable Long id) {
        // Return v2 representation
    }
}
</code></pre>
<ol start="4">
    <li><strong>Media Type Versioning</strong> (Content Negotiation):</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @GetMapping(
        value = &quot;/{id}&quot;,
        produces = &quot;application/vnd.company.app-v1+json&quot;
    )
    public ProductV1 getProductV1(@PathVariable Long id) {
        // Return v1 representation
    }

    @GetMapping(
        value = &quot;/{id}&quot;,
        produces = &quot;application/vnd.company.app-v2+json&quot;
    )
    public ProductV2 getProductV2(@PathVariable Long id) {
        // Return v2 representation
    }
}
</code></pre>
<ol start="5">
    <li><strong>Handling Different Versions with Gateway</strong>:</li>
</ol>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      routes:
        - id: product-service-v1
          uri: lb://PRODUCT-SERVICE-V1
          predicates:
            - Path=/api/v1/products/**

        - id: product-service-v2
          uri: lb://PRODUCT-SERVICE-V2
          predicates:
            - Path=/api/v2/products/**
</code></pre>
<ol start="6">
    <li><strong>Version-specific DTOs with Mapping</strong>:</li>
</ol>
<pre><code class="language-java">// Version-specific DTOs
public class ProductV1DTO {
    private Long id;
    private String name;
    private BigDecimal price;
}

public class ProductV2DTO {
    private Long id;
    private String name;
    private BigDecimal price;
    private String description;
    private List&lt;String&gt; categories;
}

// Mapper
@Component
public class ProductMapper {
    public ProductV1DTO toV1DTO(Product product) {
        ProductV1DTO dto = new ProductV1DTO();
        dto.setId(product.getId());
        dto.setName(product.getName());
        dto.setPrice(product.getPrice());
        return dto;
    }

    public ProductV2DTO toV2DTO(Product product) {
        ProductV2DTO dto = new ProductV2DTO();
        dto.setId(product.getId());
        dto.setName(product.getName());
        dto.setPrice(product.getPrice());
        dto.setDescription(product.getDescription());
        dto.setCategories(product.getCategories());
        return dto;
    }
}

// Controller using mapper
@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    private final ProductService productService;
    private final ProductMapper mapper;

    @GetMapping(value = &quot;/{id}&quot;, headers = &quot;X-API-VERSION=1&quot;)
    public ProductV1DTO getProductV1(@PathVariable Long id) {
        Product product = productService.findById(id);
        return mapper.toV1DTO(product);
    }

    @GetMapping(value = &quot;/{id}&quot;, headers = &quot;X-API-VERSION=2&quot;)
    public ProductV2DTO getProductV2(@PathVariable Long id) {
        Product product = productService.findById(id);
        return mapper.toV2DTO(product);
    }
}
</code></pre>
<ol start="7">
    <li><strong>Documentation for Versioned APIs</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @Operation(
        summary = &quot;Get product by ID (V1)&quot;,
        description = &quot;Returns basic product information&quot;
    )
    @ApiResponses({
        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Product found&quot;),
        @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Product not found&quot;)
    })
    @GetMapping(value = &quot;/{id}&quot;, headers = &quot;X-API-VERSION=1&quot;)
    public ProductV1DTO getProductV1(@PathVariable Long id) {
        // Implementation
    }

    @Operation(
        summary = &quot;Get product by ID (V2)&quot;,
        description = &quot;Returns enhanced product information including categories&quot;
    )
    @ApiResponses({
        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Product found&quot;),
        @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Product not found&quot;)
    })
    @GetMapping(value = &quot;/{id}&quot;, headers = &quot;X-API-VERSION=2&quot;)
    public ProductV2DTO getProductV2(@PathVariable Long id) {
        // Implementation
    }
}
</code></pre>
<ol start="8">
    <li><strong>Handling Deprecated Versions</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @Deprecated
    @GetMapping(value = &quot;/{id}&quot;, headers = &quot;X-API-VERSION=1&quot;)
    public ProductV1DTO getProductV1(@PathVariable Long id) {
        // Implementation
    }

    @GetMapping(value = &quot;/{id}&quot;, headers = &quot;X-API-VERSION=2&quot;)
    public ProductV2DTO getProductV2(@PathVariable Long id) {
        // Implementation
    }
}
</code></pre>
<pre><code class="language-java">// Custom header to indicate deprecation
@Component
public class DeprecationHeaderFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
                       FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;

        if (httpRequest.getHeader(&quot;X-API-VERSION&quot;) != null &amp;&amp;
            httpRequest.getHeader(&quot;X-API-VERSION&quot;).equals(&quot;1&quot;)) {
            httpResponse.setHeader(&quot;Warning&quot;,
                &quot;299 - \&quot;This API version is deprecated and will be removed on 2023-12-31\&quot;&quot;);
        }

        chain.doFilter(request, response);
    }
}
</code></pre>
<h2 id="performance-observability-and-deployment">Performance, Observability, and Deployment</h2>
<h3 id="81-how-do-you-optimize-spring-boot-application-performance">81. How do you optimize Spring Boot application performance?</h3>
<p>Key performance optimization techniques for Spring Boot:</p>
<ol>
    <li><strong>JVM Tuning</strong>:</li>
</ol>
<pre><code class="language-bash"># Memory settings
java -Xms2g -Xmx2g -jar app.jar

# Garbage collection
java -XX:+UseG1GC -jar app.jar
</code></pre>
<ol start="2">
    <li><strong>Database optimizations</strong>:</li>
</ol>
<pre><code class="language-properties"># Connection pool tuning
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=30000

# JPA/Hibernate performance
spring.jpa.properties.hibernate.jdbc.batch_size=30
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.query.in_clause_parameter_padding=true
spring.jpa.properties.hibernate.query.fail_on_pagination_over_collection_fetch=true
spring.jpa.properties.hibernate.connection.provider_disables_autocommit=true
</code></pre>
<ol start="3">
    <li><strong>Caching implementation</strong>:</li>
</ol>
<pre><code class="language-java">@EnableCaching
@Configuration
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .expireAfterWrite(60, TimeUnit.MINUTES)
            .maximumSize(1000));
        return cacheManager;
    }
}

@Service
public class ProductService {
    @Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;)
    public Product getProduct(Long id) {
        // Method will be executed only if result not in cache
        return productRepository.findById(id).orElse(null);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Asynchronous processing</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class ReportService {
    @Async
    public CompletableFuture&lt;Report&gt; generateReportAsync(ReportRequest request) {
        // Long-running operation in separate thread
        Report report = generateReport(request);
        return CompletableFuture.completedFuture(report);
    }
}
</code></pre>
<ol start="5">
    <li><strong>HTTP response compression</strong>:</li>
</ol>
<pre><code class="language-properties"># Enable response compression
server.compression.enabled=true
server.compression.min-response-size=2048
server.compression.mime-types=application/json,application/xml,text/html,text/plain
</code></pre>
<ol start="6">
    <li><strong>Load lazy beans on demand</strong>:</li>
</ol>
<pre><code class="language-java">@Lazy
@Component
public class ExpensiveBean {
    // This bean is only initialized when requested
}
</code></pre>
<ol start="7">
    <li><strong>Use WebFlux for reactive applications</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @GetMapping
    public Flux&lt;Product&gt; getAllProducts() {
        return productRepository.findAll();
    }
}
</code></pre>
<ol start="8">
    <li><strong>Optimize JSON serialization</strong>:</li>
</ol>
<pre><code class="language-java">// Use @JsonIgnore for unnecessary fields
public class Product {
    @JsonIgnore
    private byte[] image;

    // Lazy-loaded collection is often not needed in responses
    @JsonIgnore
    private List&lt;Review&gt; reviews;
}

// Use @JsonView for different representations
public class User {
    public interface Summary {}
    public interface Detail extends Summary {}

    @JsonView(Summary.class)
    private Long id;

    @JsonView(Summary.class)
    private String name;

    @JsonView(Detail.class)
    private String email;
}

@GetMapping(&quot;/users&quot;)
@JsonView(User.Summary.class)
public List&lt;User&gt; getAll() {
    return userRepository.findAll();
}
</code></pre>
<ol start="9">
    <li><strong>HTTP/2 support</strong>:</li>
</ol>
<pre><code class="language-properties"># Enable HTTP/2
server.http2.enabled=true
</code></pre>
<ol start="10">
    <li><strong>Class data sharing and AppCDS</strong>:</li>
</ol>
<pre><code class="language-bash"># Create a class list
java -XX:DumpLoadedClassList=classes.lst -jar app.jar

# Create a shared archive
java -Xshare:dump -XX:SharedClassListFile=classes.lst -XX:SharedArchiveFile=app.jsa -jar app.jar

# Use the shared archive
java -Xshare:on -XX:SharedArchiveFile=app.jsa -jar app.jar
</code></pre>
<h3 id="82-how-do-you-implement-observability-in-spring-boot-applications">82. How do you implement observability in Spring Boot applications?</h3>
<p>Observability components in Spring Boot:</p>
<ol>
    <li><strong>Metrics with Micrometer</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
    &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># Enable metrics endpoints
management.endpoints.web.exposure.include=info,health,metrics,prometheus
management.metrics.export.prometheus.enabled=true
</code></pre>
<pre><code class="language-java">@RestController
public class ProductController {
    private final MeterRegistry meterRegistry;
    private final Counter productViewsCounter;

    public ProductController(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.productViewsCounter = meterRegistry.counter(&quot;app.product.views&quot;);
    }

    @GetMapping(&quot;/products/{id}&quot;)
    public Product getProduct(@PathVariable Long id) {
        // Record metric
        productViewsCounter.increment();

        // Record with tags
        meterRegistry.counter(&quot;app.product.views.detail&quot;,
            &quot;productId&quot;, id.toString(),
            &quot;user&quot;, SecurityContextHolder.getContext().getAuthentication().getName())
            .increment();

        return productService.getProduct(id);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Tracing with Spring Cloud Sleuth/OpenTelemetry</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
    &lt;artifactId&gt;micrometer-tracing-bridge-otel&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;
    &lt;artifactId&gt;opentelemetry-exporter-zipkin&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># Tracing configuration
management.tracing.sampling.probability=1.0
management.zipkin.tracing.endpoint=http://localhost:9411/api/v2/spans
</code></pre>
<ol start="3">
    <li><strong>Centralized Logging with ELK Stack</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;
    &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;
    &lt;version&gt;7.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-xml">&lt;!-- logback-spring.xml --&gt;
&lt;configuration&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;appender name=&quot;LOGSTASH&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;
        &lt;destination&gt;localhost:5000&lt;/destination&gt;
        &lt;encoder class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&gt;
            &lt;includeMdcKeyName&gt;traceId&lt;/includeMdcKeyName&gt;
            &lt;includeMdcKeyName&gt;spanId&lt;/includeMdcKeyName&gt;
            &lt;includeMdcKeyName&gt;userId&lt;/includeMdcKeyName&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;root level=&quot;INFO&quot;&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;
        &lt;appender-ref ref=&quot;LOGSTASH&quot; /&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<ol start="4">
    <li><strong>Health checks with Actuator</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    private final DataSource dataSource;

    @Override
    public Health health() {
        try (Connection conn = dataSource.getConnection()) {
            try (Statement stmt = conn.createStatement()) {
                stmt.execute(&quot;SELECT 1&quot;);
                return Health.up()
                    .withDetail(&quot;database&quot;, &quot;Available&quot;)
                    .build();
            }
        } catch (Exception e) {
            return Health.down()
                .withDetail(&quot;database&quot;, &quot;Unavailable&quot;)
                .withException(e)
                .build();
        }
    }
}
</code></pre>
<pre><code class="language-properties"># Health check configuration
management.endpoint.health.show-details=always
management.endpoint.health.show-components=always
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
</code></pre>
<ol start="5">
    <li><strong>Observability Dashboard with Grafana</strong>:</li>
</ol>
<pre><code class="language-yaml"># Docker Compose for observability stack
version: &#39;3&#39;
services:
  prometheus:
    image: prom/prometheus
    ports:
      - &quot;9090:9090&quot;
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

  grafana:
    image: grafana/grafana
    ports:
      - &quot;3000:3000&quot;
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana-storage:/var/lib/grafana
    depends_on:
      - prometheus

  zipkin:
    image: openzipkin/zipkin
    ports:
      - &quot;9411:9411&quot;

volumes:
  grafana-storage:
</code></pre>
<ol start="6">
    <li><strong>Custom actuator endpoints</strong>:</li>
</ol>
<pre><code class="language-java">@Component
@EndpointWebExtension(endpoint = HealthEndpoint.class)
public class DetailedHealthEndpoint implements WebEndpointExtension {
    private final HealthEndpoint delegate;

    @ReadOperation
    public WebEndpointResponse&lt;DetailedHealth&gt; health() {
        Health health = this.delegate.health();
        DetailedHealth detailedHealth = new DetailedHealth(health);

        // Add additional system metrics
        detailedHealth.setDiskSpace(getDiskSpaceInfo());
        detailedHealth.setMemory(getMemoryInfo());

        return new WebEndpointResponse&lt;&gt;(detailedHealth,
                                      getStatus(health.getStatus()));
    }

    private int getStatus(Status status) {
        if (Status.UP.equals(status)) {
            return 200;
        }
        return 503;
    }
}
</code></pre>
<h3 id="83-how-do-you-deploy-spring-boot-applications-in-a-containerized-environment">83. How do you deploy Spring Boot applications in a containerized environment?</h3>
<p>Deploying Spring Boot in containers:</p>
<ol>
    <li><strong>Basic Dockerfile</strong>:</li>
</ol>
<pre><code class="language-dockerfile">FROM openjdk:17-jdk-slim
VOLUME /tmp
COPY target/*.jar app.jar
ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
</code></pre>
<ol start="2">
    <li><strong>Optimized Dockerfile</strong>:</li>
</ol>
<pre><code class="language-dockerfile"># Build stage
FROM maven:3.8-openjdk-17-slim AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

# Run stage
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app/app.jar&quot;]
</code></pre>
<ol start="3">
    <li><strong>Spring Boot Docker Maven plugin</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;build-image&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
        &lt;image&gt;
            &lt;name&gt;myorg/myapp:${project.version}&lt;/name&gt;
            &lt;env&gt;
                &lt;BP_JVM_VERSION&gt;17&lt;/BP_JVM_VERSION&gt;
            &lt;/env&gt;
        &lt;/image&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<ol start="4">
    <li><strong>Docker Compose for microservices</strong>:</li>
</ol>
<pre><code class="language-yaml">version: &#39;3&#39;
services:
  config-server:
    build: ./config-server
    ports:
      - &quot;8888:8888&quot;
    environment:
      - SPRING_PROFILES_ACTIVE=docker

  discovery-server:
    build: ./discovery-server
    ports:
      - &quot;8761:8761&quot;
    depends_on:
      - config-server
    environment:
      - SPRING_PROFILES_ACTIVE=docker

  gateway:
    build: ./gateway
    ports:
      - &quot;8080:8080&quot;
    depends_on:
      - config-server
      - discovery-server
    environment:
      - SPRING_PROFILES_ACTIVE=docker

  user-service:
    build: ./user-service
    depends_on:
      - config-server
      - discovery-server
      - mysql
    environment:
      - SPRING_PROFILES_ACTIVE=docker

  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=rootpw
      - MYSQL_DATABASE=userdb
    ports:
      - &quot;3306:3306&quot;
    volumes:
      - mysql-data:/var/lib/mysql

volumes:
  mysql-data:
</code></pre>
<ol start="5">
    <li><strong>Kubernetes deployment</strong>:</li>
</ol>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myorg/myapp:1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: &quot;production&quot;
        - name: SPRING_DATASOURCE_URL
          valueFrom:
            configMapKeyRef:
              name: myapp-config
              key: database-url
        - name: SPRING_DATASOURCE_USERNAME
          valueFrom:
            secretKeyRef:
              name: myapp-secrets
              key: database-username
        - name: SPRING_DATASOURCE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: myapp-secrets
              key: database-password
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 20
        resources:
          limits:
            cpu: &quot;1&quot;
            memory: &quot;1Gi&quot;
          requests:
            cpu: &quot;500m&quot;
            memory: &quot;512Mi&quot;
---
apiVersion: v1
kind: Service
metadata:
  name: myapp
spec:
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
</code></pre>
<ol start="6">
    <li><strong>Helm chart for Spring Boot</strong>:</li>
</ol>
<pre><code class="language-yaml"># values.yaml
replicaCount: 3
image:
  repository: myorg/myapp
  tag: 1.0.0
  pullPolicy: IfNotPresent
service:
  type: ClusterIP
  port: 80
env:
  - name: SPRING_PROFILES_ACTIVE
    value: &quot;production&quot;
configMap:
  create: true
  data:
    database-url: jdbc:mysql://mysql:3306/myapp
secret:
  create: true
  data:
    database-username: dXNlcm5hbWU=  # base64 encoded
    database-password: cGFzc3dvcmQ=  # base64 encoded
</code></pre>
<ol start="7">
    <li><strong>Spring Boot Layered JAR</strong> for smaller images:</li>
</ol>
<pre><code># Enable layered JAR
bootJar {
    layered {
        enabled = true
    }
}
</code></pre>
<pre><code class="language-dockerfile">FROM eclipse-temurin:17-jre-alpine as builder
WORKDIR /app
COPY target/*.jar app.jar
RUN java -Djarmode=layertools -jar app.jar extract

FROM eclipse-temurin:17-jre-alpine
WORKDIR /app
COPY --from=builder /app/dependencies/ ./
COPY --from=builder /app/spring-boot-loader/ ./
COPY --from=builder /app/snapshot-dependencies/ ./
COPY --from=builder /app/application/ ./
ENTRYPOINT [&quot;java&quot;, &quot;org.springframework.boot.loader.JarLauncher&quot;]
</code></pre>
<ol start="8">
    <li><strong>GraalVM Native Image</strong> for faster startup:</li>
</ol>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;
    &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;imageName&gt;myapp&lt;/imageName&gt;
        &lt;mainClass&gt;com.example.Application&lt;/mainClass&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<pre><code class="language-dockerfile">FROM ghcr.io/graalvm/native-image:ol8-java17 AS builder
WORKDIR /app
COPY target/myapp .

FROM gcr.io/distroless/base
COPY --from=builder /app/myapp /app/myapp
ENTRYPOINT [&quot;/app/myapp&quot;]
</code></pre>
<h3 id="84-what-are-the-best-practices-for-securing-a-spring-boot-application-in-production">84. What are the best practices for securing a Spring Boot application in production?</h3>
<p>Production security best practices:</p>
<ol>
    <li><strong>Use HTTPS everywhere</strong>:</li>
</ol>
<pre><code class="language-properties"># Enable HTTPS
server.ssl.key-store=classpath:keystore.p12
server.ssl.key-store-password=password
server.ssl.key-store-type=PKCS12
server.ssl.key-alias=tomcat
server.ssl.enabled=true
</code></pre>
<ol start="2">
    <li><strong>Secure HTTP headers</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // Other security config...
            .headers(headers -&gt; headers
                .frameOptions().deny()
                .xssProtection().block(true)
                .contentSecurityPolicy(&quot;script-src &#39;self&#39;&quot;)
                .and()
                .referrerPolicy(ReferrerPolicy.SAME_ORIGIN)
            );

        return http.build();
    }
}
</code></pre>
<ol start="3">
    <li><strong>CSRF protection</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -&gt; csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            );

        return http.build();
    }
}
</code></pre>
<ol start="4">
    <li><strong>Strong password encoding</strong>:</li>
</ol>
<pre><code class="language-java">@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(12);
}
</code></pre>
<ol start="5">
    <li><strong>Rate limiting</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class RateLimitingFilter extends OncePerRequestFilter {
    private final Bucket bucket;

    public RateLimitingFilter() {
        Bandwidth limit = Bandwidth.classic(100, Refill.greedy(100, Duration.ofMinutes(1)));
        this.bucket = Bucket.builder().addLimit(limit).build();
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        if (bucket.tryConsume(1)) {
            filterChain.doFilter(request, response);
        } else {
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            response.getWriter().append(&quot;Too many requests&quot;);
        }
    }
}
</code></pre>
<ol start="6">
    <li><strong>Secure JWT implementation</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class JwtTokenProvider {
    @Value(&quot;${jwt.secret}&quot;)
    private String jwtSecret;

    @Value(&quot;${jwt.expiration}&quot;)
    private int jwtExpiration;

    public String generateToken(Authentication authentication) {
        UserDetails userPrincipal = (UserDetails) authentication.getPrincipal();

        return Jwts.builder()
            .setSubject(userPrincipal.getUsername())
            .setIssuedAt(new Date())
            .setExpiration(new Date(new Date().getTime() + jwtExpiration))
            .signWith(Keys.hmacShaKeyFor(jwtSecret.getBytes()), SignatureAlgorithm.HS512)
            .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(Keys.hmacShaKeyFor(jwtSecret.getBytes()))
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
</code></pre>
<ol start="7">
    <li><strong>Database security</strong>:</li>
</ol>
<pre><code class="language-properties"># Encrypt sensitive properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb?useSSL=true&amp;requireSSL=true
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}

# Use environment variables or encrypted values
spring.datasource.hikari.data-source-properties.trustServerCertificate=true
spring.jpa.properties.hibernate.connection_provider_disables_autocommit=true
</code></pre>
<ol start="8">
    <li><strong>Production-ready actuator security</strong>:</li>
</ol>
<pre><code class="language-properties"># Disable sensitive endpoints or secure them
management.endpoints.web.exposure.include=health,info
management.endpoint.health.show-details=when_authorized
management.endpoint.health.roles=ADMIN
management.endpoints.web.base-path=/management
</code></pre>
<pre><code class="language-java">@Configuration
public class ActuatorSecurityConfig {
    @Bean
    public SecurityFilterChain actuatorFilterChain(HttpSecurity http) throws Exception {
        http
            .securityMatcher(&quot;/management/**&quot;)
            .authorizeHttpRequests(auth -&gt; {
                auth.requestMatchers(&quot;/management/health&quot;).permitAll();
                auth.requestMatchers(&quot;/management/info&quot;).permitAll();
                auth.requestMatchers(&quot;/management/**&quot;).hasRole(&quot;ADMIN&quot;);
            })
            .httpBasic(Customizer.withDefaults());

        return http.build();
    }
}
</code></pre>
<ol start="9">
    <li><strong>Secrets management</strong>:</li>
</ol>
<pre><code class="language-yaml"># Using Kubernetes Secrets
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
data:
  db-password: cGFzc3dvcmQ=
  jwt-secret: c2VjcmV0a2V5
</code></pre>
<ol start="10">
    <li><strong>Security Headers Filter</strong>:</li>
</ol>
<pre><code class="language-java">@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class SecurityHeadersFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        response.setHeader(&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;);
        response.setHeader(&quot;X-Frame-Options&quot;, &quot;DENY&quot;);
        response.setHeader(&quot;X-XSS-Protection&quot;, &quot;1; mode=block&quot;);
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache, no-store, max-age=0, must-revalidate&quot;);
        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);
        response.setHeader(&quot;Expires&quot;, &quot;0&quot;);

        filterChain.doFilter(request, response);
    }
}
</code></pre>
<h3 id="85-what-is-spring-native-and-graalvm-native-image-support-in-spring-boot">85. What is Spring Native and GraalVM Native Image support in Spring Boot?</h3>
<p>Spring Native and GraalVM provide faster startup and lower memory usage:</p>
<ol>
    <li><strong>Basic Setup</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;
            &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;classesDirectory&gt;${project.build.outputDirectory}&lt;/classesDirectory&gt;
                &lt;metadataRepository&gt;
                    &lt;enabled&gt;true&lt;/enabled&gt;
                &lt;/metadataRepository&gt;
                &lt;requiredVersion&gt;22.3&lt;/requiredVersion&gt;
            &lt;/configuration&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;build-native&lt;/id&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;compile-no-fork&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;classifier&gt;exec&lt;/classifier&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<ol start="2">
    <li><strong>Build and run native image</strong>:</li>
</ol>
<pre><code class="language-bash"># Build native image
./mvnw -Pnative native:compile

# Run native application
./target/myapp
</code></pre>
<ol start="3">
    <li><strong>Reflection configuration</strong> for classes not detected:</li>
</ol>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;com.example.model.User&quot;,
    &quot;allDeclaredConstructors&quot;: true,
    &quot;allPublicConstructors&quot;: true,
    &quot;allDeclaredMethods&quot;: true,
    &quot;allPublicMethods&quot;: true,
    &quot;allDeclaredFields&quot;: true,
    &quot;allPublicFields&quot;: true
  }
]
</code></pre>
<ol start="4">
    <li><strong>Docker build for native image</strong>:</li>
</ol>
<pre><code class="language-dockerfile">FROM ghcr.io/graalvm/native-image:ol8-java17 as builder
WORKDIR /build
COPY . /build
RUN ./mvnw -Pnative native:compile

FROM oraclelinux:8-slim
WORKDIR /app
COPY --from=builder /build/target/myapp /app/myapp
EXPOSE 8080
ENTRYPOINT [&quot;/app/myapp&quot;]
</code></pre>
<ol start="5">
    <li><strong>Spring Boot Docker Maven plugin for native</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;image&gt;
            &lt;builder&gt;paketobuildpacks/builder:tiny&lt;/builder&gt;
            &lt;env&gt;
                &lt;BP_NATIVE_IMAGE&gt;true&lt;/BP_NATIVE_IMAGE&gt;
            &lt;/env&gt;
        &lt;/image&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<ol start="6">
    <li><strong>Handling native image limitations</strong>:</li>
</ol>
<pre><code class="language-java">// Use @RegisterReflectionForBinding for Jackson serialization
@RegisterReflectionForBinding({User.class, Order.class})
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

// Use RuntimeHints for resources
@Configuration
public class MyRuntimeHints implements RuntimeHintsRegistrar {
    @Override
    public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
        hints.resources().registerPattern(&quot;data/*.json&quot;);
        hints.serialization().registerType(MyDto.class);
        hints.reflection().registerType(
            MyService.class,
            MemberCategory.INVOKE_DECLARED_METHODS
        );
    }
}
</code></pre>
<ol start="7">
    <li><strong>Testing native applications</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootTest
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class NativeApplicationTests {
    @Test
    @Order(1)
    void contextLoads() {
        // Basic test that context loads
    }

    @Test
    @Order(2)
    void testEndpoint() {
        // Test application functionality
    }
}
</code></pre>
<ol start="8">
    <li><strong>Troubleshooting native image issues</strong>:</li>
</ol>
<pre><code class="language-bash"># Build with verbose output
native-image -H:+PrintAnalysisCallTree -H:+ReportExceptionStackTraces

# Track initialization
-H:+TraceClassInitialization

# Enable agent for tracing
java -agentlib:native-image-agent=config-output-dir=src/main/resources/META-INF/native-image -jar target/myapp.jar
</code></pre>
<h3 id="86-what-is-spring-boots-support-for-graceful-shutdown">86. What is Spring Boot&#39;s support for graceful shutdown?</h3>
<p>Spring Boot provides graceful shutdown mechanisms:</p>
<ol>
    <li><strong>Basic configuration</strong>:</li>
</ol>
<pre><code class="language-properties"># Enable graceful shutdown
server.shutdown=graceful

# Maximum grace period
spring.lifecycle.timeout-per-shutdown-phase=20s
</code></pre>
<ol start="2">
    <li><strong>Custom graceful shutdown</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class GracefulShutdownConfig {
    private final ApplicationContext applicationContext;

    @EventListener(ContextClosedEvent.class)
    public void onContextClosed() {
        // Perform custom cleanup before shutdown
        log.info(&quot;Context is closing. Starting graceful shutdown...&quot;);
    }

    @PreDestroy
    public void onDestroy() {
        // Additional cleanup resources
        log.info(&quot;Application is shutting down...&quot;);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Custom shutdown hooks for resources</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class TaskService {
    private final ExecutorService executorService;

    public TaskService() {
        this.executorService = Executors.newFixedThreadPool(10);
    }

    @PreDestroy
    public void cleanup() {
        log.info(&quot;Shutting down executor service&quot;);

        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(30, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
</code></pre>
<ol start="4">
    <li><strong>Kubernetes graceful shutdown</strong>:</li>
</ol>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  template:
    spec:
      containers:
      - name: myapp
        image: myorg/myapp:1.0.0
        lifecycle:
          preStop:
            exec:
              command: [&quot;sh&quot;, &quot;-c&quot;, &quot;sleep 10&quot;]
        terminationGracePeriodSeconds: 30
</code></pre>
<ol start="5">
    <li><strong>Shutdown hooks for connection pools</strong>:</li>
</ol>
<pre><code class="language-java">@Bean
public DataSource dataSource() {
    HikariConfig config = new HikariConfig();
    config.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/mydb&quot;);
    config.setUsername(&quot;user&quot;);
    config.setPassword(&quot;password&quot;);
    // Add shutdown hook
    config.setRegisterMbeans(true);
    return new HikariDataSource(config);
}

@PreDestroy
public void closeDataSource() {
    if (dataSource instanceof HikariDataSource) {
        ((HikariDataSource) dataSource).close();
    }
}
</code></pre>
<ol start="6">
    <li><strong>WebFlux graceful shutdown</strong>:</li>
</ol>
<pre><code class="language-properties"># WebFlux graceful shutdown settings
spring.lifecycle.timeout-per-shutdown-phase=30s
</code></pre>
<pre><code class="language-java">@Bean
public NettyServerCustomizer nettyServerCustomizer() {
    return server -&gt; server.lifecycleTimeout(Duration.ofSeconds(30));
}
</code></pre>
<h3 id="87-how-do-you-integrate-spring-boot-with-event-driven-architecture">87. How do you integrate Spring Boot with event-driven architecture?</h3>
<p>Spring Boot offers multiple ways to implement event-driven patterns:</p>
<ol>
    <li><strong>Spring Application Events</strong>:</li>
</ol>
<pre><code class="language-java">// Custom event
public class OrderCreatedEvent extends ApplicationEvent {
    private final Order order;

    public OrderCreatedEvent(Object source, Order order) {
        super(source);
        this.order = order;
    }

    public Order getOrder() {
        return order;
    }
}

// Publisher
@Service
public class OrderService {
    private final ApplicationEventPublisher eventPublisher;

    public OrderService(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    public Order createOrder(Order order) {
        // Save order
        Order saved = orderRepository.save(order);

        // Publish event
        eventPublisher.publishEvent(new OrderCreatedEvent(this, saved));

        return saved;
    }
}

// Listener
@Component
public class OrderEventListener {
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        Order order = event.getOrder();
        // Process the order
    }

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleOrderCreatedAfterCommit(OrderCreatedEvent event) {
        // Only processed after transaction commits
    }
}
</code></pre>
<ol start="2">
    <li><strong>Spring Cloud Stream</strong> with Kafka:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-stream&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-stream-binder-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">interface OrderStreams {
    String INPUT = &quot;order-input&quot;;
    String OUTPUT = &quot;order-output&quot;;

    @Input(INPUT)
    SubscribableChannel input();

    @Output(OUTPUT)
    MessageChannel output();
}

@EnableBinding(OrderStreams.class)
@Service
public class OrderService {
    private final OrderStreams orderStreams;

    public void publishOrder(Order order) {
        MessageChannel messageChannel = orderStreams.output();
        messageChannel.send(MessageBuilder
            .withPayload(order)
            .setHeader(MessageHeaders.CONTENT_TYPE, MimeTypeUtils.APPLICATION_JSON)
            .build());
    }
}

@Service
public class OrderProcessor {
    @StreamListener(OrderStreams.INPUT)
    public void handleOrder(Order order) {
        // Process incoming order
    }
}
</code></pre>
<pre><code class="language-yaml">spring:
  cloud:
    stream:
      kafka:
        binder:
          brokers: localhost:9092
      bindings:
        order-output:
          destination: orders
          content-type: application/json
        order-input:
          destination: orders
          content-type: application/json
          group: order-group
</code></pre>
<ol start="3">
    <li><strong>Spring AMQP</strong> with RabbitMQ:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean
    public Queue ordersQueue() {
        return new Queue(&quot;orders&quot;, true);
    }

    @Bean
    public DirectExchange orderExchange() {
        return new DirectExchange(&quot;order-exchange&quot;);
    }

    @Bean
    public Binding binding(Queue ordersQueue, DirectExchange orderExchange) {
        return BindingBuilder.bind(ordersQueue)
                .to(orderExchange)
                .with(&quot;order.created&quot;);
    }

    @Bean
    public MessageConverter jsonMessageConverter() {
        return new Jackson2JsonMessageConverter();
    }
}

@Service
public class OrderService {
    private final RabbitTemplate rabbitTemplate;
    private final DirectExchange orderExchange;

    public void publishOrder(Order order) {
        rabbitTemplate.convertAndSend(
            orderExchange.getName(),
            &quot;order.created&quot;,
            order
        );
    }
}

@Component
public class OrderListener {
    @RabbitListener(queues = &quot;orders&quot;)
    public void receiveOrder(Order order) {
        // Process order
    }
}
</code></pre>
<ol start="4">
    <li><strong>Spring Integration</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-integration&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableIntegration
public class IntegrationConfig {
    @Bean
    public MessageChannel orderChannel() {
        return new DirectChannel();
    }

    @Bean
    public MessageChannel processedOrderChannel() {
        return new DirectChannel();
    }

    @Bean
    public IntegrationFlow orderFlow() {
        return IntegrationFlows.from(&quot;orderChannel&quot;)
                .filter(Order.class, order -&gt; order.getAmount().compareTo(BigDecimal.ZERO) &gt; 0)
                .transform(Order.class, this::enrichOrder)
                .handle(this::processOrder)
                .channel(&quot;processedOrderChannel&quot;)
                .get();
    }

    private Order enrichOrder(Order order) {
        order.setProcessedTime(LocalDateTime.now());
        return order;
    }

    private void processOrder(Order order) {
        // Processing logic
    }

    @ServiceActivator(inputChannel = &quot;processedOrderChannel&quot;)
    public void handleProcessedOrder(Order processedOrder) {
        // Handle processed order
    }
}

@Component
public class OrderGateway {
    @Autowired
    private MessageChannel orderChannel;

    public void sendOrder(Order order) {
        orderChannel.send(MessageBuilder.withPayload(order).build());
    }
}
</code></pre>
<ol start="5">
    <li><strong>WebSockets</strong> for bidirectional event streaming:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker(&quot;/topic&quot;);
        registry.setApplicationDestinationPrefixes(&quot;/app&quot;);
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint(&quot;/ws&quot;).withSockJS();
    }
}

@Controller
public class OrderController {
    private final SimpMessagingTemplate messagingTemplate;

    @MessageMapping(&quot;/orders.create&quot;)
    @SendTo(&quot;/topic/orders&quot;)
    public OrderUpdate createOrder(Order order) {
        // Process order
        return new OrderUpdate(order.getId(), &quot;CREATED&quot;);
    }

    // Send updates from services
    public void notifyOrderUpdated(Order order) {
        messagingTemplate.convertAndSend(
            &quot;/topic/orders.&quot; + order.getId(),
            new OrderUpdate(order.getId(), order.getStatus())
        );
    }
}
</code></pre>
<h3 id="88-what-are-the-ways-to-extend-spring-boot-auto-configuration">88. What are the ways to extend Spring Boot auto-configuration?</h3>
<p>Extending auto-configuration:</p>
<ol>
    <li><strong>Custom Starter</strong>: Create your own starter module</li>
</ol>
<pre><code class="language-xml">&lt;!-- Starter module POM --&gt;
&lt;project&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;example-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.example&lt;/groupId&gt;
            &lt;artifactId&gt;example-spring-boot-autoconfigure&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;

&lt;!-- Autoconfigure module POM --&gt;
&lt;project&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;example-spring-boot-autoconfigure&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ol start="2">
    <li><strong>Auto-configuration class</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@ConditionalOnClass(ExampleService.class)
@EnableConfigurationProperties(ExampleProperties.class)
public class ExampleAutoConfiguration {

    private final ExampleProperties properties;

    public ExampleAutoConfiguration(ExampleProperties properties) {
        this.properties = properties;
    }

    @Bean
    @ConditionalOnMissingBean
    public ExampleService exampleService() {
        return new ExampleService(properties.getPrefix(), properties.getSuffix());
    }
}
</code></pre>
<ol start="3">
    <li><strong>Configuration properties</strong>:</li>
</ol>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;example&quot;)
public class ExampleProperties {
    /**
     * Prefix to add to messages.
     */
    private String prefix = &quot;Hello&quot;;

    /**
     * Suffix to add to messages.
     */
    private String suffix = &quot;!&quot;;

    // Getters and setters
}
</code></pre>
<ol start="4">
    <li><strong>Register auto-configuration</strong>:</li>
</ol>
<pre><code># META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.ExampleAutoConfiguration
</code></pre>
<p>For Spring Boot 2.7+ / 3.x:</p>
<pre><code># META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
com.example.ExampleAutoConfiguration
</code></pre>
<ol start="5">
    <li><strong>Custom condition annotations</strong>:</li>
</ol>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnCustomCondition.class)
public @interface ConditionalOnCustomCriteria {
    String value() default &quot;&quot;;
}

public class OnCustomCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        Map&lt;String, Object&gt; attributes = metadata.getAnnotationAttributes(
            ConditionalOnCustomCriteria.class.getName());

        String value = (String) attributes.get(&quot;value&quot;);

        // Evaluate condition logic
        return checkCondition(value, context.getEnvironment());
    }
}
</code></pre>
<ol start="6">
    <li><strong>Ordering auto-configurations</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@AutoConfigureAfter(DataSourceAutoConfiguration.class)
@AutoConfigureBefore(WebMvcAutoConfiguration.class)
public class ExampleAutoConfiguration {
    // Configuration beans
}
</code></pre>
<ol start="7">
    <li><strong>Customizing existing auto-configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class CustomWebServerFactoryConfiguration {
    @Bean
    public WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; tomcatCustomizer() {
        return (factory) -&gt; {
            factory.addContextCustomizers((context) -&gt; {
                // Customize Tomcat context
            });
            factory.addConnectorCustomizers((connector) -&gt; {
                // Customize Tomcat connector
            });
        };
    }
}
</code></pre>
<ol start="8">
    <li><strong>Replacing auto-configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableConfigurationProperties(ServerProperties.class)
public class CustomServerConfiguration {
    private final ServerProperties serverProperties;

    public CustomServerConfiguration(ServerProperties serverProperties) {
        this.serverProperties = serverProperties;
    }

    @Bean
    @ConditionalOnMissingBean
    public TomcatServletWebServerFactory servletWebServerFactory() {
        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
        // Custom configuration
        return factory;
    }
}
</code></pre>
<h3 id="89-whats-new-in-spring-boot-3x-compared-to-2x">89. What&#39;s new in Spring Boot 3.x compared to 2.x?</h3>
<p>Key changes in Spring Boot 3.x:</p>
<ol>
    <li><strong>Java 17+ requirement</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;!-- Minimum Java version --&gt;
&lt;java.version&gt;17&lt;/java.version&gt;
</code></pre>
<ol start="2">
    <li><strong>Jakarta EE 9+ instead of Java EE</strong>:</li>
</ol>
<pre><code class="language-java">// Spring Boot 2.x
import javax.servlet.http.HttpServletRequest;
import javax.persistence.Entity;

// Spring Boot 3.x
import jakarta.servlet.http.HttpServletRequest;
import jakarta.persistence.Entity;
</code></pre>
<ol start="3">
    <li><strong>Native support improvements</strong>:</li>
</ol>
<pre><code class="language-java">// Improved runtime hints registration
@Configuration
@ImportRuntimeHints(MyRuntimeHints.class)
public class AppConfig {
    // Configuration
}

class MyRuntimeHints implements RuntimeHintsRegistrar {
    @Override
    public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
        hints.reflection().registerType(MyClass.class, MemberCategory.INVOKE_PUBLIC_METHODS);
        hints.resources().registerPattern(&quot;static/images/*&quot;);
        hints.serialization().registerType(MyDTO.class);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Micrometer observation API</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
public class ProductController {
    private final ObservationRegistry observationRegistry;

    @GetMapping(&quot;/products/{id}&quot;)
    public Product getProduct(@PathVariable Long id) {
        return Observation.createNotStarted(&quot;getProduct&quot;, observationRegistry)
            .contextualName(&quot;get-product&quot;)
            .lowCardinalityKeyValue(&quot;productId&quot;, id.toString())
            .observe(() -&gt; {
                // Method implementation
                return productService.findById(id);
            });
    }
}
</code></pre>
<ol start="5">
    <li><strong>HTTP Interface Client</strong>:</li>
</ol>
<pre><code class="language-java">// Define interface
@HttpExchange(&quot;/api/users&quot;)
public interface UserClient {
    @GetExchange(&quot;/{id}&quot;)
    User getUser(@PathVariable Long id);

    @PostExchange
    User createUser(@RequestBody User user);
}

// Create and use client
@Configuration
public class ClientConfig {
    @Bean
    public UserClient userClient(WebClient.Builder builder) {
        return HttpServiceProxyFactory
            .builder(WebClientAdapter.forClient(
                builder.baseUrl(&quot;https://api.example.com&quot;).build()))
            .build()
            .createClient(UserClient.class);
    }
}
</code></pre>
<ol start="6">
    <li><strong>Problem Details for HTTP APIs (RFC 7807)</strong>:</li>
</ol>
<pre><code class="language-java">@ControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(ProductNotFoundException.class)
    ProblemDetail handleProductNotFoundException(ProductNotFoundException e) {
        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(
                HttpStatus.NOT_FOUND, e.getMessage());

        problemDetail.setTitle(&quot;Product Not Found&quot;);
        problemDetail.setType(URI.create(&quot;https://api.example.com/errors/not-found&quot;));
        problemDetail.setProperty(&quot;timestamp&quot;, new Date());

        return problemDetail;
    }
}
</code></pre>
<ol start="7">
    <li><strong>Actuator improvements</strong>:</li>
</ol>
<pre><code class="language-properties"># Health groups
management.endpoint.health.group.readiness.include=db,redis
management.endpoint.health.group.liveness.include=ping

# Metrics with Prometheus exemplars
management.prometheus.metrics.export.enabled=true
</code></pre>
<ol start="8">
    <li><strong>Controller parameter validation</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/users&quot;)
@Validated
public class UserController {

    @PostMapping
    public User createUser(@Valid @RequestBody User user) {
        return userService.save(user);
    }

    @GetMapping
    public List&lt;User&gt; getUsers(
            @RequestParam(defaultValue = &quot;0&quot;) @Min(0) int page,
            @RequestParam(defaultValue = &quot;10&quot;) @Min(1) @Max(100) int size) {
        return userService.findAll(PageRequest.of(page, size));
    }
}
</code></pre>
<ol start="9">
    <li><strong>Virtual threads support</strong>:</li>
</ol>
<pre><code class="language-properties"># Enable virtual threads (Spring Boot 3.2+)
spring.threads.virtual.enabled=true
</code></pre>
<pre><code class="language-java">@Bean
public AsyncTaskExecutor applicationTaskExecutor() {
    SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor();
    executor.setVirtualThreads(true);
    return executor;
}
</code></pre>
<ol start="10">
    <li><strong>Docker Compose Support</strong>:</li>
</ol>
<pre><code class="language-properties"># Automatic Docker Compose integration (3.1+)
spring.docker.compose.enabled=true
spring.docker.compose.file=./compose.yaml
spring.docker.compose.lifecycle-management=start_only
</code></pre>
<h3 id="90-how-do-you-handle-application-startup-failure-in-spring-boot">90. How do you handle application startup failure in Spring Boot?</h3>
<p>Handling startup failures:</p>
<ol>
    <li><strong>FailureAnalyzer for custom errors</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ConnectionFailureAnalyzer implements FailureAnalyzer {
    @Override
    public FailureAnalysis analyze(Throwable failure) {
        if (failure instanceof ConnectionException) {
            ConnectionException ex = (ConnectionException) failure;

            return new FailureAnalysis(
                &quot;Database connection failed: &quot; + ex.getMessage(),
                &quot;Verify that the database is running and credentials are correct. &quot; +
                &quot;Check connection URL: &quot; + ex.getConnectionUrl(),
                ex);
        }
        return null;
    }
}
</code></pre>
<ol start="2">
    <li><strong>Register custom FailureAnalyzer</strong>:</li>
</ol>
<pre><code># META-INF/spring.factories
org.springframework.boot.diagnostics.FailureAnalyzer=\
com.example.ConnectionFailureAnalyzer
</code></pre>
<p>For Spring Boot 3.x:</p>
<pre><code># META-INF/spring/org.springframework.boot.diagnostics.FailureAnalyzer.imports
com.example.ConnectionFailureAnalyzer
</code></pre>
<ol start="3">
    <li><strong>ApplicationRunner/CommandLineRunner for validation</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class DatabaseConnectionValidator implements ApplicationRunner {
    private final DataSource dataSource;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        try (Connection conn = dataSource.getConnection()) {
            // Execute a simple query to verify connectivity
            try (Statement stmt = conn.createStatement()) {
                stmt.execute(&quot;SELECT 1&quot;);
            }
        } catch (SQLException e) {
            throw new ConnectionException(&quot;Database validation failed&quot;, e);
        }
    }
}
</code></pre>
<ol start="4">
    <li><strong>Custom exceptions during startup</strong>:</li>
</ol>
<pre><code class="language-java">public class ApplicationStartupException extends RuntimeException {
    public ApplicationStartupException(String message) {
        super(message);
    }

    public ApplicationStartupException(String message, Throwable cause) {
        super(message, cause);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Custom banner on failure</strong>:</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        try {
            SpringApplication app = new SpringApplication(Application.class);
            app.setBannerMode(Banner.Mode.CONSOLE);
            app.run(args);
        } catch (Exception e) {
            System.err.println(&quot;Application failed to start!&quot;);
            e.printStackTrace();
            System.exit(1);
        }
    }
}
</code></pre>
<ol start="6">
    <li><strong>ApplicationContextInitializer for setup validation</strong>:</li>
</ol>
<pre><code class="language-java">public class ValidationInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {
    @Override
    public void initialize(ConfigurableApplicationContext context) {
        ConfigurableEnvironment environment = context.getEnvironment();

        // Check required properties
        String requiredProperty = environment.getProperty(&quot;app.required-setting&quot;);
        if (requiredProperty == null) {
            throw new ApplicationContextException(
                &quot;Required property &#39;app.required-setting&#39; is missing!&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-java">@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(Application.class);
        app.addInitializers(new ValidationInitializer());
        app.run(args);
    }
}
</code></pre>
<ol start="7">
    <li><strong>Handling BindException for configuration errors</strong>:</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        try {
            SpringApplication.run(Application.class, args);
        } catch (Exception e) {
            if (e instanceof BindException ||
                (e.getCause() != null &amp;&amp; e.getCause() instanceof BindException)) {

                System.err.println(&quot;Configuration error: invalid property values&quot;);
                BindException bindException = (BindException)
                    (e instanceof BindException ? e : e.getCause());

                bindException.getBindingResult().getFieldErrors().forEach(error -&gt; {
                    System.err.println(&quot;Field &#39;&quot; + error.getField() + &quot;&#39;: &quot; +
                                     error.getDefaultMessage());
                });
            }
            System.exit(1);
        }
    }
}
</code></pre>
<ol start="8">
    <li><strong>Using ApplicationFailedEvent</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class FailureListener {
    private static final Logger logger = LoggerFactory.getLogger(FailureListener.class);

    @EventListener
    public void handleApplicationFailedEvent(ApplicationFailedEvent event) {
        Throwable exception = event.getException();
        logger.error(&quot;Application failed to start&quot;, exception);

        // Send notification
        NotificationService.sendStartupFailureAlert(exception);

        // Additional handling
        System.exit(1);
    }
}
</code></pre>
<ol start="9">
    <li><strong>Fallback configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class DatabaseConfig {
    @Bean
    @Primary
    public DataSource dataSource(Environment env) {
        try {
            return primaryDataSource(env);
        } catch (Exception e) {
            logger.warn(&quot;Failed to configure primary database, using in-memory database&quot;);
            return inMemoryDataSource();
        }
    }

    private DataSource primaryDataSource(Environment env) {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(env.getRequiredProperty(&quot;spring.datasource.url&quot;));
        config.setUsername(env.getRequiredProperty(&quot;spring.datasource.username&quot;));
        config.setPassword(env.getRequiredProperty(&quot;spring.datasource.password&quot;));
        return new HikariDataSource(config);
    }

    private DataSource inMemoryDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .addScript(&quot;classpath:schema-h2.sql&quot;)
            .build();
    }
}
</code></pre>
<ol start="10">
    <li><strong>Health check during startup</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class StartupHealthCheckService {
    private final List&lt;HealthChecker&gt; healthCheckers;

    @PostConstruct
    public void verifySystemHealth() {
        List&lt;HealthCheckResult&gt; results = healthCheckers.stream()
            .map(HealthChecker::checkHealth)
            .filter(result -&gt; !result.isHealthy())
            .collect(Collectors.toList());

        if (!results.isEmpty()) {
            StringBuilder message = new StringBuilder(&quot;System health check failed:&quot;);
            results.forEach(result -&gt; message.append(&quot;\n- &quot;)
                                           .append(result.getMessage()));
            throw new ApplicationStartupException(message.toString());
        }
    }

    public interface HealthChecker {
        HealthCheckResult checkHealth();
    }

    public static class HealthCheckResult {
        private final boolean healthy;
        private final String message;

        // Constructor, getters, etc.
    }
}
</code></pre>
<h2 id="advanced-features-and-best-practices">Advanced Features and Best Practices</h2>
<h3 id="91-how-do-you-implement-health-checks-for-external-systems-in-spring-boot">91. How do you implement health checks for external systems in Spring Boot?</h3>
<p>Health checks for external systems:</p>
<ol>
    <li><strong>Custom HealthIndicator implementation</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ExternalApiHealthIndicator implements HealthIndicator {
    private final RestTemplate restTemplate;
    private final String apiUrl;

    public ExternalApiHealthIndicator(RestTemplate restTemplate,
                                    @Value(&quot;${external.api.url}&quot;) String apiUrl) {
        this.restTemplate = restTemplate;
        this.apiUrl = apiUrl;
    }

    @Override
    public Health health() {
        try {
            ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(
                apiUrl + &quot;/health&quot;, String.class);

            if (response.getStatusCode().is2xxSuccessful()) {
                return Health.up()
                    .withDetail(&quot;statusCode&quot;, response.getStatusCodeValue())
                    .build();
            } else {
                return Health.down()
                    .withDetail(&quot;statusCode&quot;, response.getStatusCodeValue())
                    .withDetail(&quot;reason&quot;, &quot;API responded with error status&quot;)
                    .build();
            }
        } catch (Exception e) {
            return Health.down()
                .withDetail(&quot;error&quot;, e.getMessage())
                .build();
        }
    }
}
</code></pre>
<ol start="2">
    <li><strong>Database health check</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    private final DataSource dataSource;

    @Override
    public Health health() {
        try (Connection conn = dataSource.getConnection()) {
            try (Statement stmt = conn.createStatement()) {
                stmt.execute(&quot;SELECT 1&quot;);

                Map&lt;String, Object&gt; details = new HashMap&lt;&gt;();
                DatabaseMetaData metadata = conn.getMetaData();
                details.put(&quot;database&quot;, metadata.getDatabaseProductName());
                details.put(&quot;version&quot;, metadata.getDatabaseProductVersion());

                return Health.up().withDetails(details).build();
            }
        } catch (Exception e) {
            return Health.down()
                .withDetail(&quot;error&quot;, e.getMessage())
                .build();
        }
    }
}
</code></pre>
<ol start="3">
    <li><strong>Redis health check</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class RedisHealthIndicator implements HealthIndicator {
    private final StringRedisTemplate redisTemplate;

    @Override
    public Health health() {
        try {
            String key = &quot;health:check:&quot; + UUID.randomUUID();
            String value = UUID.randomUUID().toString();

            redisTemplate.opsForValue().set(key, value, Duration.ofSeconds(1));
            String retrieved = redisTemplate.opsForValue().get(key);

            if (value.equals(retrieved)) {
                return Health.up()
                    .withDetail(&quot;version&quot;, getRedisVersion())
                    .build();
            } else {
                return Health.down()
                    .withDetail(&quot;error&quot;, &quot;Value mismatch in read-write test&quot;)
                    .build();
            }
        } catch (Exception e) {
            return Health.down()
                .withDetail(&quot;error&quot;, e.getMessage())
                .build();
        }
    }

    private String getRedisVersion() {
        return redisTemplate.execute((RedisCallback&lt;String&gt;) connection -&gt;
            connection.serverCommands().info(&quot;server&quot;).getString(&quot;redis_version&quot;));
    }
}
</code></pre>
<ol start="4">
    <li><strong>Configuration for health checks</strong>:</li>
</ol>
<pre><code class="language-properties"># Enable more detailed health information
management.endpoint.health.show-details=always

# Enable specific health indicators
management.health.defaults.enabled=true
management.health.db.enabled=true
management.health.redis.enabled=true

# Configure timeout for health checks
management.endpoint.health.group.readiness.include=db,redis,externalApi
management.endpoint.health.group.readiness.show-details=always
management.endpoint.health.group.liveness.include=ping
</code></pre>
<ol start="5">
    <li><strong>Composite health indicator</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class MicroservicesHealthIndicator implements CompositeHealthContributor {
    private final Map&lt;String, HealthContributor&gt; contributors;

    public MicroservicesHealthIndicator(RestTemplate restTemplate) {
        contributors = new HashMap&lt;&gt;();
        contributors.put(&quot;userService&quot;, new ServiceHealthIndicator(restTemplate, &quot;http://user-service/health&quot;));
        contributors.put(&quot;orderService&quot;, new ServiceHealthIndicator(restTemplate, &quot;http://order-service/health&quot;));
        contributors.put(&quot;paymentService&quot;, new ServiceHealthIndicator(restTemplate, &quot;http://payment-service/health&quot;));
    }

    @Override
    public HealthContributor getContributor(String name) {
        return contributors.get(name);
    }

    @Override
    public Iterator&lt;NamedContributor&lt;HealthContributor&gt;&gt; iterator() {
        return contributors.entrySet().stream()
                .map(entry -&gt; NamedContributor.of(entry.getKey(), entry.getValue()))
                .iterator();
    }

    static class ServiceHealthIndicator implements HealthIndicator {
        private final RestTemplate restTemplate;
        private final String serviceUrl;

        // Implementation similar to ExternalApiHealthIndicator
    }
}
</code></pre>
<h3 id="92-what-are-the-different-ways-to-deploy-a-spring-boot-application-to-the-cloud">92. What are the different ways to deploy a Spring Boot application to the cloud?</h3>
<p>Cloud deployment options for Spring Boot:</p>
<ol>
    <li><strong>AWS Elastic Beanstalk</strong>:</li>
</ol>
<pre><code class="language-properties"># application-aws.properties
server.port=5000
logging.file.path=/var/log
</code></pre>
<pre><code class="language-xml">&lt;!-- Add AWS SDK dependencies --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.amazonaws&lt;/groupId&gt;
    &lt;artifactId&gt;aws-java-sdk-s3&lt;/artifactId&gt;
    &lt;version&gt;1.12.99&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>AWS Lambda with Spring Cloud Function</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-function-adapter-aws&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
public class ServerlessApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServerlessApplication.class, args);
    }

    @Bean
    public Function&lt;String, String&gt; uppercase() {
        return value -&gt; value.toUpperCase();
    }

    // AWS Lambda handler class
    public class FunctionHandler extends SpringBootRequestHandler&lt;String, String&gt; {
    }
}
</code></pre>
<ol start="3">
    <li><strong>Azure Spring Apps</strong> (formerly Spring Cloud Azure):</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.azure.spring&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-azure-starter&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># Azure configuration
spring.cloud.azure.profile.tenant-id=${AZURE_TENANT_ID}
spring.cloud.azure.profile.subscription-id=${AZURE_SUBSCRIPTION_ID}
</code></pre>
<ol start="4">
    <li><strong>Google Cloud Run</strong>:</li>
</ol>
<pre><code class="language-dockerfile">FROM adoptopenjdk:11-jre-hotspot
WORKDIR /app
COPY target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]
</code></pre>
<pre><code class="language-yaml"># cloudbuild.yaml
steps:
- name: &#39;gcr.io/cloud-builders/mvn&#39;
  args: [&#39;package&#39;, &#39;-DskipTests&#39;]
- name: &#39;gcr.io/cloud-builders/docker&#39;
  args: [&#39;build&#39;, &#39;-t&#39;, &#39;gcr.io/$PROJECT_ID/myapp&#39;, &#39;.&#39;]
- name: &#39;gcr.io/cloud-builders/docker&#39;
  args: [&#39;push&#39;, &#39;gcr.io/$PROJECT_ID/myapp&#39;]
- name: &#39;gcr.io/google.com/cloudsdktool/cloud-sdk&#39;
  entrypoint: gcloud
  args:
  - &#39;run&#39;
  - &#39;deploy&#39;
  - &#39;myapp&#39;
  - &#39;--image&#39;
  - &#39;gcr.io/$PROJECT_ID/myapp&#39;
  - &#39;--platform&#39;
  - &#39;managed&#39;
  - &#39;--region&#39;
  - &#39;us-central1&#39;
  - &#39;--allow-unauthenticated&#39;
</code></pre>
<ol start="5">
    <li><strong>Kubernetes with Spring Boot</strong>:</li>
</ol>
<pre><code class="language-yaml"># deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: spring-boot-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: spring-boot-app
  template:
    metadata:
      labels:
        app: spring-boot-app
    spec:
      containers:
      - name: spring-boot-app
        image: myorg/spring-boot-app:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: &quot;prod&quot;
        - name: DATABASE_URL
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: database-url
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-password
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 20
---
apiVersion: v1
kind: Service
metadata:
  name: spring-boot-app
spec:
  selector:
    app: spring-boot-app
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
</code></pre>
<ol start="6">
    <li><strong>Heroku deployment</strong>:</li>
</ol>
<pre><code># Procfile
web: java -Dserver.port=$PORT -jar target/*.jar
</code></pre>
<pre><code class="language-properties"># application.properties
spring.datasource.url=${JDBC_DATABASE_URL}
spring.datasource.username=${JDBC_DATABASE_USERNAME}
spring.datasource.password=${JDBC_DATABASE_PASSWORD}
</code></pre>
<ol start="7">
    <li><strong>CloudFoundry/Pivotal Cloud Foundry</strong>:</li>
</ol>
<pre><code class="language-yaml"># manifest.yml
applications:
- name: spring-boot-app
  path: target/myapp-0.0.1-SNAPSHOT.jar
  memory: 1G
  instances: 2
  env:
    SPRING_PROFILES_ACTIVE: cloud
    JBP_CONFIG_OPEN_JDK_JRE: &#39;{jre: {version: 11.+}}&#39;
  services:
  - mysql-db-service
</code></pre>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.pivotal.spring.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-services-starter-service-registry&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="8">
    <li><strong>Docker Swarm</strong>:</li>
</ol>
<pre><code class="language-yaml"># docker-compose.yml
version: &#39;3.8&#39;
services:
  app:
    image: myorg/spring-boot-app:latest
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
    ports:
      - &quot;8080:8080&quot;
    environment:
      - SPRING_PROFILES_ACTIVE=prod
    networks:
      - app-network

networks:
  app-network:
</code></pre>
<h3 id="93-what-is-spring-boots-autoconfiguration-logging-and-how-can-you-troubleshoot-it">93. What is Spring Boot&#39;s autoconfiguration logging and how can you troubleshoot it?</h3>
<p>Spring Boot autoconfiguration logging and troubleshooting:</p>
<ol>
    <li><strong>Enable debug mode</strong> to see auto-configuration report:</li>
</ol>
<pre><code class="language-properties"># In application.properties
debug=true
</code></pre>
<ol start="2">
    <li><strong>Output shows</strong> positive and negative matches:</li>
</ol>
<pre><code>=========================
AUTO-CONFIGURATION REPORT
=========================

Positive matches:
-----------------
   DataSourceAutoConfiguration matched:
      - @ConditionalOnClass found required classes &#39;javax.sql.DataSource&#39;, &#39;org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType&#39; (OnClassCondition)
      - @ConditionalOnMissingBean (types: javax.sql.DataSource; SearchStrategy: all) did not find any beans (OnBeanCondition)

Negative matches:
-----------------
   MongoDataAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class &#39;com.mongodb.client.MongoClient&#39; (OnClassCondition)
</code></pre>
<ol start="3">
    <li><strong>Examine specific auto-configuration</strong> conditions:</li>
</ol>
<pre><code class="language-java">@Configuration
@ConditionalOnClass(DataSource.class)
@ConditionalOnMissingBean(DataSource.class)
@EnableConfigurationProperties(DataSourceProperties.class)
public class DataSourceAutoConfiguration {
    // Auto-configuration code
}
</code></pre>
<ol start="4">
    <li><strong>Check condition evaluation details</strong> with actuator:</li>
</ol>
<pre><code class="language-properties">management.endpoints.web.exposure.include=conditions
</code></pre>
<p>Access <code>/actuator/conditions</code> for detailed report.</p>
<ol start="5">
    <li><strong>Customize logging levels</strong> for deeper inspection:</li>
</ol>
<pre><code class="language-properties"># Log all condition evaluations
logging.level.org.springframework.boot.autoconfigure.condition=DEBUG

# Log specific auto-configuration packages
logging.level.org.springframework.boot.autoconfigure.security=TRACE
</code></pre>
<ol start="6">
    <li><strong>Debug specific failure</strong>:</li>
</ol>
<pre><code class="language-properties"># Focus on data source issues
logging.level.org.springframework.boot.autoconfigure.jdbc=TRACE
logging.level.com.zaxxer.hikari=DEBUG
</code></pre>
<ol start="7">
    <li><strong>Trace bean creation</strong> for specific beans:</li>
</ol>
<pre><code class="language-properties">logging.level.org.springframework.beans.factory.support.DefaultListableBeanFactory=TRACE
</code></pre>
<ol start="8">
    <li><strong>Exclude problematic auto-configurations</strong>:</li>
</ol>
<pre><code class="language-java">@SpringBootApplication(exclude = {
    DataSourceAutoConfiguration.class,
    SecurityAutoConfiguration.class
})
public class Application {
    // Main class
}
</code></pre>
<ol start="9">
    <li><strong>Force a specific auto-configuration</strong> to apply:</li>
</ol>
<pre><code class="language-java">@Configuration
@AutoConfigureBefore(JpaRepositoriesAutoConfiguration.class)
public class CustomDataSourceConfig {
    @Bean
    public DataSource customDataSource() {
        // Custom data source that should be picked up before JPA auto-config runs
        return new CustomDataSource();
    }
}
</code></pre>
<ol start="10">
    <li><strong>Understand auto-configuration order</strong>:</li>
</ol>
<pre><code class="language-bash"># Run application with this parameter
java -jar myapp.jar --debug
</code></pre>
<h3 id="94-how-do-you-implement-custom-application-events-in-spring-boot">94. How do you implement custom application events in Spring Boot?</h3>
<p>Custom application events implementation:</p>
<ol>
    <li><strong>Define custom event class</strong>:</li>
</ol>
<pre><code class="language-java">public class OrderCreatedEvent extends ApplicationEvent {
    private final Order order;

    public OrderCreatedEvent(Object source, Order order) {
        super(source);
        this.order = order;
    }

    public Order getOrder() {
        return order;
    }
}

public class OrderCanceledEvent extends ApplicationEvent {
    private final Order order;
    private final String reason;

    public OrderCanceledEvent(Object source, Order order, String reason) {
        super(source);
        this.order = order;
        this.reason = reason;
    }

    public Order getOrder() {
        return order;
    }

    public String getReason() {
        return reason;
    }
}
</code></pre>
<ol start="2">
    <li><strong>Publish events</strong> from services:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderService {
    private final ApplicationEventPublisher eventPublisher;
    private final OrderRepository orderRepository;

    public OrderService(ApplicationEventPublisher eventPublisher, OrderRepository orderRepository) {
        this.eventPublisher = eventPublisher;
        this.orderRepository = orderRepository;
    }

    @Transactional
    public Order createOrder(Order order) {
        // Save order
        Order savedOrder = orderRepository.save(order);

        // Publish event after order is created
        eventPublisher.publishEvent(new OrderCreatedEvent(this, savedOrder));

        return savedOrder;
    }

    @Transactional
    public Order cancelOrder(Long id, String reason) {
        Order order = orderRepository.findById(id)
            .orElseThrow(() -&gt; new OrderNotFoundException(id));

        order.setStatus(&quot;CANCELED&quot;);
        Order savedOrder = orderRepository.save(order);

        // Publish cancellation event
        eventPublisher.publishEvent(new OrderCanceledEvent(this, savedOrder, reason));

        return savedOrder;
    }
}
</code></pre>
<ol start="3">
    <li><strong>Create event listeners</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class OrderEventListener {
    private final Logger logger = LoggerFactory.getLogger(OrderEventListener.class);

    @EventListener
    public void handleOrderCreatedEvent(OrderCreatedEvent event) {
        Order order = event.getOrder();
        logger.info(&quot;Order created: {}&quot;, order.getId());

        // Process the order creation
        sendOrderConfirmationEmail(order);
    }

    @EventListener
    public void handleOrderCanceledEvent(OrderCanceledEvent event) {
        Order order = event.getOrder();
        String reason = event.getReason();

        logger.info(&quot;Order canceled: {}, reason: {}&quot;, order.getId(), reason);

        // Process the cancellation
        sendCancellationNotification(order, reason);
    }

    private void sendOrderConfirmationEmail(Order order) {
        // Email sending logic
    }

    private void sendCancellationNotification(Order order, String reason) {
        // Notification logic
    }
}
</code></pre>
<ol start="4">
    <li><strong>Asynchronous event processing</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableAsync
public class AsyncConfig {
    @Bean
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix(&quot;Event-&quot;);
        return executor;
    }
}

@Component
public class AsyncOrderEventListener {
    @Async
    @EventListener
    public void handleOrderCreatedEvent(OrderCreatedEvent event) {
        // This will be processed in a separate thread
        // Long-running operations like sending emails, etc.
    }
}
</code></pre>
<ol start="5">
    <li><strong>Ordering event listeners</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class OrderedEventListeners {
    @EventListener
    @Order(1)
    public void logOrderCreation(OrderCreatedEvent event) {
        // This listener runs first
    }

    @EventListener
    @Order(2)
    public void notifyInventory(OrderCreatedEvent event) {
        // This listener runs second
    }

    @EventListener
    @Order(3)
    public void notifyShipping(OrderCreatedEvent event) {
        // This listener runs third
    }
}
</code></pre>
<ol start="6">
    <li><strong>Transactional event listener</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class TransactionalOrderEventListener {
    private final Logger logger = LoggerFactory.getLogger(TransactionalOrderEventListener.class);

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleOrderCreatedAfterCommit(OrderCreatedEvent event) {
        // This is executed only after the transaction that published the event commits
        logger.info(&quot;Order {} confirmed after transaction commit&quot;, event.getOrder().getId());
    }

    @TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)
    public void handleOrderCanceledBeforeCommit(OrderCanceledEvent event) {
        // This is executed before the transaction commits
        logger.info(&quot;Order {} cancellation processing before commit&quot;, event.getOrder().getId());
    }

    @TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)
    public void handleOrderEventAfterRollback(ApplicationEvent event) {
        // This is executed if the transaction rolls back
        logger.warn(&quot;Transaction rolled back for event: {}&quot;, event);
    }
}
</code></pre>
<ol start="7">
    <li><strong>Conditional event processing</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ConditionalEventListener {
    @EventListener(condition = &quot;#event.order.amount &gt; 1000&quot;)
    public void handleLargeOrder(OrderCreatedEvent event) {
        // Only process orders with amount &gt; 1000
    }

    @EventListener(condition = &quot;#event.reason == &#39;CUSTOMER_REQUEST&#39;&quot;)
    public void handleCustomerInitiatedCancellation(OrderCanceledEvent event) {
        // Only process customer-initiated cancellations
    }
}
</code></pre>
<h3 id="95-how-do-you-implement-database-auditing-in-spring-boot">95. How do you implement database auditing in Spring Boot?</h3>
<p>Database auditing implementation:</p>
<ol>
    <li><strong>Enable JPA auditing</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableJpaAuditing
public class AuditConfig {
    @Bean
    public AuditorAware&lt;String&gt; auditorProvider() {
        return () -&gt; Optional.ofNullable(SecurityContextHolder.getContext())
            .map(SecurityContext::getAuthentication)
            .filter(Authentication::isAuthenticated)
            .map(Authentication::getName)
            .or(() -&gt; Optional.of(&quot;system&quot;));
    }
}
</code></pre>
<ol start="2">
    <li><strong>Create audit entity base class</strong>:</li>
</ol>
<pre><code class="language-java">@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class Auditable {
    @CreatedDate
    @Column(name = &quot;created_date&quot;, nullable = false, updatable = false)
    private LocalDateTime createdDate;

    @LastModifiedDate
    @Column(name = &quot;last_modified_date&quot;)
    private LocalDateTime lastModifiedDate;

    @CreatedBy
    @Column(name = &quot;created_by&quot;, nullable = false, updatable = false)
    private String createdBy;

    @LastModifiedBy
    @Column(name = &quot;last_modified_by&quot;)
    private String lastModifiedBy;

    // Getters and setters
}
</code></pre>
<ol start="3">
    <li><strong>Use the auditable base class</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Table(name = &quot;products&quot;)
public class Product extends Auditable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private BigDecimal price;

    // Other fields, getters, and setters
}
</code></pre>
<ol start="4">
    <li><strong>Custom revision entity</strong> with Hibernate Envers:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-envers&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableJpaRepositories(repositoryFactoryBeanClass = EnversRevisionRepositoryFactoryBean.class)
@EnableJpaAuditing
public class EnversConfig {
    // Configuration
}

@Entity
@RevisionEntity(CustomRevisionListener.class)
public class CustomRevisionEntity {
    @Id
    @GeneratedValue
    @RevisionNumber
    private int id;

    @RevisionTimestamp
    private long timestamp;

    @Column(name = &quot;modified_by&quot;)
    private String modifiedBy;

    // Getters and setters
}

public class CustomRevisionListener implements RevisionListener {
    @Override
    public void newRevision(Object revisionEntity) {
        CustomRevisionEntity revision = (CustomRevisionEntity) revisionEntity;

        String currentUser = Optional.ofNullable(SecurityContextHolder.getContext().getAuthentication())
            .map(Authentication::getName)
            .orElse(&quot;system&quot;);

        revision.setModifiedBy(currentUser);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Audited entity with Envers</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Audited
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    @NotAudited
    private String notes; // This field won&#39;t be audited

    // Getters and setters
}
</code></pre>
<ol start="6">
    <li><strong>Repository for history access</strong>:</li>
</ol>
<pre><code class="language-java">public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt;, RevisionRepository&lt;Customer, Long, Integer&gt; {
    // Standard repository methods plus revision methods
}

// Usage
@Service
public class CustomerService {
    private final CustomerRepository customerRepository;

    public List&lt;Revision&lt;Integer, Customer&gt;&gt; getCustomerHistory(Long id) {
        return customerRepository.findRevisions(id).getContent();
    }

    public Customer getCustomerAtRevision(Long id, int revisionNumber) {
        return customerRepository.findRevision(id, revisionNumber)
            .orElseThrow(() -&gt; new RevisionNotFoundException(id, revisionNumber));
    }
}
</code></pre>
<ol start="7">
    <li><strong>Custom audit trail implementation</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Table(name = &quot;audit_log&quot;)
public class AuditLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String entityType;

    @Column(nullable = false)
    private Long entityId;

    @Column(nullable = false)
    private String action;

    @Column(nullable = false)
    private String username;

    @Column(nullable = false)
    private LocalDateTime timestamp;

    @Column(columnDefinition = &quot;TEXT&quot;)
    private String details;

    // Getters and setters
}

@Component
public class AuditAspect {
    private final AuditLogRepository auditLogRepository;

    @Pointcut(&quot;@annotation(com.example.audit.Audited)&quot;)
    public void auditedMethod() {}

    @AfterReturning(pointcut = &quot;auditedMethod() &amp;&amp; @annotation(audited)&quot;, returning = &quot;result&quot;)
    public void audit(JoinPoint joinPoint, Audited audited, Object result) {
        // Extract method information
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();

        // Create audit log
        AuditLog log = new AuditLog();
        log.setEntityType(audited.entity());
        log.setEntityId(extractEntityId(args, result));
        log.setAction(audited.action());
        log.setUsername(getCurrentUsername());
        log.setTimestamp(LocalDateTime.now());
        log.setDetails(createAuditDetails(methodName, args, result));

        auditLogRepository.save(log);
    }

    // Helper methods...
}
</code></pre>
<h3 id="96-how-can-you-implement-rate-limiting-in-spring-boot-applications">96. How can you implement rate limiting in Spring Boot applications?</h3>
<p>Rate limiting implementation approaches:</p>
<ol>
    <li><strong>Simple in-memory implementation</strong> with Bucket4j:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.vladimir-bukhtoyarov&lt;/groupId&gt;
    &lt;artifactId&gt;bucket4j-core&lt;/artifactId&gt;
    &lt;version&gt;7.6.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Component
public class RateLimitingFilter extends OncePerRequestFilter {
    // Create 10 requests per minute rate limit
    private final Bucket bucket = Bucket.builder()
        .addLimit(Bandwidth.classic(10, Refill.greedy(10, Duration.ofMinutes(1))))
        .build();

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        if (bucket.tryConsume(1)) {
            // Allow the request to proceed
            filterChain.doFilter(request, response);
        } else {
            // Reject with 429 Too Many Requests
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);
            response.getWriter().write(&quot;{\&quot;message\&quot;:\&quot;Rate limit exceeded. Try again later.\&quot;}&quot;);
        }
    }
}
</code></pre>
<ol start="2">
    <li><strong>Per-user rate limiting</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class UserBasedRateLimitingFilter extends OncePerRequestFilter {
    private final Map&lt;String, Bucket&gt; bucketCache = new ConcurrentHashMap&lt;&gt;();

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        // Get user identifier (API key, username, IP address)
        String userId = getUserIdentifier(request);

        // Get or create bucket for this user
        Bucket bucket = bucketCache.computeIfAbsent(userId, k -&gt; createBucket());

        if (bucket.tryConsume(1)) {
            filterChain.doFilter(request, response);
        } else {
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            response.getWriter().write(&quot;Too many requests&quot;);
        }
    }

    private String getUserIdentifier(HttpServletRequest request) {
        // Use API key from header if present
        String apiKey = request.getHeader(&quot;X-API-Key&quot;);
        if (apiKey != null) {
            return apiKey;
        }

        // Fall back to authenticated user
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null &amp;&amp; auth.isAuthenticated()) {
            return auth.getName();
        }

        // Fall back to IP address
        return request.getRemoteAddr();
    }

    private Bucket createBucket() {
        return Bucket.builder()
            .addLimit(Bandwidth.classic(20, Refill.intervally(20, Duration.ofMinutes(1))))
            .build();
    }
}
</code></pre>
<ol start="3">
    <li><strong>Redis-based distributed rate limiting</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Component
public class RedisRateLimiter {
    private final StringRedisTemplate redisTemplate;

    public boolean tryAcquire(String key, int maxRequests, int windowSeconds) {
        String redisKey = &quot;rate:limiter:&quot; + key;

        long currentTime = System.currentTimeMillis() / 1000;
        long windowStart = currentTime - windowSeconds;

        // Transaction to ensure atomicity
        List&lt;Object&gt; results = redisTemplate.execute(new SessionCallback&lt;List&lt;Object&gt;&gt;() {
            @Override
            @SuppressWarnings(&quot;unchecked&quot;)
            public List&lt;Object&gt; execute(RedisOperations operations) throws DataAccessException {
                operations.multi();

                // Clean up old requests outside the current window
                operations.opsForZSet().removeRangeByScore(redisKey, 0, windowStart);

                // Count requests in current window
                operations.opsForZSet().count(redisKey, windowStart, currentTime);

                // Add current request
                operations.opsForZSet().add(redisKey, UUID.randomUUID().toString(), currentTime);

                // Set expiration on the key
                operations.expire(redisKey, windowSeconds * 2, TimeUnit.SECONDS);

                return operations.exec();
            }
        });

        Long requestsInWindow = (Long) results.get(1);

        return requestsInWindow &lt; maxRequests;
    }
}

@RestController
@RequestMapping(&quot;/api&quot;)
public class ApiController {
    private final RedisRateLimiter rateLimiter;

    @GetMapping(&quot;/resource&quot;)
    public ResponseEntity&lt;?&gt; getResource(HttpServletRequest request) {
        String identifier = request.getRemoteAddr();

        if (!rateLimiter.tryAcquire(identifier, 10, 60)) {
            return ResponseEntity
                .status(HttpStatus.TOO_MANY_REQUESTS)
                .body(&quot;Rate limit exceeded&quot;);
        }

        // Normal processing
        return ResponseEntity.ok(&quot;Resource data&quot;);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Spring Cloud Gateway with rate limiting</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class GatewayConfig {
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            .route(&quot;auth_service_route&quot;, r -&gt; r.path(&quot;/auth/**&quot;)
                .filters(f -&gt; f.requestRateLimiter(c -&gt; c
                    .setRateLimiter(redisRateLimiter())
                    .setKeyResolver(ipKeyResolver())))
                .uri(&quot;lb://AUTH-SERVICE&quot;))
            .route(&quot;product_service_route&quot;, r -&gt; r.path(&quot;/products/**&quot;)
                .filters(f -&gt; f.requestRateLimiter(c -&gt; c
                    .setRateLimiter(redisRateLimiter())
                    .setKeyResolver(userKeyResolver())))
                .uri(&quot;lb://PRODUCT-SERVICE&quot;))
            .build();
    }

    @Bean
    public RedisRateLimiter redisRateLimiter() {
        return new RedisRateLimiter(10, 20);  // replenishRate, burstCapacity
    }

    @Bean(name = &quot;ipKeyResolver&quot;)
    public KeyResolver ipKeyResolver() {
        return exchange -&gt; Mono.just(
            exchange.getRequest().getRemoteAddress().getAddress().getHostAddress()
        );
    }

    @Bean(name = &quot;userKeyResolver&quot;)
    public KeyResolver userKeyResolver() {
        return exchange -&gt; Mono.justOrEmpty(
            exchange.getRequest().getHeaders().getFirst(&quot;X-User-Id&quot;)
        ).defaultIfEmpty(&quot;anonymous&quot;);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Resilience4j rate limiter</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt;
    &lt;artifactId&gt;resilience4j-spring-boot2&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api&quot;)
public class ApiController {
    private final RateLimiterRegistry rateLimiterRegistry;
    private final RateLimiter rateLimiter;

    public ApiController(RateLimiterRegistry rateLimiterRegistry) {
        this.rateLimiterRegistry = rateLimiterRegistry;
        this.rateLimiter = rateLimiterRegistry.rateLimiter(&quot;apiRateLimiter&quot;);
    }

    @GetMapping(&quot;/data&quot;)
    public ResponseEntity&lt;String&gt; getData() {
        return rateLimiter.executeSupplier(() -&gt; {
            // Actual processing...
            return ResponseEntity.ok(&quot;Response data&quot;);
        });
    }

    @RateLimiter(name = &quot;paymentRateLimiter&quot;)
    @PostMapping(&quot;/payments&quot;)
    public ResponseEntity&lt;String&gt; processPayment(@RequestBody PaymentRequest request) {
        // Rate limited by annotation
        return ResponseEntity.ok(&quot;Payment processed&quot;);
    }
}
</code></pre>
<pre><code class="language-properties"># Configure rate limiters
resilience4j.ratelimiter.instances.apiRateLimiter.limitForPeriod=10
resilience4j.ratelimiter.instances.apiRateLimiter.limitRefreshPeriod=1s
resilience4j.ratelimiter.instances.apiRateLimiter.timeoutDuration=0

resilience4j.ratelimiter.instances.paymentRateLimiter.limitForPeriod=3
resilience4j.ratelimiter.instances.paymentRateLimiter.limitRefreshPeriod=1m
</code></pre>
<h3 id="97-how-do-you-implement-custom-annotations-in-spring-boot">97. How do you implement custom annotations in Spring Boot?</h3>
<p>Custom annotations implementation:</p>
<ol>
    <li><strong>Simple custom annotation</strong>:</li>
</ol>
<pre><code class="language-java">@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface LogExecutionTime {
}

@Aspect
@Component
public class LogExecutionTimeAspect {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    @Around(&quot;@annotation(com.example.annotation.LogExecutionTime)&quot;)
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();

        Object result = joinPoint.proceed();

        long executionTime = System.currentTimeMillis() - start;

        logger.info(&quot;{} executed in {} ms&quot;, joinPoint.getSignature(), executionTime);

        return result;
    }
}

@RestController
public class DemoController {
    @LogExecutionTime
    @GetMapping(&quot;/slow-operation&quot;)
    public String slowOperation() throws InterruptedException {
        Thread.sleep(1000); // Simulate slow operation
        return &quot;Operation completed&quot;;
    }
}
</code></pre>
<ol start="2">
    <li><strong>Validation annotation</strong>:</li>
</ol>
<pre><code class="language-java">@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = ValidProductIdValidator.class)
@Documented
public @interface ValidProductId {
    String message() default &quot;Invalid product ID format&quot;;
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}

public class ValidProductIdValidator implements ConstraintValidator&lt;ValidProductId, String&gt; {
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true; // Let @NotNull handle null validation
        }

        // Check if it matches pattern: PRD-12345
        return value.matches(&quot;PRD-\\d{5}&quot;);
    }
}

public class ProductRequest {
    @NotNull
    @ValidProductId
    private String productId;

    // Other fields, getters, setters
}
</code></pre>
<ol start="3">
    <li><strong>Security annotation</strong>:</li>
</ol>
<pre><code class="language-java">@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize(&quot;hasPermission(#id, &#39;PRODUCT&#39;, &#39;EDIT&#39;)&quot;)
@Documented
public @interface CanEditProduct {
}

@Component
public class ProductPermissionEvaluator implements PermissionEvaluator {
    private final ProductRepository productRepository;

    @Override
    public boolean hasPermission(Authentication auth, Object targetId, Object permission) {
        if (auth == null || targetId == null || !(targetId instanceof Long)) {
            return false;
        }

        Long productId = (Long) targetId;
        String action = (String) permission;

        // Check if user can edit product
        return checkPermission(auth, productId, action);
    }

    // Other implementations
}

@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @CanEditProduct
    @PutMapping(&quot;/{id}&quot;)
    public Product updateProduct(@PathVariable Long id, @RequestBody Product product) {
        // Method will only execute if user has EDIT permission for the product
        return productService.update(id, product);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Transaction annotation with custom properties</strong>:</li>
</ol>
<pre><code class="language-java">@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Transactional
@Documented
public @interface ReadOnlyTransaction {
}

@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Transactional(rollbackFor = Exception.class)
@Documented
public @interface WriteTransaction {
}

@Service
public class ProductService {
    @ReadOnlyTransaction
    public List&lt;Product&gt; findAll() {
        // Read-only transaction
    }

    @WriteTransaction
    public Product save(Product product) {
        // Transaction with rollback for any exception
    }
}
</code></pre>
<ol start="5">
    <li><strong>Custom conditional annotation</strong>:</li>
</ol>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Conditional(OnCustomPropertyCondition.class)
@Documented
public @interface ConditionalOnCustomProperty {
    String property();
    String value();
}

public class OnCustomPropertyCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        Map&lt;String, Object&gt; attributes = metadata.getAnnotationAttributes(
            ConditionalOnCustomProperty.class.getName());

        String propertyName = (String) attributes.get(&quot;property&quot;);
        String expectedValue = (String) attributes.get(&quot;value&quot;);
        String actualValue = context.getEnvironment().getProperty(propertyName);

        return expectedValue.equals(actualValue);
    }
}

@Configuration
public class AppConfig {
    @Bean
    @ConditionalOnCustomProperty(property = &quot;app.feature.premium&quot;, value = &quot;enabled&quot;)
    public PremiumFeatureService premiumFeatureService() {
        return new PremiumFeatureService();
    }
}
</code></pre>
<ol start="6">
    <li><strong>Repeatable annotation</strong>:</li>
</ol>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(Audited.List.class)
public @interface Audited {
    String value();

    @Target(ElementType.METHOD)
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    @interface List {
        Audited[] value();
    }
}

@Component
@Aspect
public class AuditAspect {
    @Around(&quot;@annotation(audited)&quot;)
    public Object audit(ProceedingJoinPoint joinPoint, Audited audited) throws Throwable {
        // Log before execution
        log.info(&quot;Executing {} with audit type: {}&quot;,
            joinPoint.getSignature().getName(), audited.value());

        Object result = joinPoint.proceed();

        // Log after execution
        log.info(&quot;Finished {} with audit type: {}&quot;,
            joinPoint.getSignature().getName(), audited.value());

        return result;
    }
}

@Service
public class OrderService {
    @Audited(&quot;BUSINESS&quot;)
    @Audited(&quot;SECURITY&quot;)
    public Order processOrder(Order order) {
        // Processing logic
    }
}
</code></pre>
<ol start="7">
    <li><strong>Meta-annotation</strong> (annotation composition):</li>
</ol>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Cacheable(cacheNames = &quot;products&quot;)
@Transactional(readOnly = true)
public @interface ReadFromCache {
}

@RestController
public class ProductController {
    @ReadFromCache
    @GetMapping(&quot;/products/{id}&quot;)
    public Product getProduct(@PathVariable Long id) {
        // This method will use cache and run in read-only transaction
        return productService.findById(id);
    }
}
</code></pre>
<h3 id="98-how-do-you-implement-a-custom-spring-boot-starter">98. How do you implement a custom Spring Boot starter?</h3>
<p>Custom Spring Boot starter implementation:</p>
<ol>
    <li><strong>Project structure</strong>:</li>
</ol>
<pre><code>custom-spring-boot-starter/
├── pom.xml
└── src/
    └── main/
        ├── java/
        │   └── com/example/starter/
        │       ├── CustomAutoConfiguration.java
        │       ├── CustomService.java
        │       └── CustomProperties.java
        └── resources/
            └── META-INF/
                ├── spring.factories (Spring Boot 2.x)
                └── spring/
                    └── org.springframework.boot.autoconfigure.AutoConfiguration.imports (Spring Boot 3.x)
</code></pre>
<ol start="2">
    <li><strong>POM configuration</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;custom-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;Custom Spring Boot Starter&lt;/name&gt;
    &lt;description&gt;Spring Boot Starter for custom functionality&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
        &lt;spring-boot.version&gt;3.0.0&lt;/spring-boot.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;${spring-boot.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
            &lt;version&gt;${spring-boot.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;version&gt;${spring-boot.version}&lt;/version&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ol start="3">
    <li><strong>Custom properties class</strong>:</li>
</ol>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;custom&quot;)
public class CustomProperties {
    /**
     * Enable the custom feature.
     */
    private boolean enabled = true;

    /**
     * Message prefix to be used.
     */
    private String prefix = &quot;Hello&quot;;

    /**
     * Message suffix to be used.
     */
    private String suffix = &quot;!&quot;;

    // Getters and setters
}
</code></pre>
<ol start="4">
    <li><strong>Service to be auto-configured</strong>:</li>
</ol>
<pre><code class="language-java">public class CustomService {
    private final String prefix;
    private final String suffix;

    public CustomService(String prefix, String suffix) {
        this.prefix = prefix;
        this.suffix = suffix;
    }

    public String formatMessage(String message) {
        return prefix + &quot; &quot; + message + suffix;
    }
}
</code></pre>
<ol start="5">
    <li><strong>Auto-configuration class</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@ConditionalOnClass(CustomService.class)
@EnableConfigurationProperties(CustomProperties.class)
@ConditionalOnProperty(prefix = &quot;custom&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
public class CustomAutoConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public CustomService customService(CustomProperties properties) {
        return new CustomService(properties.getPrefix(), properties.getSuffix());
    }
}
</code></pre>
<ol start="6">
    <li><strong>Register auto-configuration</strong> (Spring Boot 2.x):</li>
</ol>
<pre><code># META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.starter.CustomAutoConfiguration
</code></pre>
<ol start="7">
    <li><strong>Register auto-configuration</strong> (Spring Boot 3.x):</li>
</ol>
<pre><code># META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
com.example.starter.CustomAutoConfiguration
</code></pre>
<ol start="8">
    <li><strong>Build and install</strong>:</li>
</ol>
<pre><code class="language-bash">mvn clean install
</code></pre>
<ol start="9">
    <li><strong>Using the custom starter</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;!-- In consumer application --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;custom-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="10">
    <li><strong>Configure the custom starter</strong>:</li>
</ol>
<pre><code class="language-properties"># application.properties
custom.enabled=true
custom.prefix=Greetings
custom.suffix=!!!
</code></pre>
<ol start="11">
    <li><strong>Use the auto-configured bean</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class GreetingService {
    private final CustomService customService;

    public GreetingService(CustomService customService) {
        this.customService = customService;
    }

    public String greet(String name) {
        return customService.formatMessage(name);
    }
}
</code></pre>
<h3 id="99-how-do-you-handle-multi-tenancy-in-spring-boot-applications">99. How do you handle multi-tenancy in Spring Boot applications?</h3>
<p>Multi-tenancy implementation approaches:</p>
<ol>
    <li><strong>Database per tenant</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class MultiTenantDatabaseConfig {
    @Autowired
    private Environment env;

    @Bean
    public DataSource dataSource() {
        AbstractRoutingDataSource dataSource = new TenantRoutingDataSource();

        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();
        targetDataSources.put(&quot;tenant1&quot;, tenant1DataSource());
        targetDataSources.put(&quot;tenant2&quot;, tenant2DataSource());

        dataSource.setTargetDataSources(targetDataSources);
        dataSource.setDefaultTargetDataSource(tenant1DataSource());

        return dataSource;
    }

    @Bean
    @ConfigurationProperties(prefix = &quot;tenant1.datasource&quot;)
    public DataSource tenant1DataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @ConfigurationProperties(prefix = &quot;tenant2.datasource&quot;)
    public DataSource tenant2DataSource() {
        return DataSourceBuilder.create().build();
    }

    public class TenantRoutingDataSource extends AbstractRoutingDataSource {
        @Override
        protected Object determineCurrentLookupKey() {
            return TenantContext.getCurrentTenant();
        }
    }
}

public class TenantContext {
    private static ThreadLocal&lt;String&gt; currentTenant = new ThreadLocal&lt;&gt;();

    public static void setCurrentTenant(String tenant) {
        currentTenant.set(tenant);
    }

    public static String getCurrentTenant() {
        return currentTenant.get();
    }

    public static void clear() {
        currentTenant.remove();
    }
}

@Component
public class TenantFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        String tenant = request.getHeader(&quot;X-Tenant&quot;);
        if (tenant != null) {
            TenantContext.setCurrentTenant(tenant);
        } else {
            TenantContext.setCurrentTenant(&quot;tenant1&quot;);  // Default tenant
        }

        try {
            filterChain.doFilter(request, response);
        } finally {
            TenantContext.clear();
        }
    }
}
</code></pre>
<ol start="2">
    <li><strong>Schema per tenant</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class MultiTenantSchemaConfig {
    @Bean
    public DataSource dataSource() {
        // Single database connection
        return DataSourceBuilder.create()
            .url(env.getProperty(&quot;spring.datasource.url&quot;))
            .username(env.getProperty(&quot;spring.datasource.username&quot;))
            .password(env.getProperty(&quot;spring.datasource.password&quot;))
            .build();
    }

    @Bean
    public JpaVendorAdapter jpaVendorAdapter() {
        HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();
        adapter.setDatabase(Database.POSTGRESQL);
        adapter.setShowSql(true);
        adapter.setGenerateDdl(true);
        return adapter;
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource());
        em.setPackagesToScan(&quot;com.example.model&quot;);
        em.setJpaVendorAdapter(jpaVendorAdapter());

        Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();
        // The MultiTenantConnectionProvider impl
        properties.put(Environment.MULTI_TENANT, MultiTenancyStrategy.SCHEMA);
        properties.put(Environment.MULTI_TENANT_CONNECTION_PROVIDER, multiTenantConnectionProvider());
        properties.put(Environment.MULTI_TENANT_IDENTIFIER_RESOLVER, currentTenantIdentifierResolver());
        em.setJpaPropertyMap(properties);

        return em;
    }

    @Bean
    public CurrentTenantIdentifierResolver currentTenantIdentifierResolver() {
        return new CurrentTenantIdentifierResolver() {
            @Override
            public String resolveCurrentTenantIdentifier() {
                String tenant = TenantContext.getCurrentTenant();
                return tenant != null ? tenant : &quot;public&quot;;
            }

            @Override
            public boolean validateExistingCurrentSessions() {
                return true;
            }
        };
    }

    @Bean
    public MultiTenantConnectionProvider multiTenantConnectionProvider() {
        return new MultiTenantConnectionProvider() {
            // Implementation that switches schema for each tenant
            @Override
            public Connection getConnection(String tenantIdentifier) throws SQLException {
                Connection connection = getAnyConnection();
                connection.createStatement().execute(&quot;SET SCHEMA &#39;&quot; + tenantIdentifier + &quot;&#39;&quot;);
                return connection;
            }

            // Other required methods...
        };
    }
}
</code></pre>
<ol start="3">
    <li><strong>Discriminator column</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Table(name = &quot;products&quot;)
@FilterDef(name = &quot;tenantFilter&quot;, parameters = @ParamDef(name = &quot;tenantId&quot;, type = &quot;string&quot;))
@Filter(name = &quot;tenantFilter&quot;, condition = &quot;tenant_id = :tenantId&quot;)
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private BigDecimal price;

    @Column(name = &quot;tenant_id&quot;)
    private String tenantId;

    // Getters and setters
}

@Component
public class TenantEntityInterceptor extends EmptyInterceptor {
    @Override
    public boolean onSave(Object entity, Object id, Object[] state,
                        String[] propertyNames, Type[] types) {
        if (entity instanceof TenantAware) {
            for (int i = 0; i &lt; propertyNames.length; i++) {
                if (&quot;tenantId&quot;.equals(propertyNames[i])) {
                    state[i] = TenantContext.getCurrentTenant();
                    return true;
                }
            }
        }
        return false;
    }
}

@Aspect
@Component
public class RepositoryAspect {
    @Around(&quot;execution(* com.example.repository.*.*(..))&quot;)
    public Object aroundRepositoryMethod(ProceedingJoinPoint pjp) throws Throwable {
        Session session = entityManager.unwrap(Session.class);
        session.enableFilter(&quot;tenantFilter&quot;)
            .setParameter(&quot;tenantId&quot;, TenantContext.getCurrentTenant());

        try {
            return pjp.proceed();
        } finally {
            session.disableFilter(&quot;tenantFilter&quot;);
        }
    }
}
</code></pre>
<ol start="4">
    <li><strong>Tenant-specific caching</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableCaching
public class TenantAwareCacheConfig extends CachingConfigurerSupport {
    @Bean
    @Override
    public KeyGenerator keyGenerator() {
        return new TenantAwareKeyGenerator();
    }

    public static class TenantAwareKeyGenerator implements KeyGenerator {
        @Override
        public Object generate(Object target, Method method, Object... params) {
            StringBuilder sb = new StringBuilder();
            sb.append(TenantContext.getCurrentTenant()).append(&quot;:&quot;);
            sb.append(target.getClass().getSimpleName()).append(&quot;:&quot;);
            sb.append(method.getName()).append(&quot;:&quot;);

            for (Object param : params) {
                sb.append(param).append(&quot;:&quot;);
            }

            return sb.toString();
        }
    }
}

@Service
public class ProductService {
    private final ProductRepository productRepository;

    @Cacheable(value = &quot;products&quot;)  // Uses tenant-aware key generator
    public Product getProduct(Long id) {
        return productRepository.findById(id)
            .orElseThrow(() -&gt; new ProductNotFoundException(id));
    }
}
</code></pre>
<ol start="5">
    <li><strong>Dynamic database routing for SaaS</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class DynamicTenantConfig {
    @Autowired
    private TenantRepository tenantRepository;

    @Bean
    public DataSource dataSource() {
        final DynamicTenantAwareRoutingSource dataSource = new DynamicTenantAwareRoutingSource();

        // Configure defaults
        DataSourceBuilder&lt;?&gt; defaultBuilder = DataSourceBuilder.create()
            .url(&quot;jdbc:h2:mem:default&quot;)
            .username(&quot;sa&quot;)
            .password(&quot;&quot;);
        dataSource.setDefaultTargetDataSource(defaultBuilder.build());

        // Load all tenant configurations from database or configuration service
        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();
        tenantRepository.findAll().forEach(tenant -&gt; {
            DataSource tenantDataSource = DataSourceBuilder.create()
                .url(tenant.getJdbcUrl())
                .username(tenant.getUsername())
                .password(tenant.getPassword())
                .build();
            targetDataSources.put(tenant.getId(), tenantDataSource);
        });

        dataSource.setTargetDataSources(targetDataSources);

        return dataSource;
    }

    public class DynamicTenantAwareRoutingSource extends AbstractRoutingDataSource {
        @Override
        protected Object determineCurrentLookupKey() {
            return TenantContext.getCurrentTenant();
        }
    }
}
</code></pre>
<h3 id="100-what-are-the-most-important-best-practices-for-a-production-ready-spring-boot-application">100. What are the most important best practices for a production-ready Spring Boot application?</h3>
<p>Production-ready best practices:</p>
<ol>
    <li><p><strong>Security best practices</strong>:</p>
        <ul>
            <li>Use HTTPS in production</li>
            <li>Implement proper authentication and authorization</li>
            <li>Keep dependencies updated for security patches</li>
            <li>Validate all input data</li>
            <li>Use parameterized queries to prevent SQL injection</li>
            <li>Set appropriate Content Security Policy headers</li>
            <li>Use CSRF protection for forms</li>
            <li>Implement secure password storage with BCrypt or similar</li>
            <li>Apply the principle of least privilege</li>
        </ul>
    </li>
    <li><p><strong>Configuration management</strong>:</p>
        <ul>
            <li>Externalize configuration using environment variables or config server</li>
            <li>Use different profiles for each environment (dev, test, prod)</li>
            <li>Don&#39;t store secrets in code or properties files</li>
            <li>Use a secrets management solution</li>
            <li>Configure proper logging levels</li>
            <li>Use YAML for complex configurations</li>
        </ul>
    </li>
    <li><p><strong>Health monitoring</strong>:</p>
        <ul>
            <li>Configure Spring Boot Actuator for health checks and metrics</li>
            <li>Set up proper health indicators for external systems</li>
            <li>Use distributed tracing for microservices</li>
            <li>Configure JVM memory and GC settings appropriately</li>
            <li>Set up alerting for critical issues</li>
        </ul>
    </li>
    <li><p><strong>Performance optimization</strong>:</p>
        <ul>
            <li>Use connection pooling for databases</li>
            <li>Implement caching where appropriate</li>
            <li>Configure proper timeouts for external services</li>
            <li>Use async processing for long-running tasks</li>
            <li>Optimize JPA/Hibernate usage and queries</li>
            <li>Size thread pools appropriately</li>
        </ul>
    </li>
    <li><p><strong>Resilience and stability</strong>:</p>
        <ul>
            <li>Implement circuit breakers for external dependencies</li>
            <li>Use rate limiting to prevent abuse</li>
            <li>Add retries with exponential backoff for transient failures</li>
            <li>Implement graceful degradation</li>
            <li>Handle partial failures appropriately</li>
            <li>Add proper exception handling and fallbacks</li>
        </ul>
    </li>
    <li><p><strong>Logging and observability</strong>:</p>
        <ul>
            <li>Configure consistent logging format across services</li>
            <li>Include correlation IDs for request tracing</li>
            <li>Use structured logging (JSON) in production</li>
            <li>Set up centralized log aggregation</li>
            <li>Configure appropriate log rotation</li>
            <li>Add relevant context to logs</li>
        </ul>
    </li>
    <li><p><strong>Testing strategy</strong>:</p>
        <ul>
            <li>Implement unit tests with high coverage</li>
            <li>Add integration tests for critical flows</li>
            <li>Set up automated API tests</li>
            <li>Implement performance/load testing</li>
            <li>Include security testing in the pipeline</li>
            <li>Use test containers for integration testing</li>
        </ul>
    </li>
    <li><p><strong>Containerization and deployment</strong>:</p>
        <ul>
            <li>Create optimized Docker images</li>
            <li>Use health checks for container orchestration</li>
            <li>Implement graceful shutdown</li>
            <li>Configure proper resource limits</li>
            <li>Use CI/CD pipelines for automated deployment</li>
            <li>Implement blue-green or canary deployment strategies</li>
        </ul>
    </li>
    <li><p><strong>API design</strong>:</p>
        <ul>
            <li>Implement proper error handling and status codes</li>
            <li>Version your APIs</li>
            <li>Use appropriate content types</li>
            <li>Document APIs with OpenAPI/Swagger</li>
            <li>Implement pagination for large result sets</li>
            <li>Handle partial failures in API responses</li>
        </ul>
    </li>
    <li><p><strong>Database management</strong>:</p>
        <ul>
            <li>Use database migration tools (Flyway/Liquibase)</li>
            <li>Implement proper connection pooling</li>
            <li>Use transactions appropriately</li>
            <li>Optimize database queries</li>
            <li>Consider using read replicas for scaling</li>
            <li>Implement proper indexing strategy</li>
        </ul>
    </li>
</ol>
<h2 id="advanced-concepts-and-integration-patterns">Advanced Concepts and Integration Patterns</h2>
<h3 id="101-how-do-you-implement-batch-processing-in-spring-boot">101. How do you implement batch processing in Spring Boot?</h3>
<p>Spring Batch provides a framework for batch processing:</p>
<ol>
    <li><strong>Basic setup</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-batch&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@EnableBatchProcessing
@SpringBootApplication
public class BatchApplication {
    public static void main(String[] args) {
        SpringApplication.run(BatchApplication.class, args);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Job configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class BatchConfig {
    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public ItemReader&lt;Customer&gt; reader() {
        return new FlatFileItemReaderBuilder&lt;Customer&gt;()
                .name(&quot;customerReader&quot;)
                .resource(new ClassPathResource(&quot;data.csv&quot;))
                .delimited()
                .names(new String[]{&quot;firstName&quot;, &quot;lastName&quot;, &quot;email&quot;})
                .fieldSetMapper(new BeanWrapperFieldSetMapper&lt;&gt;() {{
                    setTargetType(Customer.class);
                }})
                .build();
    }

    @Bean
    public ItemProcessor&lt;Customer, Customer&gt; processor() {
        return customer -&gt; {
            // Transform or filter customer data
            customer.setEmail(customer.getEmail().toLowerCase());
            return customer;
        };
    }

    @Bean
    public ItemWriter&lt;Customer&gt; writer(DataSource dataSource) {
        return new JdbcBatchItemWriterBuilder&lt;Customer&gt;()
                .sql(&quot;INSERT INTO customers (first_name, last_name, email) VALUES (:firstName, :lastName, :email)&quot;)
                .dataSource(dataSource)
                .beanMapped()
                .build();
    }

    @Bean
    public Job importCustomerJob(JobCompletionNotificationListener listener, Step step1) {
        return jobBuilderFactory.get(&quot;importCustomerJob&quot;)
                .incrementer(new RunIdIncrementer())
                .listener(listener)
                .flow(step1)
                .end()
                .build();
    }

    @Bean
    public Step step1(ItemWriter&lt;Customer&gt; writer) {
        return stepBuilderFactory.get(&quot;step1&quot;)
                .&lt;Customer, Customer&gt;chunk(10)
                .reader(reader())
                .processor(processor())
                .writer(writer)
                .build();
    }
}
</code></pre>
<ol start="3">
    <li><strong>Job completion listener</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class JobCompletionNotificationListener extends JobExecutionListenerSupport {
    private final JdbcTemplate jdbcTemplate;

    @Override
    public void afterJob(JobExecution jobExecution) {
        if (jobExecution.getStatus() == BatchStatus.COMPLETED) {
            log.info(&quot;!!! JOB FINISHED !!!&quot;);

            jdbcTemplate.query(&quot;SELECT first_name, last_name, email FROM customers&quot;,
                (rs, row) -&gt; new Customer(
                    rs.getString(1),
                    rs.getString(2),
                    rs.getString(3))
            ).forEach(customer -&gt; log.info(&quot;Found &lt;{{}}&gt; in the database.&quot;, customer));
        }
    }
}
</code></pre>
<ol start="4">
    <li><strong>Running the job</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
public class JobController {
    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private Job importCustomerJob;

    @PostMapping(&quot;/start-job&quot;)
    public ResponseEntity&lt;String&gt; startJob() {
        try {
            JobParameters jobParameters = new JobParametersBuilder()
                    .addLong(&quot;time&quot;, System.currentTimeMillis())
                    .toJobParameters();

            JobExecution jobExecution = jobLauncher.run(importCustomerJob, jobParameters);

            return ResponseEntity.ok(&quot;Job started with ID: &quot; + jobExecution.getId());
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(&quot;Error starting job: &quot; + e.getMessage());
        }
    }
}
</code></pre>
<ol start="5">
    <li><strong>Configuration properties</strong>:</li>
</ol>
<pre><code class="language-properties"># Disable job auto-execution at startup
spring.batch.job.enabled=false

# Initialize schema
spring.batch.jdbc.initialize-schema=always

# Job repository datasource
spring.batch.datasource.url=jdbc:h2:mem:batch
spring.batch.datasource.username=sa
spring.batch.datasource.password=
</code></pre>
<h3 id="102-how-do-you-implement-a-refresh-token-mechanism-with-oauth2-in-spring-boot">102. How do you implement a refresh token mechanism with OAuth2 in Spring Boot?</h3>
<p>Implementing refresh token flow with OAuth2:</p>
<ol>
    <li><strong>Dependencies</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Authorization server configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableAuthorizationServer
public class AuthServerConfig extends AuthorizationServerConfigurerAdapter {
    @Autowired
    private AuthenticationManager authenticationManager;

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
            .withClient(&quot;client-id&quot;)
            .secret(&quot;{noop}client-secret&quot;)
            .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;)
            .scopes(&quot;read&quot;, &quot;write&quot;)
            .accessTokenValiditySeconds(3600)        // 1 hour
            .refreshTokenValiditySeconds(2592000);   // 30 days
    }

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {
        endpoints
            .authenticationManager(authenticationManager)
            .userDetailsService(userDetailsService)
            // Store tokens in database
            .tokenStore(tokenStore());
    }

    @Bean
    public TokenStore tokenStore() {
        return new JdbcTokenStore(dataSource);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Token controller</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/token&quot;)
public class TokenController {
    @Autowired
    private TokenEndpoint tokenEndpoint;

    @PostMapping(&quot;/refresh&quot;)
    public ResponseEntity&lt;OAuth2AccessToken&gt; refresh(
            @RequestParam(&quot;refresh_token&quot;) String refreshToken) {

        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder
                .getRequestAttributes()).getRequest();

        Map&lt;String, String&gt; parameters = new HashMap&lt;&gt;();
        parameters.put(&quot;grant_type&quot;, &quot;refresh_token&quot;);
        parameters.put(&quot;refresh_token&quot;, refreshToken);

        OAuth2AccessToken token = tokenEndpoint.getTokenGranter()
                .grant(&quot;refresh_token&quot;, new TokenRequest(parameters, &quot;client-id&quot;,
                        Arrays.asList(&quot;read&quot;, &quot;write&quot;), &quot;refresh_token&quot;));

        return ResponseEntity.ok(token);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Security configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeRequests()
                .antMatchers(&quot;/api/token/**&quot;).permitAll()
                .anyRequest().authenticated()
            .and()
            .oauth2ResourceServer()
                .jwt();
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
}
</code></pre>
<ol start="5">
    <li><strong>Client implementation</strong>:</li>
</ol>
<pre><code class="language-javascript">// Example React client code using axios
const refreshAccessToken = async () =&gt; {
    try {
        const response = await axios.post(&#39;/api/token/refresh&#39;, null, {
            params: {
                refresh_token: localStorage.getItem(&#39;refreshToken&#39;)
            }
        });

        localStorage.setItem(&#39;accessToken&#39;, response.data.access_token);

        // Optional: Update refresh token if a new one was provided
        if (response.data.refresh_token) {
            localStorage.setItem(&#39;refreshToken&#39;, response.data.refresh_token);
        }

        return response.data.access_token;
    } catch (error) {
        // If refresh token is expired or invalid, redirect to login
        localStorage.removeItem(&#39;accessToken&#39;);
        localStorage.removeItem(&#39;refreshToken&#39;);
        window.location.href = &#39;/login&#39;;
    }
};

// Axios interceptor for handling 401 errors
axios.interceptors.response.use(
    response =&gt; response,
    async error =&gt; {
        const originalRequest = error.config;

        if (error.response.status === 401 &amp;&amp; !originalRequest._retry) {
            originalRequest._retry = true;

            const accessToken = await refreshAccessToken();

            originalRequest.headers[&#39;Authorization&#39;] = `Bearer ${accessToken}`;
            return axios(originalRequest);
        }

        return Promise.reject(error);
    }
);
</code></pre>
<h3 id="103-how-do-you-handle-business-rules-and-validation-logic-in-spring-boot-applications">103. How do you handle business rules and validation logic in Spring Boot applications?</h3>
<p>Business rules and validation approaches:</p>
<ol>
    <li><strong>Bean Validation (JSR-380)</strong>:</li>
</ol>
<pre><code class="language-java">public class OrderRequest {
    @NotNull(message = &quot;Customer ID is required&quot;)
    private Long customerId;

    @NotEmpty(message = &quot;Order must contain at least one item&quot;)
    private List&lt;OrderItemRequest&gt; items;

    @Future(message = &quot;Delivery date must be in the future&quot;)
    private LocalDate deliveryDate;

    @AssertTrue(message = &quot;Order value must exceed minimum amount&quot;)
    public boolean isOrderValueValid() {
        return items.stream()
                .mapToDouble(item -&gt; item.getPrice() * item.getQuantity())
                .sum() &gt;= 10.0;
    }
}

@RestController
@RequestMapping(&quot;/api/orders&quot;)
public class OrderController {
    @PostMapping
    public ResponseEntity&lt;Order&gt; createOrder(@Valid @RequestBody OrderRequest request) {
        // If validation fails, MethodArgumentNotValidException is thrown
        return ResponseEntity.ok(orderService.createOrder(request));
    }
}
</code></pre>
<ol start="2">
    <li><strong>Service-layer validation</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderService {
    public Order createOrder(OrderRequest request) {
        // Business validation
        validateOrder(request);

        // Transform request to domain object
        Order order = orderMapper.toEntity(request);

        // Process order
        return orderRepository.save(order);
    }

    private void validateOrder(OrderRequest request) {
        // Complex business rules validation
        if (request.getItems().isEmpty()) {
            throw new InvalidOrderException(&quot;Order must contain at least one item&quot;);
        }

        // Check inventory availability
        for (OrderItemRequest item : request.getItems()) {
            Product product = productRepository.findById(item.getProductId())
                    .orElseThrow(() -&gt; new ProductNotFoundException(item.getProductId()));

            if (product.getStock() &lt; item.getQuantity()) {
                throw new InsufficientInventoryException(
                        &quot;Insufficient inventory for product: &quot; + product.getName());
            }
        }

        // Check customer credit limit
        Customer customer = customerRepository.findById(request.getCustomerId())
                .orElseThrow(() -&gt; new CustomerNotFoundException(request.getCustomerId()));

        double orderTotal = calculateOrderTotal(request.getItems());

        if (customer.getCreditLimit() &lt; orderTotal) {
            throw new CreditLimitExceededException(
                    &quot;Order exceeds customer credit limit of &quot; + customer.getCreditLimit());
        }
    }
}
</code></pre>
<ol start="3">
    <li><strong>Spring Validator implementation</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class OrderValidator implements Validator {
    @Override
    public boolean supports(Class&lt;?&gt; clazz) {
        return OrderRequest.class.equals(clazz);
    }

    @Override
    public void validate(Object target, Errors errors) {
        OrderRequest request = (OrderRequest) target;

        if (request.getItems() == null || request.getItems().isEmpty()) {
            errors.reject(&quot;items.empty&quot;, &quot;Order must have at least one item&quot;);
        }

        // Validate delivery date
        if (request.getDeliveryDate() != null &amp;&amp;
                request.getDeliveryDate().isBefore(LocalDate.now())) {
            errors.rejectValue(&quot;deliveryDate&quot;, &quot;deliveryDate.past&quot;,
                    &quot;Delivery date must be in the future&quot;);
        }

        // Calculate and validate total order value
        if (request.getItems() != null &amp;&amp; !request.getItems().isEmpty()) {
            double total = request.getItems().stream()
                    .mapToDouble(i -&gt; i.getPrice() * i.getQuantity())
                    .sum();

            if (total &lt; 10.0) {
                errors.reject(&quot;order.value.tooLow&quot;,
                        &quot;Order total must be at least $10.00&quot;);
            }
        }
    }
}

@RestController
@RequestMapping(&quot;/api/orders&quot;)
public class OrderController {
    private final OrderValidator orderValidator;

    @InitBinder
    protected void initBinder(WebDataBinder binder) {
        binder.addValidators(orderValidator);
    }

    @PostMapping
    public ResponseEntity&lt;Order&gt; createOrder(@RequestBody @Validated OrderRequest request) {
        return ResponseEntity.ok(orderService.createOrder(request));
    }
}
</code></pre>
<ol start="4">
    <li><strong>Rule engine integration</strong> (Drools):</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-core&lt;/artifactId&gt;
    &lt;version&gt;7.73.0.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;
    &lt;version&gt;7.73.0.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class DroolsConfig {
    @Bean
    public KieContainer kieContainer() {
        KieServices kieServices = KieServices.Factory.get();
        KieFileSystem kieFileSystem = kieServices.newKieFileSystem();

        kieFileSystem.write(ResourceFactory.newClassPathResource(&quot;rules/order-rules.drl&quot;));
        KieBuilder kieBuilder = kieServices.newKieBuilder(kieFileSystem);
        kieBuilder.buildAll();

        KieModule kieModule = kieBuilder.getKieModule();

        return kieServices.newKieContainer(kieModule.getReleaseId());
    }
}

@Service
public class OrderRuleService {
    @Autowired
    private KieContainer kieContainer;

    public OrderValidationResult validateOrder(Order order) {
        OrderValidationResult result = new OrderValidationResult();

        KieSession kieSession = kieContainer.newKieSession();
        kieSession.insert(order);
        kieSession.insert(result);
        kieSession.fireAllRules();
        kieSession.dispose();

        return result;
    }
}
</code></pre>
<pre><code>// file: rules/order-rules.drl
package com.example.rules;

import com.example.model.Order;
import com.example.model.OrderValidationResult;
import java.time.LocalDate;

rule &quot;Minimum Order Value&quot;
    when
        $order : Order(getTotalValue() &lt; 10)
        $result : OrderValidationResult()
    then
        $result.addError(&quot;Order total must be at least $10.00&quot;);
end

rule &quot;Future Delivery Date&quot;
    when
        $order : Order(deliveryDate.isBefore(LocalDate.now()))
        $result : OrderValidationResult()
    then
        $result.addError(&quot;Delivery date must be in the future&quot;);
end
</code></pre>
<ol start="5">
    <li><strong>Specification pattern</strong>:</li>
</ol>
<pre><code class="language-java">public interface Specification&lt;T&gt; {
    boolean isSatisfiedBy(T t);
    String getReason();
}

public class MinimumOrderValueSpecification implements Specification&lt;Order&gt; {
    private static final double MINIMUM_VALUE = 10.0;

    @Override
    public boolean isSatisfiedBy(Order order) {
        return order.getTotalValue() &gt;= MINIMUM_VALUE;
    }

    @Override
    public String getReason() {
        return &quot;Order total must be at least $&quot; + MINIMUM_VALUE;
    }
}

public class FutureDeliveryDateSpecification implements Specification&lt;Order&gt; {
    @Override
    public boolean isSatisfiedBy(Order order) {
        return order.getDeliveryDate() == null ||
               order.getDeliveryDate().isAfter(LocalDate.now());
    }

    @Override
    public String getReason() {
        return &quot;Delivery date must be in the future&quot;;
    }
}

@Service
public class OrderValidationService {
    private final List&lt;Specification&lt;Order&gt;&gt; specifications;

    public OrderValidationService() {
        specifications = Arrays.asList(
            new MinimumOrderValueSpecification(),
            new FutureDeliveryDateSpecification(),
            new AvailableInventorySpecification(productRepository)
            // Add more specifications as needed
        );
    }

    public ValidationResult validate(Order order) {
        ValidationResult result = new ValidationResult();

        for (Specification&lt;Order&gt; spec : specifications) {
            if (!spec.isSatisfiedBy(order)) {
                result.addError(spec.getReason());
            }
        }

        return result;
    }
}
</code></pre>
<h3 id="104-how-do-you-implement-event-driven-microservices-with-spring-cloud-stream">104. How do you implement event-driven microservices with Spring Cloud Stream?</h3>
<p>Event-driven architecture with Spring Cloud Stream:</p>
<ol>
    <li><strong>Dependencies</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-stream-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Message producer configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class StreamConfig {
    @Bean
    public Function&lt;String, String&gt; uppercase() {
        return String::toUpperCase;
    }

    @Bean
    public Supplier&lt;String&gt; greetingSupplier() {
        return () -&gt; &quot;Hello, &quot; + LocalDateTime.now();
    }
}
</code></pre>
<pre><code class="language-properties"># Configure Kafka binder
spring.cloud.stream.kafka.binder.brokers=localhost:9092

# Configure producer binding
spring.cloud.stream.bindings.uppercase-in-0.destination=lowercase-topic
spring.cloud.stream.bindings.uppercase-out-0.destination=uppercase-topic

# Configure supplier binding
spring.cloud.stream.bindings.greetingSupplier-out-0.destination=greeting-topic
spring.cloud.stream.poller.fixed-delay=5000
</code></pre>
<ol start="3">
    <li><strong>Consumer implementation</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class EventConsumerConfig {
    private final Logger log = LoggerFactory.getLogger(EventConsumerConfig.class);

    @Bean
    public Consumer&lt;String&gt; logUppercase() {
        return message -&gt; log.info(&quot;Received: {}&quot;, message);
    }
}
</code></pre>
<pre><code class="language-properties"># Consumer configuration
spring.cloud.stream.bindings.logUppercase-in-0.destination=uppercase-topic
spring.cloud.stream.bindings.logUppercase-in-0.group=logging-group
</code></pre>
<ol start="4">
    <li><strong>Event processor with domain events</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class OrderEventProcessing {
    @Bean
    public Function&lt;OrderCreatedEvent, OrderProcessingEvent&gt; processOrder() {
        return orderCreatedEvent -&gt; {
            log.info(&quot;Processing order: {}&quot;, orderCreatedEvent.getOrderId());

            // Business logic to process the order
            return new OrderProcessingEvent(
                orderCreatedEvent.getOrderId(),
                &quot;PROCESSING&quot;,
                LocalDateTime.now()
            );
        };
    }
}
</code></pre>
<pre><code class="language-properties">spring.cloud.stream.bindings.processOrder-in-0.destination=order-created
spring.cloud.stream.bindings.processOrder-out-0.destination=order-status
</code></pre>
<ol start="5">
    <li><strong>Manual publishing with StreamBridge</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderService {
    private final OrderRepository orderRepository;
    private final StreamBridge streamBridge;

    public Order createOrder(OrderRequest orderRequest) {
        // Create and save the order
        Order order = new Order();
        order.setItems(orderRequest.getItems());
        order.setStatus(&quot;NEW&quot;);
        order = orderRepository.save(order);

        // Publish event
        OrderCreatedEvent event = new OrderCreatedEvent();
        event.setOrderId(order.getId());
        event.setCustomerId(order.getCustomerId());
        event.setTotalAmount(calculateTotal(order));
        event.setCreatedAt(LocalDateTime.now());

        streamBridge.send(&quot;orderCreatedSupplier-out-0&quot;, event);

        return order;
    }
}
</code></pre>
<ol start="6">
    <li><strong>Error handling</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class OrderErrorHandling {
    private final Logger log = LoggerFactory.getLogger(OrderErrorHandling.class);

    @Bean
    public Consumer&lt;ErrorMessage&gt; orderError() {
        return errorMessage -&gt; {
            log.error(&quot;Error processing order: {}&quot;, errorMessage.getPayload());
            // Handle error (retry, dead-letter, etc.)
        };
    }
}
</code></pre>
<pre><code class="language-properties"># Error channel configuration
spring.cloud.stream.bindings.orderError-in-0.destination=order-errors

# Configure error handling for processOrder
spring.cloud.stream.bindings.processOrder-in-0.consumer.max-attempts=3
spring.cloud.stream.kafka.bindings.processOrder-in-0.consumer.enable-dlq=true
spring.cloud.stream.kafka.bindings.processOrder-in-0.consumer.dlq-name=order-dlq
</code></pre>
<ol start="7">
    <li><strong>Schema registry with Avro</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-stream-schema&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.confluent&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-avro-serializer&lt;/artifactId&gt;
    &lt;version&gt;7.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># Schema registry configuration
spring.cloud.stream.kafka.binder.producer-properties.key.serializer=io.confluent.kafka.serializers.KafkaAvroSerializer
spring.cloud.stream.kafka.binder.producer-properties.value.serializer=io.confluent.kafka.serializers.KafkaAvroSerializer
spring.cloud.stream.kafka.binder.producer-properties.schema.registry.url=http://localhost:8081

spring.cloud.stream.kafka.binder.consumer-properties.key.deserializer=io.confluent.kafka.serializers.KafkaAvroDeserializer
spring.cloud.stream.kafka.binder.consumer-properties.value.deserializer=io.confluent.kafka.serializers.KafkaAvroDeserializer
spring.cloud.stream.kafka.binder.consumer-properties.schema.registry.url=http://localhost:8081
spring.cloud.stream.kafka.binder.consumer-properties.specific.avro.reader=true
</code></pre>
<h3 id="105-how-do-you-implement-distributed-caching-in-spring-boot">105. How do you implement distributed caching in Spring Boot?</h3>
<p>Distributed caching strategies:</p>
<ol>
    <li><strong>Redis cache implementation</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableCaching
public class RedisCacheConfig {
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        // Default cache configuration
        RedisCacheConfiguration defaultCacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .disableCachingNullValues()
                .serializeKeysWith(
                    RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(
                    RedisSerializationContext.SerializationPair.fromSerializer(
                        new GenericJackson2JsonRedisSerializer()));

        // Create cache configurations for specific caches
        Map&lt;String, RedisCacheConfiguration&gt; cacheConfigs = new HashMap&lt;&gt;();
        cacheConfigs.put(&quot;products&quot;, defaultCacheConfig.entryTtl(Duration.ofHours(1)));
        cacheConfigs.put(&quot;categories&quot;, defaultCacheConfig.entryTtl(Duration.ofDays(1)));
        cacheConfigs.put(&quot;userSessions&quot;, defaultCacheConfig.entryTtl(Duration.ofMinutes(30)));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(defaultCacheConfig)
                .withInitialCacheConfigurations(cacheConfigs)
                .build();
    }
}
</code></pre>
<pre><code class="language-properties"># Redis configuration
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=
spring.redis.timeout=2000
spring.redis.lettuce.pool.max-active=8
spring.redis.lettuce.pool.max-idle=8
spring.redis.lettuce.pool.min-idle=2
</code></pre>
<ol start="2">
    <li><strong>Using cache in service layer</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class ProductService {
    private final ProductRepository productRepository;

    @Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;, unless = &quot;#result == null&quot;)
    public Product getProductById(Long id) {
        return productRepository.findById(id).orElse(null);
    }

    @CachePut(value = &quot;products&quot;, key = &quot;#product.id&quot;)
    public Product updateProduct(Product product) {
        return productRepository.save(product);
    }

    @CacheEvict(value = &quot;products&quot;, key = &quot;#id&quot;)
    public void deleteProduct(Long id) {
        productRepository.deleteById(id);
    }

    @CacheEvict(value = &quot;products&quot;, allEntries = true)
    public void clearProductCache() {
        // Method to clear all product cache entries
    }
}
</code></pre>
<ol start="3">
    <li><strong>Hazelcast configuration</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast-spring&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableCaching
public class HazelcastConfig {
    @Bean
    public HazelcastInstance hazelcastInstance() {
        Config config = new Config();
        config.setInstanceName(&quot;hazelcast-instance&quot;);

        // Configure network settings
        NetworkConfig networkConfig = config.getNetworkConfig();
        networkConfig.setPort(5701);
        networkConfig.setPortAutoIncrement(true);

        // Configure multicast for auto-discovery
        JoinConfig joinConfig = networkConfig.getJoin();
        joinConfig.getMulticastConfig().setEnabled(true);
        joinConfig.getTcpIpConfig().setEnabled(false);

        // Configure cache maps
        MapConfig productsMap = new MapConfig(&quot;products&quot;);
        productsMap.setTimeToLiveSeconds(3600); // 1 hour TTL
        productsMap.setMaxIdleSeconds(1800);    // 30 minutes max idle time
        productsMap.setBackupCount(1);          // One backup copy
        config.addMapConfig(productsMap);

        return Hazelcast.newHazelcastInstance(config);
    }

    @Bean
    public CacheManager cacheManager(HazelcastInstance hazelcastInstance) {
        return new HazelcastCacheManager(hazelcastInstance);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Handling cache updates in a distributed environment</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class DistributedCacheService {
    private final CacheManager cacheManager;
    private final RedisTemplate&lt;String, String&gt; redisTemplate;

    public void invalidateCache(String cacheName, String key) {
        // Local cache eviction
        Cache cache = cacheManager.getCache(cacheName);
        if (cache != null) {
            cache.evict(key);
        }

        // Broadcast cache invalidation message to other services
        CacheInvalidationMessage message = new CacheInvalidationMessage(cacheName, key);
        redisTemplate.convertAndSend(&quot;cache:invalidation&quot;, JsonUtils.toJson(message));
    }
}

@Component
public class CacheInvalidationListener {
    private final CacheManager cacheManager;

    @Bean
    public RedisMessageListenerContainer redisMessageListenerContainer(
            RedisConnectionFactory connectionFactory) {

        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);

        container.addMessageListener(
            (message, pattern) -&gt; {
                try {
                    CacheInvalidationMessage invalidationMessage =
                            JsonUtils.fromJson(message.toString(), CacheInvalidationMessage.class);

                    Cache cache = cacheManager.getCache(invalidationMessage.getCacheName());
                    if (cache != null) {
                        cache.evict(invalidationMessage.getKey());
                    }
                } catch (Exception e) {
                    log.error(&quot;Error processing cache invalidation message&quot;, e);
                }
            },
            new PatternTopic(&quot;cache:invalidation&quot;)
        );

        return container;
    }
}
</code></pre>
<ol start="5">
    <li><strong>Near cache pattern implementation</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class TwoLevelCacheService {
    private final CacheManager localCacheManager;  // Caffeine cache manager (fast, in-memory)
    private final CacheManager remoteCacheManager; // Redis cache manager (distributed)

    public Product getProductById(Long id) {
        String cacheKey = &quot;product:&quot; + id;

        // Try local cache first
        Cache localCache = localCacheManager.getCache(&quot;localProducts&quot;);
        if (localCache != null) {
            Product product = localCache.get(cacheKey, Product.class);
            if (product != null) {
                return product;
            }
        }

        // Try remote cache
        Cache remoteCache = remoteCacheManager.getCache(&quot;products&quot;);
        if (remoteCache != null) {
            Product product = remoteCache.get(cacheKey, Product.class);

            // Populate local cache if found in remote
            if (product != null &amp;&amp; localCache != null) {
                localCache.put(cacheKey, product);
            }

            if (product != null) {
                return product;
            }
        }

        // Fetch from database if not found in any cache
        Product product = productRepository.findById(id).orElse(null);

        if (product != null) {
            // Update both caches
            if (remoteCache != null) {
                remoteCache.put(cacheKey, product);
            }

            if (localCache != null) {
                localCache.put(cacheKey, product);
            }
        }

        return product;
    }
}
</code></pre>
<h3 id="106-how-do-you-implement-distributed-session-management-in-a-spring-boot-application">106. How do you implement distributed session management in a Spring Boot application?</h3>
<p>Distributed session management approaches:</p>
<ol>
    <li><strong>Spring Session with Redis</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 1800) // 30 minutes
public class SessionConfig {
    @Bean
    public RedisSerializer&lt;Object&gt; springSessionDefaultRedisSerializer() {
        return new GenericJackson2JsonRedisSerializer();
    }
}
</code></pre>
<pre><code class="language-properties"># Redis configuration
spring.redis.host=localhost
spring.redis.port=6379

# Session config
server.servlet.session.timeout=30m
spring.session.store-type=redis
spring.session.redis.namespace=spring:session
spring.session.redis.flush-mode=on-save
</code></pre>
<ol start="2">
    <li><strong>Spring Session with JDBC</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
    &lt;artifactId&gt;spring-session-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableJdbcHttpSession(maxInactiveIntervalInSeconds = 1800)
public class JdbcSessionConfig {
    @Bean
    public JdbcSessionRepository.InitializerDependsOnBeanFactoryPostProcessor
           initializerDependsOnBeanFactoryPostProcessor() {
        return new JdbcSessionRepository.InitializerDependsOnBeanFactoryPostProcessor();
    }
}
</code></pre>
<pre><code class="language-properties"># Session config
spring.session.store-type=jdbc
spring.session.jdbc.initialize-schema=always
spring.session.jdbc.schema=classpath:org/springframework/session/jdbc/schema-mysql.sql
spring.session.jdbc.table-name=SPRING_SESSION
</code></pre>
<ol start="3">
    <li><strong>Spring Session with Hazelcast</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
    &lt;artifactId&gt;spring-session-hazelcast&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableHazelcastHttpSession(maxInactiveIntervalInSeconds = 1800)
public class HazelcastSessionConfig {
    @Bean
    public HazelcastInstance hazelcastInstance() {
        Config config = new Config();
        config.setInstanceName(&quot;hazelcast-instance&quot;);

        // Configure map for session data
        MapConfig sessionMapConfig = new MapConfig(&quot;spring:session:sessions&quot;);
        sessionMapConfig.setTimeToLiveSeconds(1800);
        config.addMapConfig(sessionMapConfig);

        // Network configuration for clustering
        NetworkConfig networkConfig = config.getNetworkConfig();
        JoinConfig joinConfig = networkConfig.getJoin();
        joinConfig.getMulticastConfig().setEnabled(true);
        joinConfig.getTcpIpConfig().setEnabled(false);

        return Hazelcast.newHazelcastInstance(config);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Handling authentication with distributed sessions</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -&gt; auth
                .requestMatchers(&quot;/public/**&quot;).permitAll()
                .requestMatchers(&quot;/api/**&quot;).authenticated()
            )
            .formLogin(form -&gt; form
                .loginPage(&quot;/login&quot;)
                .defaultSuccessUrl(&quot;/dashboard&quot;)
                .permitAll()
            )
            .logout(logout -&gt; logout
                .logoutUrl(&quot;/logout&quot;)
                .logoutSuccessUrl(&quot;/login?logout&quot;)
                .invalidateHttpSession(true)
                .deleteCookies(&quot;SESSION&quot;)
            )
            .sessionManagement(session -&gt; session
                .sessionFixation().migrateSession()
                .maximumSessions(1)
                .expiredUrl(&quot;/login?expired&quot;)
            );

        return http.build();
    }
}
</code></pre>
<ol start="5">
    <li><strong>Session events listener</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class SessionEventListener implements ApplicationListener&lt;AbstractSessionEvent&gt; {
    private final Logger logger = LoggerFactory.getLogger(SessionEventListener.class);

    @Override
    public void onApplicationEvent(AbstractSessionEvent event) {
        if (event instanceof SessionCreatedEvent) {
            logger.info(&quot;Session created: {}&quot;, ((SessionCreatedEvent) event).getSessionId());
        } else if (event instanceof SessionDeletedEvent) {
            logger.info(&quot;Session deleted: {}&quot;, ((SessionDeletedEvent) event).getSessionId());
        } else if (event instanceof SessionExpiredEvent) {
            logger.info(&quot;Session expired: {}&quot;, ((SessionExpiredEvent) event).getSessionId());
        }
    }
}
</code></pre>
<ol start="6">
    <li><strong>Sticky sessions with load balancer</strong>:</li>
</ol>
<pre><code class="language-yaml"># Kubernetes example with sticky sessions
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: spring-app-ingress
  annotations:
    nginx.ingress.kubernetes.io/affinity: &quot;cookie&quot;
    nginx.ingress.kubernetes.io/session-cookie-name: &quot;SESSIONID&quot;
    nginx.ingress.kubernetes.io/session-cookie-expires: &quot;172800&quot;
    nginx.ingress.kubernetes.io/session-cookie-max-age: &quot;172800&quot;
spec:
  rules:
  - host: app.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: spring-app
            port:
              number: 80
</code></pre>
<h3 id="107-how-do-you-implement-continuous-delivery-for-spring-boot-applications">107. How do you implement continuous delivery for Spring Boot applications?</h3>
<p>Continuous delivery pipeline for Spring Boot:</p>
<ol>
    <li><strong>CI/CD pipeline with GitHub Actions</strong>:</li>
</ol>
<pre><code class="language-yaml"># .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: &#39;17&#39;
        distribution: &#39;adopt&#39;
        cache: maven

    - name: Build with Maven
      run: mvn -B clean verify

    - name: Run tests
      run: mvn -B test

    - name: Code quality
      run: mvn sonar:sonar -Dsonar.projectKey=my-project -Dsonar.host.url=${{ secrets.SONAR_URL }} -Dsonar.login=${{ secrets.SONAR_TOKEN }}

    - name: Build Docker image
      run: |
        docker build -t myorg/myapp:${{ github.sha }} .
        docker tag myorg/myapp:${{ github.sha }} myorg/myapp:latest

    - name: Log in to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

    - name: Push Docker image
      run: |
        docker push myorg/myapp:${{ github.sha }}
        docker push myorg/myapp:latest

  deploy-dev:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: development
      url: https://dev.example.com

    steps:
    - name: Deploy to Dev
      uses: actions/checkout@v3

    - name: Update deployment config
      run: |
        sed -i &#39;s|image: myorg/myapp:.*|image: myorg/myapp:${{ github.sha }}|&#39; k8s/deployment.yaml

    - name: Deploy to Kubernetes
      uses: actions-hub/kubectl@master
      env:
        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
      with:
        args: apply -f k8s/deployment.yaml -n dev

    - name: Verify deployment
      uses: actions-hub/kubectl@master
      env:
        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
      with:
        args: rollout status deployment/myapp -n dev

  deploy-prod:
    needs: deploy-dev
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://example.com

    steps:
    - name: Wait for approval
      run: echo &quot;Deployment to production approved&quot;

    - name: Deploy to Production
      uses: actions/checkout@v3

    - name: Update deployment config
      run: |
        sed -i &#39;s|image: myorg/myapp:.*|image: myorg/myapp:${{ github.sha }}|&#39; k8s/deployment.yaml

    - name: Deploy to Kubernetes
      uses: actions-hub/kubectl@master
      env:
        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG_PROD }}
      with:
        args: apply -f k8s/deployment.yaml -n prod
</code></pre>
<ol start="2">
    <li><strong>Dockerfile</strong>:</li>
</ol>
<pre><code class="language-dockerfile">FROM eclipse-temurin:17-jre-alpine as builder
WORKDIR /app
COPY target/*.jar app.jar
RUN java -Djarmode=layertools -jar app.jar extract

FROM eclipse-temurin:17-jre-alpine
WORKDIR /app
RUN addgroup -S spring &amp;&amp; adduser -S spring -G spring
USER spring:spring

# Copy layers from the builder stage
COPY --from=builder /app/dependencies/ ./
COPY --from=builder /app/spring-boot-loader/ ./
COPY --from=builder /app/snapshot-dependencies/ ./
COPY --from=builder /app/application/ ./

# Environment variables
ENV JAVA_OPTS=&quot;-XX:+UseG1GC -XX:+UseContainerSupport -Xmx512m&quot;

HEALTHCHECK --interval=30s --timeout=3s \
  CMD wget -q --spider http://localhost:8080/actuator/health || exit 1

EXPOSE 8080
ENTRYPOINT [&quot;java&quot;, &quot;org.springframework.boot.loader.JarLauncher&quot;]
</code></pre>
<ol start="3">
    <li><strong>Kubernetes deployment</strong>:</li>
</ol>
<pre><code class="language-yaml"># k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 2
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myorg/myapp:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: environment
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-creds
              key: password
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 20
        resources:
          requests:
            cpu: &quot;200m&quot;
            memory: &quot;256Mi&quot;
          limits:
            cpu: &quot;500m&quot;
            memory: &quot;512Mi&quot;
---
apiVersion: v1
kind: Service
metadata:
  name: myapp
spec:
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
</code></pre>
<ol start="4">
    <li><strong>Blue-Green deployment with ArgoCD</strong>:</li>
</ol>
<pre><code class="language-yaml"># argocd/application.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: myapp
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/myorg/myapp-gitops
    targetRevision: HEAD
    path: k8s/overlays/blue
  destination:
    server: https://kubernetes.default.svc
    namespace: myapp
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
</code></pre>
<ol start="5">
    <li><strong>Configuration for different environments</strong>:</li>
</ol>
<pre><code class="language-yaml"># k8s/base/kustomization.yaml
resources:
- deployment.yaml
- service.yaml
</code></pre>
<pre><code class="language-yaml"># k8s/overlays/dev/kustomization.yaml
bases:
- ../../base
patchesStrategicMerge:
- deployment-patch.yaml
configMapGenerator:
- name: app-config
  literals:
  - environment=dev
  - log.level=DEBUG
</code></pre>
<pre><code class="language-yaml"># k8s/overlays/dev/deployment-patch.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 1
  template:
    spec:
      containers:
      - name: myapp
        resources:
          limits:
            memory: &quot;512Mi&quot;
            cpu: &quot;500m&quot;
</code></pre>
<pre><code class="language-yaml"># k8s/overlays/prod/kustomization.yaml
bases:
- ../../base
patchesStrategicMerge:
- deployment-patch.yaml
configMapGenerator:
- name: app-config
  literals:
  - environment=prod
  - log.level=INFO
</code></pre>
<pre><code class="language-yaml"># k8s/overlays/prod/deployment-patch.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: myapp
        resources:
          limits:
            memory: &quot;1Gi&quot;
            cpu: &quot;1&quot;
</code></pre>
<h3 id="108-how-do-you-implement-audit-logging-in-a-spring-boot-application">108. How do you implement audit logging in a Spring Boot application?</h3>
<p>Audit logging implementation approaches:</p>
<ol>
    <li><strong>Spring Data JPA Auditing</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableJpaAuditing
public class AuditConfig {
    @Bean
    public AuditorAware&lt;String&gt; auditorProvider() {
        return () -&gt; Optional.ofNullable(SecurityContextHolder.getContext())
            .map(SecurityContext::getAuthentication)
            .filter(Authentication::isAuthenticated)
            .map(Authentication::getName)
            .or(() -&gt; Optional.of(&quot;system&quot;));
    }
}

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class Auditable {
    @CreatedBy
    @Column(nullable = false, updatable = false)
    private String createdBy;

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdDate;

    @LastModifiedBy
    @Column(nullable = false)
    private String lastModifiedBy;

    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime lastModifiedDate;

    // Getters and setters
}

@Entity
@Table(name = &quot;products&quot;)
public class Product extends Auditable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private BigDecimal price;

    // Other fields, getters, setters
}
</code></pre>
<ol start="2">
    <li><strong>Explicit audit logging</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Table(name = &quot;audit_logs&quot;)
public class AuditLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String entityType;

    @Column(nullable = false)
    private String entityId;

    @Column(nullable = false)
    private String action;

    @Column(nullable = false)
    private String username;

    @Column(nullable = false)
    private LocalDateTime timestamp;

    @Column(columnDefinition = &quot;TEXT&quot;)
    private String details;

    // Getters and setters
}

@Repository
public interface AuditLogRepository extends JpaRepository&lt;AuditLog, Long&gt; {
    List&lt;AuditLog&gt; findByEntityTypeAndEntityIdOrderByTimestampDesc(String entityType, String entityId);
    List&lt;AuditLog&gt; findByUsernameOrderByTimestampDesc(String username);
}

@Service
public class AuditService {
    private final AuditLogRepository auditLogRepository;

    public void logEvent(String entityType, String entityId, String action, String details) {
        AuditLog log = new AuditLog();
        log.setEntityType(entityType);
        log.setEntityId(entityId);
        log.setAction(action);
        log.setUsername(getCurrentUsername());
        log.setTimestamp(LocalDateTime.now());
        log.setDetails(details);

        auditLogRepository.save(log);
    }

    private String getCurrentUsername() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null &amp;&amp; auth.isAuthenticated()) {
            return auth.getName();
        }
        return &quot;anonymous&quot;;
    }
}
</code></pre>
<ol start="3">
    <li><strong>AOP-based auditing</strong>:</li>
</ol>
<pre><code class="language-java">@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Audited {
    String entity();
    String action();
}

@Aspect
@Component
public class AuditAspect {
    private final AuditService auditService;

    @Around(&quot;@annotation(audited)&quot;)
    public Object auditMethod(ProceedingJoinPoint joinPoint, Audited audited) throws Throwable {
        // Extract method arguments for context
        String entityType = audited.entity();
        String action = audited.action();

        // Extract entity ID from arguments if possible
        String entityId = extractEntityId(joinPoint.getArgs());

        // Log before method execution
        String methodName = joinPoint.getSignature().getName();
        Map&lt;String, Object&gt; details = new HashMap&lt;&gt;();
        details.put(&quot;method&quot;, methodName);
        details.put(&quot;arguments&quot;, Arrays.toString(joinPoint.getArgs()));

        try {
            // Execute the method
            Object result = joinPoint.proceed();

            // Log successful execution
            details.put(&quot;status&quot;, &quot;SUCCESS&quot;);
            if (result != null) {
                entityId = extractEntityIdFromResult(result, entityId);
            }

            auditService.logEvent(entityType, entityId, action, JsonUtils.toJson(details));

            return result;
        } catch (Exception e) {
            // Log failed execution
            details.put(&quot;status&quot;, &quot;FAILED&quot;);
            details.put(&quot;error&quot;, e.getMessage());

            auditService.logEvent(entityType, entityId, action, JsonUtils.toJson(details));

            throw e;
        }
    }

    // Helper methods to extract entity IDs
    private String extractEntityId(Object[] args) {
        // Implementation to extract ID from arguments
    }

    private String extractEntityIdFromResult(Object result, String defaultId) {
        // Implementation to extract ID from result
    }
}
</code></pre>
<ol start="4">
    <li><strong>Spring Data Envers for entity history</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-envers&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableJpaRepositories(repositoryFactoryBeanClass = EnversRevisionRepositoryFactoryBean.class)
public class EnversConfig {
    // Configuration
}

@Entity
@Audited
@Table(name = &quot;products&quot;)
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private BigDecimal price;

    // Other fields, getters, setters
}

@Entity
@RevisionEntity(CustomRevisionListener.class)
public class CustomRevisionEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @RevisionNumber
    private int id;

    @RevisionTimestamp
    private long timestamp;

    @Column(name = &quot;username&quot;, nullable = false)
    private String username;

    // Getters and setters
}

public class CustomRevisionListener implements RevisionListener {
    @Override
    public void newRevision(Object revisionEntity) {
        CustomRevisionEntity revision = (CustomRevisionEntity) revisionEntity;

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null &amp;&amp; auth.isAuthenticated()) {
            revision.setUsername(auth.getName());
        } else {
            revision.setUsername(&quot;system&quot;);
        }
    }
}
</code></pre>
<ol start="5">
    <li><strong>Custom MDC logging</strong>:</li>
</ol>
<pre><code class="language-java">@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class RequestContextFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        try {
            // Add request details to MDC for logging
            MDC.put(&quot;requestId&quot;, UUID.randomUUID().toString());
            MDC.put(&quot;remoteAddr&quot;, request.getRemoteAddr());
            MDC.put(&quot;requestURI&quot;, request.getRequestURI());
            MDC.put(&quot;method&quot;, request.getMethod());

            // Add user info if available
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            if (auth != null &amp;&amp; auth.isAuthenticated()) {
                MDC.put(&quot;username&quot;, auth.getName());
            } else {
                MDC.put(&quot;username&quot;, &quot;anonymous&quot;);
            }

            filterChain.doFilter(request, response);
        } finally {
            MDC.clear();
        }
    }
}
</code></pre>
<h3 id="109-how-do-you-implement-feature-toggles-feature-flags-in-spring-boot">109. How do you implement feature toggles (feature flags) in Spring Boot?</h3>
<p>Feature toggle implementation approaches:</p>
<ol>
    <li><strong>Simple property-based toggles</strong>:</li>
</ol>
<pre><code class="language-properties"># application.properties
feature.premium-content=true
feature.beta-dashboard=false
feature.new-checkout-flow=true
</code></pre>
<pre><code class="language-java">@Configuration
@ConfigurationProperties(prefix = &quot;feature&quot;)
public class FeatureProperties {
    private boolean premiumContent;
    private boolean betaDashboard;
    private boolean newCheckoutFlow;

    // Getters and setters
}

@Service
public class FeatureService {
    private final FeatureProperties featureProperties;

    public boolean isPremiumContentEnabled() {
        return featureProperties.isPremiumContent();
    }

    public boolean isBetaDashboardEnabled() {
        return featureProperties.isBetaDashboard();
    }

    public boolean isNewCheckoutFlowEnabled() {
        return featureProperties.isNewCheckoutFlow();
    }
}
</code></pre>
<ol start="2">
    <li><strong>Conditional components based on feature toggles</strong>:</li>
</ol>
<pre><code class="language-java">@Component
@ConditionalOnProperty(name = &quot;feature.premium-content&quot;, havingValue = &quot;true&quot;)
public class PremiumContentProvider implements ContentProvider {
    // Premium content implementation
}

@Component
@ConditionalOnProperty(name = &quot;feature.premium-content&quot;, havingValue = &quot;false&quot;, matchIfMissing = true)
public class StandardContentProvider implements ContentProvider {
    // Standard content implementation
}

@Service
public class ContentService {
    private final ContentProvider contentProvider;

    public ContentService(ContentProvider contentProvider) {
        this.contentProvider = contentProvider;
    }

    public List&lt;Content&gt; getContentForUser(User user) {
        return contentProvider.getContent(user);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Dynamic feature toggles with database storage</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Table(name = &quot;feature_toggles&quot;)
public class FeatureToggle {
    @Id
    private String name;

    private boolean enabled;

    @Column(length = 500)
    private String description;

    private LocalDateTime lastModified;

    // Getters and setters
}

@Repository
public interface FeatureToggleRepository extends JpaRepository&lt;FeatureToggle, String&gt; {
}

@Service
public class DynamicFeatureService {
    private final FeatureToggleRepository repository;
    private final ConcurrentHashMap&lt;String, Boolean&gt; featureCache = new ConcurrentHashMap&lt;&gt;();

    public boolean isFeatureEnabled(String featureName) {
        // Check cache first
        return featureCache.computeIfAbsent(featureName, key -&gt; {
            // Load from database if not in cache
            return repository.findById(key)
                    .map(FeatureToggle::isEnabled)
                    .orElse(false);
        });
    }

    public void setFeatureEnabled(String featureName, boolean enabled) {
        FeatureToggle toggle = repository.findById(featureName)
                .orElse(new FeatureToggle());

        toggle.setName(featureName);
        toggle.setEnabled(enabled);
        toggle.setLastModified(LocalDateTime.now());

        repository.save(toggle);
        featureCache.put(featureName, enabled);
    }

    @Scheduled(fixedDelayString = &quot;${feature.cache.refresh.interval:60000}&quot;)
    public void refreshCache() {
        repository.findAll().forEach(toggle -&gt;
            featureCache.put(toggle.getName(), toggle.isEnabled()));
    }
}
</code></pre>
<ol start="4">
    <li><strong>Feature toggle admin API</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/features&quot;)
@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)
public class FeatureToggleController {
    private final DynamicFeatureService featureService;

    @GetMapping
    public List&lt;FeatureToggle&gt; getAllFeatures() {
        return featureService.getAllFeatures();
    }

    @GetMapping(&quot;/{name}&quot;)
    public ResponseEntity&lt;FeatureToggle&gt; getFeature(@PathVariable String name) {
        return featureService.getFeature(name)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PutMapping(&quot;/{name}&quot;)
    public FeatureToggle updateFeature(@PathVariable String name,
                                     @RequestBody FeatureToggleRequest request) {
        featureService.setFeatureEnabled(name, request.isEnabled());
        return featureService.getFeature(name).orElseThrow();
    }

    public static class FeatureToggleRequest {
        private boolean enabled;

        // Getters and setters
    }
}
</code></pre>
<ol start="5">
    <li><strong>User-specific feature toggles</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class UserFeatureService {
    private final DynamicFeatureService featureService;

    public boolean isFeatureEnabledForUser(String featureName, User user) {
        // First check global toggle
        if (!featureService.isFeatureEnabled(featureName)) {
            return false;
        }

        // Then apply user-specific rules
        switch (featureName) {
            case &quot;premium-content&quot;:
                return user.isPremiumSubscriber();

            case &quot;beta-features&quot;:
                return user.isBetaTester();

            case &quot;new-ui&quot;:
                // Gradual rollout based on user ID
                return user.getId() % 100 &lt; 25;  // 25% of users

            default:
                return true;
        }
    }
}
</code></pre>
<ol start="6">
    <li><strong>Thymeleaf integration for feature toggles</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class ThymeleafConfig {
    @Bean
    public FeatureDialect featureDialect(FeatureService featureService) {
        return new FeatureDialect(featureService);
    }
}

public class FeatureDialect extends AbstractProcessorDialect {
    private final FeatureService featureService;

    public FeatureDialect(FeatureService featureService) {
        super(&quot;Feature Toggle Dialect&quot;, &quot;feature&quot;, 1000);
        this.featureService = featureService;
    }

    @Override
    public Set&lt;IProcessor&gt; getProcessors(String dialectPrefix) {
        Set&lt;IProcessor&gt; processors = new HashSet&lt;&gt;();
        processors.add(new FeatureIfProcessor(dialectPrefix, featureService));
        return processors;
    }
}

public class FeatureIfProcessor extends AbstractConditionalVisibilityTagProcessor {
    private final FeatureService featureService;

    public FeatureIfProcessor(String dialectPrefix, FeatureService featureService) {
        super(dialectPrefix, &quot;if&quot;, 100);
        this.featureService = featureService;
    }

    @Override
    protected boolean evaluateCondition(ITemplateContext context, IProcessableElementTag tag,
                                     AttributeName attributeName, String attributeValue) {
        return featureService.isFeatureEnabled(attributeValue);
    }
}
</code></pre>
<pre><code class="language-html">&lt;!-- Usage in Thymeleaf template --&gt;
&lt;div feature:if=&quot;premium-content&quot;&gt;
    &lt;h2&gt;Premium Content&lt;/h2&gt;
    &lt;p&gt;This content is only visible when the premium-content feature is enabled.&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<ol start="7">
    <li><strong>Integration with external feature flag service</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;!-- Example with LaunchDarkly --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.launchdarkly&lt;/groupId&gt;
    &lt;artifactId&gt;launchdarkly-java-server-sdk&lt;/artifactId&gt;
    &lt;version&gt;5.10.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class LaunchDarklyConfig {
    @Bean
    public LDClient ldClient(@Value(&quot;${launchdarkly.sdk-key}&quot;) String sdkKey) {
        LDConfig config = new LDConfig.Builder()
            .events(Components.sendEvents().capacity(1000))
            .build();

        return new LDClient(sdkKey, config);
    }
}

@Service
public class FeatureFlagService {
    private final LDClient ldClient;

    public boolean isFeatureEnabled(String featureName) {
        return ldClient.boolVariation(featureName, createAnonymousContext(), false);
    }

    public boolean isFeatureEnabledForUser(String featureName, User user) {
        LDUser ldUser = new LDUser.Builder(user.getId().toString())
            .firstName(user.getFirstName())
            .lastName(user.getLastName())
            .email(user.getEmail())
            .custom(&quot;role&quot;, user.getRole())
            .custom(&quot;region&quot;, user.getRegion())
            .build();

        return ldClient.boolVariation(featureName, ldUser, false);
    }

    private LDUser createAnonymousContext() {
        return new LDUser.Builder(&quot;anonymous&quot;).anonymous(true).build();
    }
}
</code></pre>
<h2 id="advanced-concepts-and-integration-patterns-1">Advanced Concepts and Integration Patterns</h2>
<h3 id="110-how-do-you-implement-api-versioning-in-spring-boot">110. How do you implement API versioning in Spring Boot?</h3>
<ol start="2">
    <li><strong>Request parameter versioning</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @GetMapping(value = &quot;/{id}&quot;, params = &quot;version=1&quot;)
    public ProductV1 getProductV1(@PathVariable Long id) {
        // Version 1 implementation
        return productServiceV1.getProduct(id);
    }

    @GetMapping(value = &quot;/{id}&quot;, params = &quot;version=2&quot;)
    public ProductV2 getProductV2(@PathVariable Long id) {
        // Version 2 implementation
        return productServiceV2.getProduct(id);
    }
}
</code></pre>
<p>Usage: <code>/api/products/123?version=1</code> or <code>/api/products/123?version=2</code></p>
<ol start="3">
    <li><strong>HTTP header versioning</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @GetMapping(value = &quot;/{id}&quot;, headers = &quot;X-API-Version=1&quot;)
    public ProductV1 getProductV1(@PathVariable Long id) {
        // Version 1 implementation
        return productServiceV1.getProduct(id);
    }

    @GetMapping(value = &quot;/{id}&quot;, headers = &quot;X-API-Version=2&quot;)
    public ProductV2 getProductV2(@PathVariable Long id) {
        // Version 2 implementation
        return productServiceV2.getProduct(id);
    }
}
</code></pre>
<p>Usage requires setting a custom header: <code>X-API-Version: 1</code></p>
<ol start="4">
    <li><strong>Media type versioning (content negotiation)</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @GetMapping(
        value = &quot;/{id}&quot;,
        produces = &quot;application/vnd.company.app-v1+json&quot;
    )
    public ProductV1 getProductV1(@PathVariable Long id) {
        return productServiceV1.getProduct(id);
    }

    @GetMapping(
        value = &quot;/{id}&quot;,
        produces = &quot;application/vnd.company.app-v2+json&quot;
    )
    public ProductV2 getProductV2(@PathVariable Long id) {
        return productServiceV2.getProduct(id);
    }
}
</code></pre>
<p>Usage requires setting the Accept header: <code>Accept: application/vnd.company.app-v2+json</code></p>
<ol start="5">
    <li><strong>Model versioning with mappers</strong>:</li>
</ol>
<pre><code class="language-java">// Different versions of the model
public class ProductV1 {
    private Long id;
    private String name;
    private BigDecimal price;
}

public class ProductV2 {
    private Long id;
    private String name;
    private BigDecimal price;
    private String description;
    private List&lt;String&gt; categories;
}

// Mapper between versions
@Component
public class ProductMapper {
    public ProductV1 toV1(Product entity) {
        return new ProductV1(
            entity.getId(),
            entity.getName(),
            entity.getPrice()
        );
    }

    public ProductV2 toV2(Product entity) {
        return new ProductV2(
            entity.getId(),
            entity.getName(),
            entity.getPrice(),
            entity.getDescription(),
            entity.getCategories()
        );
    }
}

// Controller using mappers
@RestController
@RequestMapping(&quot;/api&quot;)
public class ProductController {
    private final ProductService productService;
    private final ProductMapper mapper;

    @GetMapping(&quot;/v1/products/{id}&quot;)
    public ProductV1 getProductV1(@PathVariable Long id) {
        Product product = productService.findById(id);
        return mapper.toV1(product);
    }

    @GetMapping(&quot;/v2/products/{id}&quot;)
    public ProductV2 getProductV2(@PathVariable Long id) {
        Product product = productService.findById(id);
        return mapper.toV2(product);
    }
}
</code></pre>
<ol start="6">
    <li><strong>Custom API version annotation</strong>:</li>
</ol>
<pre><code class="language-java">@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@RequestMapping(produces = &quot;application/json&quot;)
public @interface ApiVersion {
    int[] value();
}

@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @ApiVersion(1)
    @GetMapping(&quot;/{id}&quot;)
    public ProductV1 getProductV1(@PathVariable Long id) {
        return productServiceV1.getProduct(id);
    }

    @ApiVersion(2)
    @GetMapping(&quot;/{id}&quot;)
    public ProductV2 getProductV2(@PathVariable Long id) {
        return productServiceV2.getProduct(id);
    }
}

@Component
public class ApiVersionRequestMappingHandlerMapping extends RequestMappingHandlerMapping {
    @Override
    protected RequestCondition&lt;?&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {
        return null;
    }

    @Override
    protected RequestCondition&lt;?&gt; getCustomMethodCondition(Method method) {
        ApiVersion apiVersion = method.getAnnotation(ApiVersion.class);
        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());
    }
}
</code></pre>
<h3 id="111-how-do-you-handle-concurrency-and-locking-in-spring-boot-applications">111. How do you handle concurrency and locking in Spring Boot applications?</h3>
<p>Concurrency and locking strategies:</p>
<ol>
    <li><strong>Optimistic locking with JPA</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Table(name = &quot;products&quot;)
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private BigDecimal price;
    private Integer stock;

    @Version
    private Integer version;

    // Getters and setters
}

@Service
public class ProductService {
    private final ProductRepository productRepository;

    public Product updateStock(Long id, int quantityChange) {
        try {
            Product product = productRepository.findById(id)
                .orElseThrow(() -&gt; new ProductNotFoundException(id));

            // Updating the entity will check version
            product.setStock(product.getStock() + quantityChange);
            return productRepository.save(product);
        } catch (ObjectOptimisticLockingFailureException e) {
            // Handle concurrency conflict
            throw new ConcurrentModificationException(
                &quot;Product was updated by another transaction. Please retry.&quot;);
        }
    }
}
</code></pre>
<ol start="2">
    <li><strong>Pessimistic locking with JPA</strong>:</li>
</ol>
<pre><code class="language-java">@Repository
public interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @QueryHints({@QueryHint(name = &quot;javax.persistence.lock.timeout&quot;, value =&quot;3000&quot;)})
    Optional&lt;Product&gt; findWithLockById(Long id);
}

@Service
@Transactional
public class InventoryService {
    private final ProductRepository productRepository;

    public boolean reserveStock(Long productId, int quantity) {
        // This will lock the row until transaction completes
        Product product = productRepository.findWithLockById(productId)
            .orElseThrow(() -&gt; new ProductNotFoundException(productId));

        if (product.getStock() &lt; quantity) {
            return false;
        }

        product.setStock(product.getStock() - quantity);
        productRepository.save(product);
        return true;
    }
}
</code></pre>
<ol start="3">
    <li><strong>Distributed locking with Redis</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class RedisLockConfig {
    @Bean
    public RedisLockRegistry redisLockRegistry(RedisConnectionFactory connectionFactory) {
        return new RedisLockRegistry(connectionFactory, &quot;locks&quot;, 30000);
    }
}

@Service
public class DistributedLockService {
    private final RedisLockRegistry lockRegistry;

    public &lt;T&gt; T executeWithLock(String lockKey, long timeout, Supplier&lt;T&gt; supplier) {
        Lock lock = lockRegistry.obtain(lockKey);
        try {
            boolean acquired = lock.tryLock(timeout, TimeUnit.MILLISECONDS);
            if (!acquired) {
                throw new LockAcquisitionException(&quot;Could not acquire lock for &quot; + lockKey);
            }
            return supplier.get();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new LockAcquisitionException(&quot;Interrupted while acquiring lock&quot;, e);
        } finally {
            lock.unlock();
        }
    }
}

@Service
public class PaymentService {
    private final DistributedLockService lockService;
    private final TransactionRepository transactionRepository;

    public TransactionResult processPayment(String accountId, BigDecimal amount) {
        return lockService.executeWithLock(&quot;payment:&quot; + accountId, 5000, () -&gt; {
            // This code runs with distributed lock held
            Account account = accountRepository.findById(accountId)
                .orElseThrow(() -&gt; new AccountNotFoundException(accountId));

            if (account.getBalance().compareTo(amount) &lt; 0) {
                throw new InsufficientFundsException();
            }

            account.setBalance(account.getBalance().subtract(amount));
            accountRepository.save(account);

            Transaction tx = new Transaction(accountId, amount, &quot;DEBIT&quot;);
            return transactionRepository.save(tx);
        });
    }
}
</code></pre>
<ol start="4">
    <li><strong>Atomic operations with synchronized blocks</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class CounterService {
    private final AtomicLong counter = new AtomicLong(0);

    public long incrementAndGet() {
        return counter.incrementAndGet();
    }
}

@Service
public class CacheService {
    private final Map&lt;String, Object&gt; cache = new ConcurrentHashMap&lt;&gt;();

    public Object get(String key) {
        return cache.get(key);
    }

    public void put(String key, Object value) {
        cache.put(key, value);
    }
}

@Service
public class ResourceManager {
    private final Object lock = new Object();
    private final List&lt;Resource&gt; resources = new ArrayList&lt;&gt;();

    public void addResource(Resource resource) {
        synchronized(lock) {
            resources.add(resource);
        }
    }

    public List&lt;Resource&gt; getResources() {
        synchronized(lock) {
            return new ArrayList&lt;&gt;(resources);
        }
    }
}
</code></pre>
<ol start="5">
    <li><strong>Batch operations to reduce lock contention</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class BatchUpdateService {
    private final JdbcTemplate jdbcTemplate;

    public int[] batchUpdatePrices(List&lt;ProductPriceUpdate&gt; updates) {
        return jdbcTemplate.batchUpdate(
            &quot;UPDATE products SET price = ? WHERE id = ?&quot;,
            new BatchPreparedStatementSetter() {
                @Override
                public void setValues(PreparedStatement ps, int i) throws SQLException {
                    ProductPriceUpdate update = updates.get(i);
                    ps.setBigDecimal(1, update.getNewPrice());
                    ps.setLong(2, update.getProductId());
                }

                @Override
                public int getBatchSize() {
                    return updates.size();
                }
            });
    }
}
</code></pre>
<ol start="6">
    <li><strong>Semaphore for limiting concurrent operations</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class RateLimitedService {
    private final Semaphore semaphore;

    public RateLimitedService(@Value(&quot;${service.max-concurrent-operations:10}&quot;) int maxConcurrent) {
        this.semaphore = new Semaphore(maxConcurrent);
    }

    public &lt;T&gt; T executeWithRateLimit(Supplier&lt;T&gt; operation) throws RateLimitExceededException {
        try {
            if (!semaphore.tryAcquire(100, TimeUnit.MILLISECONDS)) {
                throw new RateLimitExceededException(&quot;Too many concurrent operations&quot;);
            }

            try {
                return operation.get();
            } finally {
                semaphore.release();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RateLimitExceededException(&quot;Operation interrupted&quot;, e);
        }
    }
}
</code></pre>
<h3 id="112-how-do-you-implement-hypermedia-driven-rest-apis-in-spring-boot">112. How do you implement hypermedia-driven REST APIs in Spring Boot?</h3>
<p>Hypermedia-driven REST APIs with Spring HATEOAS:</p>
<ol>
    <li><strong>Basic setup</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Simple entity model with links</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    private final ProductService productService;

    @GetMapping(&quot;/{id}&quot;)
    public EntityModel&lt;Product&gt; getProduct(@PathVariable Long id) {
        Product product = productService.findById(id);

        return EntityModel.of(product,
            linkTo(methodOn(ProductController.class).getProduct(id)).withSelfRel(),
            linkTo(methodOn(ProductController.class).getAllProducts()).withRel(&quot;products&quot;),
            linkTo(methodOn(CategoryController.class).getCategory(product.getCategoryId())).withRel(&quot;category&quot;)
        );
    }

    @GetMapping
    public CollectionModel&lt;EntityModel&lt;Product&gt;&gt; getAllProducts() {
        List&lt;Product&gt; products = productService.findAll();

        List&lt;EntityModel&lt;Product&gt;&gt; productModels = products.stream()
            .map(product -&gt; EntityModel.of(product,
                linkTo(methodOn(ProductController.class).getProduct(product.getId())).withSelfRel()))
            .collect(Collectors.toList());

        return CollectionModel.of(productModels,
            linkTo(methodOn(ProductController.class).getAllProducts()).withSelfRel());
    }
}
</code></pre>
<ol start="3">
    <li><strong>Model assemblers for reusable link creation</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ProductModelAssembler implements RepresentationModelAssembler&lt;Product, EntityModel&lt;Product&gt;&gt; {

    @Override
    public EntityModel&lt;Product&gt; toModel(Product product) {
        return EntityModel.of(product,
            linkTo(methodOn(ProductController.class).getProduct(product.getId())).withSelfRel(),
            linkTo(methodOn(ProductController.class).getAllProducts()).withRel(&quot;products&quot;),
            linkTo(methodOn(CategoryController.class).getCategory(product.getCategoryId())).withRel(&quot;category&quot;),
            linkTo(methodOn(ReviewController.class).getReviewsForProduct(product.getId())).withRel(&quot;reviews&quot;)
        );
    }

    @Override
    public CollectionModel&lt;EntityModel&lt;Product&gt;&gt; toCollectionModel(Iterable&lt;? extends Product&gt; products) {
        List&lt;EntityModel&lt;Product&gt;&gt; productModels = StreamSupport.stream(products.spliterator(), false)
            .map(this::toModel)
            .collect(Collectors.toList());

        return CollectionModel.of(productModels,
            linkTo(methodOn(ProductController.class).getAllProducts()).withSelfRel());
    }
}
</code></pre>
<ol start="4">
    <li><strong>Using model assemblers in controllers</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    private final ProductService productService;
    private final ProductModelAssembler assembler;

    @GetMapping(&quot;/{id}&quot;)
    public EntityModel&lt;Product&gt; getProduct(@PathVariable Long id) {
        Product product = productService.findById(id);
        return assembler.toModel(product);
    }

    @GetMapping
    public CollectionModel&lt;EntityModel&lt;Product&gt;&gt; getAllProducts() {
        return assembler.toCollectionModel(productService.findAll());
    }
}
</code></pre>
<ol start="5">
    <li><strong>Working with pagination</strong>:</li>
</ol>
<pre><code class="language-java">@GetMapping
public PagedModel&lt;EntityModel&lt;Product&gt;&gt; getProducts(
        @RequestParam(defaultValue = &quot;0&quot;) int page,
        @RequestParam(defaultValue = &quot;10&quot;) int size,
        @RequestParam(defaultValue = &quot;id&quot;) String sort,
        PagedResourcesAssembler&lt;Product&gt; pagedResourcesAssembler) {

    Page&lt;Product&gt; productPage = productService.findAll(
        PageRequest.of(page, size, Sort.by(sort)));

    return pagedResourcesAssembler.toModel(productPage, assembler);
}
</code></pre>
<ol start="6">
    <li><strong>Conditional links based on state</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class OrderModelAssembler implements RepresentationModelAssembler&lt;Order, EntityModel&lt;Order&gt;&gt; {

    @Override
    public EntityModel&lt;Order&gt; toModel(Order order) {
        EntityModel&lt;Order&gt; orderModel = EntityModel.of(order,
            linkTo(methodOn(OrderController.class).getOrder(order.getId())).withSelfRel(),
            linkTo(methodOn(OrderController.class).getAllOrders()).withRel(&quot;orders&quot;)
        );

        // Add conditional links based on order state
        if (order.getStatus() == OrderStatus.IN_PROGRESS) {
            orderModel.add(
                linkTo(methodOn(OrderController.class).cancelOrder(order.getId())).withRel(&quot;cancel&quot;),
                linkTo(methodOn(OrderController.class).completeOrder(order.getId())).withRel(&quot;complete&quot;)
            );
        }

        if (order.getStatus() == OrderStatus.COMPLETED) {
            orderModel.add(
                linkTo(methodOn(InvoiceController.class).getInvoice(order.getId())).withRel(&quot;invoice&quot;)
            );
        }

        return orderModel;
    }
}
</code></pre>
<ol start="7">
    <li><strong>Advanced affordances (action descriptors)</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/orders&quot;)
public class OrderController {

    @GetMapping(&quot;/{id}&quot;)
    public EntityModel&lt;Order&gt; getOrder(@PathVariable Long id) {
        Order order = orderService.findById(id);

        return EntityModel.of(order)
            .add(linkTo(methodOn(OrderController.class).getOrder(id)).withSelfRel()
                // Define what actions can be performed on this link
                .andAffordance(afford(methodOn(OrderController.class).updateOrder(id, null)))
                .andAffordance(afford(methodOn(OrderController.class).cancelOrder(id))))
            .add(linkTo(methodOn(OrderController.class).getAllOrders()).withRel(&quot;orders&quot;));
    }

    @PutMapping(&quot;/{id}&quot;)
    public EntityModel&lt;Order&gt; updateOrder(@PathVariable Long id, @RequestBody Order order) {
        // Implementation
    }

    @DeleteMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;?&gt; cancelOrder(@PathVariable Long id) {
        // Implementation
    }
}
</code></pre>
<ol start="8">
    <li><strong>Custom link relations</strong>:</li>
</ol>
<pre><code class="language-java">// Define custom link relations
public class LinkRelations {
    public static final String CANCEL = &quot;cancel&quot;;
    public static final String INVOICE = &quot;invoice&quot;;
    public static final String PAYMENT = &quot;payment&quot;;
    public static final String SHIPMENT = &quot;shipment&quot;;
}

@Component
public class EnhancedOrderModelAssembler implements RepresentationModelAssembler&lt;Order, EntityModel&lt;Order&gt;&gt; {

    @Override
    public EntityModel&lt;Order&gt; toModel(Order order) {
        EntityModel&lt;Order&gt; orderModel = EntityModel.of(order,
            linkTo(methodOn(OrderController.class).getOrder(order.getId())).withSelfRel()
        );

        if (order.getStatus() == OrderStatus.IN_PROGRESS) {
            orderModel.add(
                linkTo(methodOn(OrderController.class).cancelOrder(order.getId())).withRel(LinkRelations.CANCEL)
            );
        }

        if (order.isPaid()) {
            orderModel.add(
                linkTo(methodOn(InvoiceController.class).getInvoice(order.getId())).withRel(LinkRelations.INVOICE)
            );
        } else {
            orderModel.add(
                linkTo(methodOn(PaymentController.class).initiatePayment(order.getId())).withRel(LinkRelations.PAYMENT)
            );
        }

        return orderModel;
    }
}
</code></pre>
<ol start="9">
    <li><strong>Root controller for API discovery</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
public class ApiController {

    @GetMapping(&quot;/api&quot;)
    public RepresentationModel&lt;?&gt; apiRoot() {
        return RepresentationModel.of(new HashMap&lt;&gt;())
            .add(linkTo(methodOn(ProductController.class).getAllProducts()).withRel(&quot;products&quot;))
            .add(linkTo(methodOn(CategoryController.class).getAllCategories()).withRel(&quot;categories&quot;))
            .add(linkTo(methodOn(OrderController.class).getAllOrders()).withRel(&quot;orders&quot;))
            .add(linkTo(methodOn(CustomerController.class).getAllCustomers()).withRel(&quot;customers&quot;));
    }
}
</code></pre>
<h3 id="113-how-do-you-implement-content-based-routing-in-spring-boot">113. How do you implement content-based routing in Spring Boot?</h3>
<p>Content-based routing approaches:</p>
<ol>
    <li><strong>Request header-based routing</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/documents&quot;)
public class DocumentController {
    private final DocumentService defaultService;
    private final PdfDocumentService pdfService;
    private final XmlDocumentService xmlService;
    private final JsonDocumentService jsonService;

    @GetMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;byte[]&gt; getDocument(
            @PathVariable String id,
            @RequestHeader(value = &quot;Accept&quot;, defaultValue = &quot;application/json&quot;) String acceptHeader) {

        byte[] content;
        String contentType;

        if (acceptHeader.contains(&quot;application/pdf&quot;)) {
            content = pdfService.generateDocument(id);
            contentType = &quot;application/pdf&quot;;
        } else if (acceptHeader.contains(&quot;application/xml&quot;)) {
            content = xmlService.generateDocument(id);
            contentType = &quot;application/xml&quot;;
        } else if (acceptHeader.contains(&quot;application/json&quot;)) {
            content = jsonService.generateDocument(id);
            contentType = &quot;application/json&quot;;
        } else {
            content = defaultService.generateDocument(id);
            contentType = &quot;application/octet-stream&quot;;
        }

        return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(contentType))
            .body(content);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Content negotiation with path extensions</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class ContentNegotiationConfig implements WebMvcConfigurer {
    @Override
    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
        configurer
            .favorParameter(true)
            .parameterName(&quot;format&quot;)
            .ignoreAcceptHeader(false)
            .useRegisteredExtensionsOnly(false)
            .defaultContentType(MediaType.APPLICATION_JSON)
            .mediaType(&quot;json&quot;, MediaType.APPLICATION_JSON)
            .mediaType(&quot;xml&quot;, MediaType.APPLICATION_XML)
            .mediaType(&quot;pdf&quot;, new MediaType(&quot;application&quot;, &quot;pdf&quot;));
    }
}

@RestController
@RequestMapping(&quot;/api/reports&quot;)
public class ReportController {
    private final ReportService reportService;

    @GetMapping(
        value = &quot;/{id}&quot;,
        produces = {
            MediaType.APPLICATION_JSON_VALUE,
            MediaType.APPLICATION_XML_VALUE,
            &quot;application/pdf&quot;
        }
    )
    public Report getReport(@PathVariable Long id) {
        return reportService.generateReport(id);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Request parameter routing</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/content&quot;)
public class ContentController {
    private final Map&lt;String, ContentStrategy&gt; contentStrategies;

    public ContentController(List&lt;ContentStrategy&gt; strategies) {
        // Map each strategy by its supported type
        this.contentStrategies = strategies.stream()
            .collect(Collectors.toMap(ContentStrategy::getType, Function.identity()));
    }

    @GetMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;?&gt; getContent(
            @PathVariable String id,
            @RequestParam(defaultValue = &quot;default&quot;) String type) {

        ContentStrategy strategy = contentStrategies.getOrDefault(
            type, contentStrategies.get(&quot;default&quot;));

        ContentResponse response = strategy.generateContent(id);

        return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(response.getContentType()))
            .body(response.getContent());
    }
}

public interface ContentStrategy {
    String getType();
    ContentResponse generateContent(String id);
}

@Component
public class HtmlContentStrategy implements ContentStrategy {
    @Override
    public String getType() {
        return &quot;html&quot;;
    }

    @Override
    public ContentResponse generateContent(String id) {
        // Generate HTML content
        String content = &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Content &quot; + id + &quot;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
        return new ContentResponse(&quot;text/html&quot;, content);
    }
}

@Component
public class PdfContentStrategy implements ContentStrategy {
    @Override
    public String getType() {
        return &quot;pdf&quot;;
    }

    @Override
    public ContentResponse generateContent(String id) {
        // Generate PDF content
        byte[] pdfContent = generatePdf(id);
        return new ContentResponse(&quot;application/pdf&quot;, pdfContent);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Payload-based routing</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/process&quot;)
public class ProcessingController {
    private final Map&lt;String, PayloadProcessor&gt; processors;

    public ProcessingController(List&lt;PayloadProcessor&gt; processorList) {
        this.processors = processorList.stream()
            .collect(Collectors.toMap(PayloadProcessor::getType, Function.identity()));
    }

    @PostMapping
    public ResponseEntity&lt;ProcessingResult&gt; processPayload(@RequestBody GenericPayload payload) {
        String payloadType = payload.getType();
        PayloadProcessor processor = processors.get(payloadType);

        if (processor == null) {
            return ResponseEntity.badRequest()
                .body(new ProcessingResult(false, &quot;Unsupported payload type: &quot; + payloadType));
        }

        try {
            ProcessingResult result = processor.process(payload);
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ProcessingResult(false, &quot;Processing error: &quot; + e.getMessage()));
        }
    }
}

public interface PayloadProcessor {
    String getType();
    ProcessingResult process(GenericPayload payload);
}

@Component
public class OrderProcessor implements PayloadProcessor {
    @Override
    public String getType() {
        return &quot;order&quot;;
    }

    @Override
    public ProcessingResult process(GenericPayload payload) {
        // Process order payload
        return new ProcessingResult(true, &quot;Order processed successfully&quot;);
    }
}

@Component
public class PaymentProcessor implements PayloadProcessor {
    @Override
    public String getType() {
        return &quot;payment&quot;;
    }

    @Override
    public ProcessingResult process(GenericPayload payload) {
        // Process payment payload
        return new ProcessingResult(true, &quot;Payment processed successfully&quot;);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Dynamic routing with Spring Integration</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-integration&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableIntegration
public class IntegrationConfig {
    @Bean
    public IntegrationFlow routingFlow() {
        return IntegrationFlows.from(&quot;requestChannel&quot;)
            .&lt;Message&lt;?&gt;, String&gt;route(
                message -&gt; message.getHeaders().get(&quot;type&quot;, String.class),
                mapping -&gt; mapping
                    .subFlowMapping(&quot;order&quot;, sf -&gt; sf.channel(&quot;orderChannel&quot;))
                    .subFlowMapping(&quot;invoice&quot;, sf -&gt; sf.channel(&quot;invoiceChannel&quot;))
                    .subFlowMapping(&quot;user&quot;, sf -&gt; sf.channel(&quot;userChannel&quot;))
                    .defaultSubFlowMapping(sf -&gt; sf.channel(&quot;defaultChannel&quot;))
            )
            .get();
    }

    @Bean
    public MessageChannel orderChannel() {
        return new DirectChannel();
    }

    @Bean
    public MessageChannel invoiceChannel() {
        return new DirectChannel();
    }

    @Bean
    public MessageChannel userChannel() {
        return new DirectChannel();
    }

    @Bean
    public MessageChannel defaultChannel() {
        return new DirectChannel();
    }
}

@Component
public class OrderHandler {
    @ServiceActivator(inputChannel = &quot;orderChannel&quot;)
    public void handleOrder(Message&lt;?&gt; message) {
        System.out.println(&quot;Processing order: &quot; + message.getPayload());
        // Order processing logic
    }
}

@Component
public class InvoiceHandler {
    @ServiceActivator(inputChannel = &quot;invoiceChannel&quot;)
    public void handleInvoice(Message&lt;?&gt; message) {
        System.out.println(&quot;Processing invoice: &quot; + message.getPayload());
        // Invoice processing logic
    }
}
</code></pre>
<h3 id="114-how-do-you-implement-api-throttling-and-rate-limiting-in-spring-boot">114. How do you implement API throttling and rate limiting in Spring Boot?</h3>
<p>API throttling and rate limiting:</p>
<ol>
    <li><strong>Basic in-memory rate limiter with Bucket4j</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.vladimir-bukhtoyarov&lt;/groupId&gt;
    &lt;artifactId&gt;bucket4j-core&lt;/artifactId&gt;
    &lt;version&gt;7.6.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Component
public class RateLimitingFilter extends OncePerRequestFilter {
    private final Map&lt;String, Bucket&gt; buckets = new ConcurrentHashMap&lt;&gt;();

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        String apiKey = request.getHeader(&quot;X-API-Key&quot;);
        if (apiKey == null) {
            apiKey = request.getRemoteAddr(); // Use IP address as fallback
        }

        Bucket bucket = buckets.computeIfAbsent(apiKey, this::createNewBucket);

        if (bucket.tryConsume(1)) {
            // Request allowed, proceed with the filter chain
            filterChain.doFilter(request, response);
        } else {
            // Rate limit exceeded
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);
            response.getWriter().write(&quot;{\&quot;error\&quot;:\&quot;Rate limit exceeded\&quot;,\&quot;retry_after_seconds\&quot;:60}&quot;);
        }
    }

    private Bucket createNewBucket(String apiKey) {
        // Create rate limiter with 10 requests per minute
        return Bucket.builder()
            .addLimit(Bandwidth.classic(10, Refill.greedy(10, Duration.ofMinutes(1))))
            .build();
    }
}

@Configuration
public class RateLimitingConfig {
    @Bean
    public FilterRegistrationBean&lt;RateLimitingFilter&gt; rateLimitingFilterRegistration(
            RateLimitingFilter filter) {
        FilterRegistrationBean&lt;RateLimitingFilter&gt; registration = new FilterRegistrationBean&lt;&gt;();
        registration.setFilter(filter);
        registration.addUrlPatterns(&quot;/api/*&quot;);
        registration.setOrder(Ordered.HIGHEST_PRECEDENCE + 100);
        return registration;
    }
}
</code></pre>
<ol start="2">
    <li><strong>Tiered rate limiting</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class TieredRateLimiter extends OncePerRequestFilter {
    private final UserService userService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        String apiKey = request.getHeader(&quot;X-API-Key&quot;);
        if (apiKey == null) {
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            return;
        }

        // Get user account type and limits
        User user = userService.findByApiKey(apiKey);
        if (user == null) {
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            return;
        }

        RateLimitTier tier = user.getRateLimitTier();
        Bucket bucket = createOrGetBucket(apiKey, tier);

        // Apply rate limiting
        if (bucket.tryConsume(1)) {
            filterChain.doFilter(request, response);
        } else {
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);
            response.getWriter().write(
                &quot;{\&quot;error\&quot;:\&quot;Rate limit exceeded for your tier (&quot; + tier.getName() + &quot;)\&quot;}&quot;);
        }
    }

    // Implementation details left out for brevity
}

public enum RateLimitTier {
    FREE(10, Duration.ofMinutes(1), &quot;Free&quot;),
    BASIC(50, Duration.ofMinutes(1), &quot;Basic&quot;),
    PROFESSIONAL(200, Duration.ofMinutes(1), &quot;Professional&quot;),
    ENTERPRISE(1000, Duration.ofMinutes(1), &quot;Enterprise&quot;);

    private final int requestLimit;
    private final Duration period;
    private final String name;

    // Constructor and getters
}
</code></pre>
<ol start="3">
    <li><strong>Redis-based distributed rate limiting</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Component
public class RedisRateLimiter {
    private final StringRedisTemplate redisTemplate;

    public boolean isAllowed(String key, int maxRequests, int timeWindow) {
        String redisKey = &quot;ratelimit:&quot; + key;

        long currentTime = System.currentTimeMillis() / 1000;
        long windowStart = currentTime - timeWindow;

        // Transaction to ensure atomicity
        List&lt;Object&gt; results = redisTemplate.execute(new SessionCallback&lt;List&lt;Object&gt;&gt;() {
            @Override
            @SuppressWarnings(&quot;unchecked&quot;)
            public List&lt;Object&gt; execute(RedisOperations operations) throws DataAccessException {
                operations.multi();

                // Remove tokens older than the time window
                operations.opsForZSet().removeRangeByScore(redisKey, 0, windowStart);

                // Count tokens within time window
                operations.opsForZSet().count(redisKey, windowStart, currentTime);

                // Add current request token
                operations.opsForZSet().add(redisKey, UUID.randomUUID().toString(), currentTime);

                // Set TTL on the key
                operations.expire(redisKey, timeWindow * 2, TimeUnit.SECONDS);

                return operations.exec();
            }
        });

        Long requestsInWindow = (Long) results.get(1);

        return requestsInWindow &lt;= maxRequests;
    }
}

@Component
public class RedisRateLimitFilter extends OncePerRequestFilter {
    private final RedisRateLimiter rateLimiter;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        String clientId = getClientIdentifier(request);

        if (rateLimiter.isAllowed(clientId, 10, 60)) {
            // If allowed, proceed with the request
            filterChain.doFilter(request, response);
        } else {
            // Otherwise return 429 Too Many Requests
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            response.getWriter().write(&quot;Rate limit exceeded. Try again later.&quot;);
        }
    }

    private String getClientIdentifier(HttpServletRequest request) {
        // Get API key or IP address
        String apiKey = request.getHeader(&quot;X-API-Key&quot;);
        if (apiKey != null) {
            return apiKey;
        }
        return request.getRemoteAddr();
    }
}
</code></pre>
<ol start="4">
    <li><strong>Resilience4j rate limiter</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt;
    &lt;artifactId&gt;resilience4j-ratelimiter&lt;/artifactId&gt;
    &lt;version&gt;1.7.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt;
    &lt;artifactId&gt;resilience4j-spring-boot2&lt;/artifactId&gt;
    &lt;version&gt;1.7.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class Resilience4jConfig {
    @Bean
    public RateLimiterRegistry rateLimiterRegistry() {
        return RateLimiterRegistry.of(rateLimiterConfig());
    }

    @Bean
    public RateLimiterConfig rateLimiterConfig() {
        return RateLimiterConfig.custom()
            .limitForPeriod(10)
            .limitRefreshPeriod(Duration.ofMinutes(1))
            .timeoutDuration(Duration.ofMillis(100))
            .build();
    }
}

@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    private final ProductService productService;
    private final RateLimiter rateLimiter;

    public ProductController(ProductService productService, RateLimiterRegistry rateLimiterRegistry) {
        this.productService = productService;
        this.rateLimiter = rateLimiterRegistry.rateLimiter(&quot;productApi&quot;);
    }

    @GetMapping
    public ResponseEntity&lt;List&lt;Product&gt;&gt; getProducts() {
        return rateLimiter.executeSupplier(() -&gt; {
            List&lt;Product&gt; products = productService.getAllProducts();
            return ResponseEntity.ok(products);
        });
    }

    @GetMapping(&quot;/{id}&quot;)
    @RateLimiter(name = &quot;productApi&quot;)  // Annotation-based alternative
    public ResponseEntity&lt;Product&gt; getProduct(@PathVariable Long id) {
        Product product = productService.getProduct(id);
        return ResponseEntity.ok(product);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Spring Cloud Gateway rate limiting</strong>:</li>
</ol>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      routes:
        - id: product-service
          uri: lb://product-service
          predicates:
            - Path=/api/products/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10
                redis-rate-limiter.burstCapacity: 20
                redis-rate-limiter.requestedTokens: 1
                key-resolver: &quot;#{@apiKeyResolver}&quot;
</code></pre>
<pre><code class="language-java">@Configuration
public class GatewayConfig {
    @Bean
    public KeyResolver apiKeyResolver() {
        return exchange -&gt; {
            List&lt;String&gt; apiKeys = exchange.getRequest().getHeaders().get(&quot;X-API-Key&quot;);
            if (apiKeys != null &amp;&amp; !apiKeys.isEmpty()) {
                return Mono.just(apiKeys.get(0));
            }
            return Mono.just(exchange.getRequest().getRemoteAddress().getAddress().getHostAddress());
        };
    }
}
</code></pre>
<h3 id="115-how-do-you-handle-idempotency-in-rest-api-operations">115. How do you handle idempotency in REST API operations?</h3>
<p>Idempotency implementation strategies:</p>
<ol>
    <li><strong>Using idempotency keys for POST operations</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/payments&quot;)
public class PaymentController {
    private final PaymentService paymentService;
    private final IdempotencyKeyRepository idempotencyRepository;

    @PostMapping
    public ResponseEntity&lt;PaymentResponse&gt; createPayment(
            @RequestHeader(&quot;X-Idempotency-Key&quot;) String idempotencyKey,
            @RequestBody PaymentRequest paymentRequest) {

        // Check if we&#39;ve seen this key before
        Optional&lt;IdempotencyRecord&gt; existingRecord =
            idempotencyRepository.findByIdempotencyKey(idempotencyKey);

        if (existingRecord.isPresent()) {
            IdempotencyRecord record = existingRecord.get();

            // Return the same response as before
            return ResponseEntity.status(record.getStatusCode())
                .body(record.getResponseBody(PaymentResponse.class));
        }

        // Process the payment
        try {
            PaymentResponse response = paymentService.processPayment(paymentRequest);

            // Store the idempotency record
            IdempotencyRecord record = new IdempotencyRecord();
            record.setIdempotencyKey(idempotencyKey);
            record.setRequest(paymentRequest);
            record.setResponseBody(response);
            record.setStatusCode(HttpStatus.CREATED.value());
            record.setCreatedAt(LocalDateTime.now());
            idempotencyRepository.save(record);

            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (Exception e) {
            // Handle error response recording
            IdempotencyRecord record = new IdempotencyRecord();
            record.setIdempotencyKey(idempotencyKey);
            record.setRequest(paymentRequest);
            record.setResponseBody(new ErrorResponse(e.getMessage()));
            record.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
            record.setCreatedAt(LocalDateTime.now());
            idempotencyRepository.save(record);

            throw e;
        }
    }
}
</code></pre>
<ol start="2">
    <li><strong>Entity lookup before creation</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/orders&quot;)
public class OrderController {
    private final OrderService orderService;
    private final OrderRepository orderRepository;

    @PostMapping
    public ResponseEntity&lt;Order&gt; createOrder(@RequestBody OrderRequest orderRequest) {
        // Check if order with same client reference already exists
        String clientReference = orderRequest.getClientReference();
        if (clientReference != null) {
            Optional&lt;Order&gt; existingOrder = orderRepository.findByClientReference(clientReference);

            if (existingOrder.isPresent()) {
                // Return existing order instead of creating a new one
                return ResponseEntity.ok(existingOrder.get());
            }
        }

        // Create new order
        Order newOrder = orderService.createOrder(orderRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(newOrder);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Using ETag for conditional requests</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    private final ProductService productService;

    @PutMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;Product&gt; updateProduct(
            @PathVariable Long id,
            @RequestBody Product product,
            @RequestHeader(value = &quot;If-Match&quot;, required = false) String ifMatch) {

        // Get current product version
        Product existingProduct = productService.findById(id);
        String currentEtag = generateEtag(existingProduct);

        // If If-Match header is provided, validate it
        if (ifMatch != null &amp;&amp; !ifMatch.equals(currentEtag)) {
            return ResponseEntity.status(HttpStatus.PRECONDITION_FAILED).build();
        }

        // Update product
        product.setId(id);
        Product updatedProduct = productService.save(product);

        // Generate new ETag
        String newEtag = generateEtag(updatedProduct);

        return ResponseEntity.ok()
                .eTag(newEtag)
                .body(updatedProduct);
    }

    @GetMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;Product&gt; getProduct(
            @PathVariable Long id,
            @RequestHeader(value = &quot;If-None-Match&quot;, required = false) String ifNoneMatch) {

        Product product = productService.findById(id);
        String etag = generateEtag(product);

        // If ETag matches, return 304 Not Modified
        if (ifNoneMatch != null &amp;&amp; ifNoneMatch.equals(etag)) {
            return ResponseEntity.status(HttpStatus.NOT_MODIFIED).build();
        }

        return ResponseEntity.ok()
                .eTag(etag)
                .body(product);
    }

    private String generateEtag(Product product) {
        // Generate ETag based on product state (could use version, timestamp, hash, etc.)
        return &quot;\&quot;&quot; + product.getVersion() + &quot;\&quot;&quot;;
    }
}
</code></pre>
<ol start="4">
    <li><strong>Database constraints for uniqueness</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Table(
    name = &quot;payments&quot;,
    uniqueConstraints = @UniqueConstraint(columnNames = {&quot;client_reference_id&quot;})
)
public class Payment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = &quot;client_reference_id&quot;)
    private String clientReferenceId;

    private BigDecimal amount;
    private String currency;

    // Other fields, getters, setters
}

@Service
@Transactional
public class PaymentService {
    private final PaymentRepository paymentRepository;

    public Payment createPayment(PaymentRequest request) {
        try {
            // Attempt to create with client reference ID
            Payment payment = new Payment();
            payment.setClientReferenceId(request.getClientReferenceId());
            payment.setAmount(request.getAmount());
            payment.setCurrency(request.getCurrency());

            return paymentRepository.save(payment);
        } catch (DataIntegrityViolationException e) {
            // Handle unique constraint violation
            if (isDuplicateKeyViolation(e)) {
                // Return existing payment
                return paymentRepository.findByClientReferenceId(request.getClientReferenceId())
                        .orElseThrow(() -&gt; new RuntimeException(&quot;Unexpected error&quot;));
            }
            throw e;
        }
    }

    private boolean isDuplicateKeyViolation(DataIntegrityViolationException e) {
        // Check exception for unique constraint violation
        return e.getMostSpecificCause().getMessage().contains(&quot;client_reference_id&quot;);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Distributed locking for concurrent operations</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class InventoryService {
    private final RedisLockRegistry lockRegistry;
    private final InventoryRepository inventoryRepository;

    public boolean reserveInventory(String productId, int quantity) {
        String lockKey = &quot;inventory:&quot; + productId;
        Lock lock = lockRegistry.obtain(lockKey);

        try {
            // Try to acquire lock with timeout
            if (!lock.tryLock(5, TimeUnit.SECONDS)) {
                throw new ResourceLockedException(&quot;Could not acquire lock for product &quot; + productId);
            }

            // Critical section - check and update inventory
            Inventory inventory = inventoryRepository.findByProductId(productId);

            if (inventory.getAvailableQuantity() &lt; quantity) {
                return false;
            }

            // Update inventory
            inventory.setAvailableQuantity(inventory.getAvailableQuantity() - quantity);
            inventoryRepository.save(inventory);

            return true;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(&quot;Operation interrupted&quot;, e);
        } finally {
            try {
                lock.unlock();
            } catch (IllegalMonitorStateException e) {
                // Lock was not held by this thread - could be due to timeout
            }
        }
    }
}
</code></pre>
<ol start="6">
    <li><strong>Implementing a transaction log</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Table(name = &quot;transaction_log&quot;)
public class TransactionLog {
    @Id
    private String transactionId;

    private String operation;
    private String entityType;
    private String entityId;
    private String requestBody;
    private String responseBody;
    private Integer statusCode;
    private LocalDateTime timestamp;

    // Getters and setters
}

@Repository
public interface TransactionLogRepository extends JpaRepository&lt;TransactionLog, String&gt; {
}

@Aspect
@Component
public class TransactionLogAspect {
    private final TransactionLogRepository logRepository;

    @Around(&quot;@annotation(com.example.annotation.Idempotent)&quot;)
    public Object logTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
        // Extract transaction ID from method arguments
        String transactionId = extractTransactionId(joinPoint.getArgs());

        // Check if transaction was already processed
        Optional&lt;TransactionLog&gt; existingLog = logRepository.findById(transactionId);
        if (existingLog.isPresent()) {
            // Return the previous response
            return deserializeResponse(existingLog.get().getResponseBody());
        }

        // Execute the method
        Object result = joinPoint.proceed();

        // Log the transaction
        TransactionLog log = new TransactionLog();
        log.setTransactionId(transactionId);
        log.setOperation(joinPoint.getSignature().getName());
        log.setRequestBody(serializeRequest(joinPoint.getArgs()));
        log.setResponseBody(serializeResponse(result));
        log.setStatusCode(200);  // Simplified
        log.setTimestamp(LocalDateTime.now());

        logRepository.save(log);

        return result;
    }

    // Implementation details left out for brevity
}
</code></pre>
<ol start="7">
    <li><strong>Conditional update with optimistic locking</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/stocks&quot;)
public class StockController {
    private final StockService stockService;

    @PutMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;Stock&gt; updateStock(
            @PathVariable Long id,
            @RequestBody StockUpdate update) {
        try {
            Stock updatedStock = stockService.updateStock(id, update.getQuantity());
            return ResponseEntity.ok(updatedStock);
        } catch (OptimisticLockingFailureException e) {
            return ResponseEntity
                .status(HttpStatus.CONFLICT)
                .body(null);
        }
    }
}

@Service
@Transactional
public class StockService {
    private final StockRepository stockRepository;

    public Stock updateStock(Long id, int quantityChange) {
        // The @Version field ensures optimistic locking
        Stock stock = stockRepository.findById(id)
            .orElseThrow(() -&gt; new StockNotFoundException(id));

        stock.setQuantity(stock.getQuantity() + quantityChange);

        return stockRepository.save(stock);
    }
}

@Entity
public class Stock {
    @Id
    private Long id;
    private String productId;
    private int quantity;

    @Version
    private Long version;

    // Getters and setters
}
</code></pre>
<ol start="8">
    <li><strong>Using PUT semantics correctly</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/configurations&quot;)
public class ConfigurationController {
    private final ConfigurationService configService;

    @PutMapping(&quot;/{key}&quot;)
    public ResponseEntity&lt;Configuration&gt; setConfiguration(
            @PathVariable String key,
            @RequestBody ConfigurationValue value) {

        // PUT is idempotent by nature - same request will produce same result
        Configuration config = configService.setConfiguration(key, value.getValue());
        return ResponseEntity.ok(config);
    }
}

@Service
public class ConfigurationService {
    private final ConfigurationRepository configRepository;

    public Configuration setConfiguration(String key, String value) {
        // Find or create
        Configuration config = configRepository.findById(key)
            .orElse(new Configuration(key));

        // Set value
        config.setValue(value);

        // Save (update or create)
        return configRepository.save(config);
    }
}

## Advanced Patterns and Techniques

### 116. How do you implement the Circuit Breaker pattern in Spring Boot?
**Answer:** The Circuit Breaker pattern prevents cascade failures by failing fast and providing fallbacks. In Spring Boot, it&#39;s implemented using Resilience4j:

1. **Add dependency**:
```xml
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-circuitbreaker-resilience4j&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Bean
public Customizer&lt;Resilience4JCircuitBreakerFactory&gt; defaultCustomizer() {
    return factory -&gt; factory.configureDefault(id -&gt; new Resilience4JConfigBuilder(id)
        .circuitBreakerConfig(CircuitBreakerConfig.custom()
            .failureRateThreshold(50)
            .waitDurationInOpenState(Duration.ofSeconds(10))
            .permittedNumberOfCallsInHalfOpenState(5)
            .slidingWindowSize(10)
            .build())
        .build());
}
</code></pre>
<ol start="3">
    <li><strong>Usage</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class PaymentService {
    private final CircuitBreakerFactory circuitBreakerFactory;

    public PaymentService(CircuitBreakerFactory circuitBreakerFactory) {
        this.circuitBreakerFactory = circuitBreakerFactory;
    }

    public PaymentResponse processPayment(PaymentRequest request) {
        CircuitBreaker circuitBreaker = circuitBreakerFactory.create(&quot;payment&quot;);

        return circuitBreaker.run(
            () -&gt; paymentGateway.processPayment(request),
            throwable -&gt; fallbackPayment(request, throwable)
        );
    }

    private PaymentResponse fallbackPayment(PaymentRequest request, Throwable t) {
        // Fallback logic
        return new PaymentResponse(&quot;offline-&quot; + UUID.randomUUID().toString());
    }
}
</code></pre>
<ol start="4">
    <li><strong>Annotation-based approach</strong>:</li>
</ol>
<pre><code class="language-java">@CircuitBreaker(name = &quot;paymentService&quot;, fallbackMethod = &quot;fallbackPayment&quot;)
public PaymentResponse processPayment(PaymentRequest request) {
    return paymentGateway.processPayment(request);
}

private PaymentResponse fallbackPayment(PaymentRequest request, Exception e) {
    return new PaymentResponse(&quot;offline-&quot; + UUID.randomUUID().toString());
}
</code></pre>
<h3 id="117-what-are-the-different-ways-to-secure-a-rest-api-in-spring-boot">117. What are the different ways to secure a REST API in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot REST API security can be implemented in several ways:</p>
<ol>
    <li><strong>Basic Authentication</strong>:</li>
</ol>
<pre><code class="language-java">@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .httpBasic(Customizer.withDefaults())
        .authorizeHttpRequests(auth -&gt; {
            auth.requestMatchers(&quot;/api/public/**&quot;).permitAll();
            auth.anyRequest().authenticated();
        });
    return http.build();
}
</code></pre>
<ol start="2">
    <li><strong>JWT Authentication</strong>:</li>
</ol>
<pre><code class="language-java">@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .csrf().disable()
        .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
        .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
        .authorizeHttpRequests(auth -&gt; {
            auth.requestMatchers(&quot;/auth/**&quot;).permitAll();
            auth.anyRequest().authenticated();
        });
    return http.build();
}
</code></pre>
<ol start="3">
    <li><strong>OAuth2 Resource Server</strong>:</li>
</ol>
<pre><code class="language-java">@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(Customizer.withDefaults()))
        .authorizeHttpRequests(auth -&gt; {
            auth.anyRequest().authenticated();
        });
    return http.build();
}
</code></pre>
<ol start="4">
    <li><strong>API Key Authentication</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ApiKeyAuthFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        String apiKey = request.getHeader(&quot;X-API-Key&quot;);
        if (apiKey == null || !apiKey.equals(expectedApiKey)) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }
        chain.doFilter(request, response);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Method-level security</strong>:</li>
</ol>
<pre><code class="language-java">@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)
@GetMapping(&quot;/sensitive-data&quot;)
public SensitiveData getSensitiveData() {
    return sensitiveDataService.getData();
}
</code></pre>
<h3 id="118-how-do-you-handle-database-migrations-in-spring-boot-applications">118. How do you handle database migrations in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Database migrations in Spring Boot are typically handled using Flyway or Liquibase:</p>
<p><strong>Flyway:</strong></p>
<ol>
    <li><strong>Add dependency</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;
    &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Configuration</strong>:</li>
</ol>
<pre><code class="language-properties"># application.properties
spring.flyway.url=jdbc:mysql://localhost:3306/mydb
spring.flyway.user=root
spring.flyway.password=secret
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
</code></pre>
<ol start="3">
    <li><strong>Migration files</strong>:</li>
</ol>
<pre><code class="language-sql">-- V1__Create_tables.sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(100) NOT NULL,
    email VARCHAR(100) NOT NULL
);

-- V2__Add_roles.sql
CREATE TABLE roles (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL
);
</code></pre>
<p><strong>Liquibase:</strong></p>
<ol>
    <li><strong>Add dependency</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.liquibase&lt;/groupId&gt;
    &lt;artifactId&gt;liquibase-core&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Configuration</strong>:</li>
</ol>
<pre><code class="language-properties"># application.properties
spring.liquibase.change-log=classpath:db/changelog/db.changelog-master.xml
</code></pre>
<ol start="3">
    <li><strong>Changelog file</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;!-- db.changelog-master.xml --&gt;
&lt;databaseChangeLog
    xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog
                        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.4.xsd&quot;&gt;

    &lt;changeSet id=&quot;1&quot; author=&quot;developer&quot;&gt;
        &lt;createTable tableName=&quot;users&quot;&gt;
            &lt;column name=&quot;id&quot; type=&quot;bigint&quot; autoIncrement=&quot;true&quot;&gt;
                &lt;constraints primaryKey=&quot;true&quot; nullable=&quot;false&quot;/&gt;
            &lt;/column&gt;
            &lt;column name=&quot;username&quot; type=&quot;varchar(100)&quot;/&gt;
            &lt;column name=&quot;email&quot; type=&quot;varchar(100)&quot;/&gt;
        &lt;/createTable&gt;
    &lt;/changeSet&gt;
&lt;/databaseChangeLog&gt;
</code></pre>
<h3 id="119-what-is-the-role-of-spring-boot-starters-and-how-would-you-create-a-custom-starter">119. What is the role of Spring Boot Starters and how would you create a custom starter?</h3>
<p><strong>Answer:</strong> Spring Boot Starters are dependency descriptors that simplify dependency management and auto-configuration.</p>
<p><strong>Role of starters:</strong></p>
<ul>
    <li>Bundle related dependencies together</li>
    <li>Provide auto-configuration for common use cases</li>
    <li>Simplify build configuration</li>
    <li>Ensure compatible versions across dependencies</li>
</ul>
<p><strong>Creating a custom starter:</strong></p>
<ol>
    <li><p><strong>Create two separate modules</strong>:</p>
        <ul>
            <li><code>custom-spring-boot-autoconfigure</code>: contains auto-configuration code</li>
            <li><code>custom-spring-boot-starter</code>: empty module that depends on the auto-configuration module</li>
        </ul>
    </li>
    <li><p><strong>Auto-configuration module</strong>:</p>
    </li>
</ol>
<pre><code class="language-java">// Define properties class
@ConfigurationProperties(prefix = &quot;custom&quot;)
public class CustomProperties {
    private boolean enabled = true;
    private String message = &quot;Hello&quot;;
    // getters and setters
}

// Define service class
public class CustomService {
    private final String message;

    public CustomService(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }
}

// Define auto-configuration class
@Configuration
@ConditionalOnClass(CustomService.class)
@EnableConfigurationProperties(CustomProperties.class)
@ConditionalOnProperty(prefix = &quot;custom&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
public class CustomAutoConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public CustomService customService(CustomProperties properties) {
        return new CustomService(properties.getMessage());
    }
}
</code></pre>
<ol start="3">
    <li><strong>Register auto-configuration</strong> (Spring Boot 3.x):
        Create <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>:</li>
</ol>
<pre><code>com.example.CustomAutoConfiguration
</code></pre>
<ol start="4">
    <li><strong>Starter POM</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.example&lt;/groupId&gt;
        &lt;artifactId&gt;custom-spring-boot-autoconfigure&lt;/artifactId&gt;
        &lt;version&gt;${project.version}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h3 id="120-explain-the-conditional-annotation-family-and-how-they-control-auto-configuration">120. Explain the @Conditional annotation family and how they control auto-configuration.</h3>
<p><strong>Answer:</strong> The @Conditional annotation family in Spring Boot controls when beans are created based on specific conditions:</p>
<ol>
    <li><p><strong>@ConditionalOnClass/@ConditionalOnMissingClass</strong>:</p>
        <ul>
            <li>Creates beans only when specific classes are present/absent on the classpath</li>
            <li><code>@ConditionalOnClass(DataSource.class)</code> - Only applies if DataSource is available</li>
        </ul>
    </li>
    <li><p><strong>@ConditionalOnBean/@ConditionalOnMissingBean</strong>:</p>
        <ul>
            <li>Creates beans only when specific beans are present/absent in the application context</li>
            <li><code>@ConditionalOnMissingBean(DataSource.class)</code> - Only applies if no DataSource bean exists</li>
        </ul>
    </li>
    <li><p><strong>@ConditionalOnProperty</strong>:</p>
        <ul>
            <li>Creates beans based on property values</li>
            <li><code>@ConditionalOnProperty(name = &quot;app.feature.enabled&quot;, havingValue = &quot;true&quot;)</code> - Only applies if the property has that value</li>
        </ul>
    </li>
    <li><p><strong>@ConditionalOnResource</strong>:</p>
        <ul>
            <li>Creates beans if a resource is available</li>
            <li><code>@ConditionalOnResource(resources = &quot;classpath:config/datasource.properties&quot;)</code> - Only applies if the resource exists</li>
        </ul>
    </li>
    <li><p><strong>@ConditionalOnWebApplication/@ConditionalOnNotWebApplication</strong>:</p>
        <ul>
            <li>Creates beans based on whether it&#39;s a web application</li>
        </ul>
    </li>
    <li><p><strong>@ConditionalOnExpression</strong>:</p>
        <ul>
            <li>Creates beans based on SpEL expressions</li>
            <li><code>@ConditionalOnExpression(&quot;${app.scheduling.enabled:true} &amp;&amp; ${app.region} == &#39;us-east&#39;&quot;)</code> - Uses expression result</li>
        </ul>
    </li>
    <li><p><strong>@ConditionalOnJava</strong>:</p>
        <ul>
            <li>Creates beans based on Java version</li>
            <li><code>@ConditionalOnJava(JavaVersion.SEVENTEEN)</code> - Only applies on Java 17</li>
        </ul>
    </li>
    <li><p><strong>@ConditionalOnCloudPlatform</strong>:</p>
        <ul>
            <li>Creates beans based on the cloud platform</li>
            <li><code>@ConditionalOnCloudPlatform(CloudPlatform.CLOUD_FOUNDRY)</code> - Only applies on that platform</li>
        </ul>
    </li>
</ol>
<p><strong>Example in auto-configuration:</strong></p>
<pre><code class="language-java">@Configuration
@ConditionalOnClass(DataSource.class)
@ConditionalOnMissingBean(name = &quot;primaryDataSource&quot;)
@ConditionalOnProperty(prefix = &quot;app.datasource&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;)
public class DataSourceAutoConfiguration {
    @Bean
    public DataSource dataSource() {
        // Create datasource
    }
}
</code></pre>
<h3 id="121-what-is-spring-boot-actuator-and-how-would-you-use-it-to-monitor-your-application">121. What is Spring Boot Actuator and how would you use it to monitor your application?</h3>
<p><strong>Answer:</strong> Spring Boot Actuator provides production-ready features for monitoring and managing applications through HTTP endpoints or JMX.</p>
<ol>
    <li><strong>Setup</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Basic configuration</strong>:</li>
</ol>
<pre><code class="language-properties"># Enable specific endpoints
management.endpoints.web.exposure.include=health,info,metrics,loggers
management.endpoint.health.show-details=always
management.endpoint.health.show-components=always

# Change base path
management.endpoints.web.base-path=/management
</code></pre>
<ol start="3">
    <li><p><strong>Key endpoints</strong>:</p>
        <ul>
            <li><code>/actuator/health</code> - Application health status</li>
            <li><code>/actuator/info</code> - Application information</li>
            <li><code>/actuator/metrics</code> - Application metrics</li>
            <li><code>/actuator/loggers</code> - View and modify logger levels</li>
            <li><code>/actuator/prometheus</code> - Prometheus metrics format</li>
            <li><code>/actuator/env</code> - Environment variables</li>
            <li><code>/actuator/httptrace</code> - HTTP request/response info</li>
        </ul>
    </li>
    <li><p><strong>Custom health indicator</strong>:</p>
    </li>
</ol>
<pre><code class="language-java">@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    private final DataSource dataSource;

    @Override
    public Health health() {
        try (Connection conn = dataSource.getConnection()) {
            if (conn.isValid(1)) {
                return Health.up()
                    .withDetail(&quot;database&quot;, &quot;Available&quot;)
                    .build();
            } else {
                return Health.down()
                    .withDetail(&quot;database&quot;, &quot;Unavailable&quot;)
                    .build();
            }
        } catch (Exception e) {
            return Health.down(e).build();
        }
    }
}
</code></pre>
<ol start="5">
    <li><strong>Custom metrics</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderService {
    private final Counter orderCounter;

    public OrderService(MeterRegistry registry) {
        this.orderCounter = registry.counter(&quot;orders.created&quot;);
    }

    public Order createOrder(Order order) {
        // Create order logic
        orderCounter.increment();
        return order;
    }
}
</code></pre>
<ol start="6">
    <li><strong>Custom info contributor</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class BuildInfoContributor implements InfoContributor {
    @Override
    public void contribute(Info.Builder builder) {
        Map&lt;String, Object&gt; buildInfo = new HashMap&lt;&gt;();
        buildInfo.put(&quot;version&quot;, &quot;1.0.0&quot;);
        buildInfo.put(&quot;buildDate&quot;, &quot;2023-07-15&quot;);
        builder.withDetail(&quot;build&quot;, buildInfo);
    }
}
</code></pre>
<ol start="7">
    <li><strong>Security for Actuator endpoints</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class ActuatorSecurity {
    @Bean
    public SecurityFilterChain actuatorSecurity(HttpSecurity http) throws Exception {
        http
            .securityMatcher(&quot;/management/**&quot;)
            .authorizeHttpRequests(auth -&gt; {
                auth.requestMatchers(&quot;/management/health/**&quot;).permitAll();
                auth.requestMatchers(&quot;/management/**&quot;).hasRole(&quot;ADMIN&quot;);
            })
            .httpBasic(withDefaults());
        return http.build();
    }
}
</code></pre>
<h3 id="122-how-do-you-implement-bulk-operations-for-better-performance-in-spring-boot">122. How do you implement bulk operations for better performance in Spring Boot?</h3>
<p><strong>Answer:</strong> Bulk operations in Spring Boot can be implemented through several methods:</p>
<ol>
    <li><strong>JPA Batch Inserts/Updates</strong>:</li>
</ol>
<pre><code class="language-properties"># Enable JDBC batching
spring.jpa.properties.hibernate.jdbc.batch_size=50
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.batch_versioned_data=true
</code></pre>
<pre><code class="language-java">@Service
public class ProductService {
    private final ProductRepository repository;

    @Transactional
    public void saveInBulk(List&lt;Product&gt; products) {
        // Hibernate will batch these inserts
        for (Product product : products) {
            repository.save(product);
        }
    }
}
</code></pre>
<ol start="2">
    <li><strong>JDBC Batch Operations</strong>:</li>
</ol>
<pre><code class="language-java">@Repository
public class BulkProductRepository {
    private final JdbcTemplate jdbcTemplate;

    public int[] bulkUpdatePrices(List&lt;ProductUpdate&gt; updates) {
        return jdbcTemplate.batchUpdate(
            &quot;UPDATE products SET price = ? WHERE id = ?&quot;,
            new BatchPreparedStatementSetter() {
                @Override
                public void setValues(PreparedStatement ps, int i) throws SQLException {
                    ProductUpdate update = updates.get(i);
                    ps.setBigDecimal(1, update.getPrice());
                    ps.setLong(2, update.getId());
                }

                @Override
                public int getBatchSize() {
                    return updates.size();
                }
            });
    }
}
</code></pre>
<ol start="3">
    <li><strong>Native bulk queries</strong>:</li>
</ol>
<pre><code class="language-java">@Repository
public interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {
    @Modifying
    @Query(value = &quot;UPDATE products SET active = false WHERE category_id = ?1&quot;, nativeQuery = true)
    int bulkDeactivateByCategory(Long categoryId);

    @Modifying
    @Query(value = &quot;DELETE FROM products WHERE last_updated &lt; ?1&quot;, nativeQuery = true)
    int bulkDeleteOldProducts(LocalDate date);
}
</code></pre>
<ol start="4">
    <li><strong>Spring Data JPA bulk methods</strong>:</li>
</ol>
<pre><code class="language-java">@Repository
public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {
    // Bulk delete without loading entities
    long deleteByStatus(OrderStatus status);

    // Bulk update without loading entities
    @Modifying
    @Query(&quot;UPDATE Order o SET o.status = :newStatus WHERE o.status = :oldStatus&quot;)
    int updateOrderStatus(@Param(&quot;oldStatus&quot;) OrderStatus oldStatus,
                         @Param(&quot;newStatus&quot;) OrderStatus newStatus);
}
</code></pre>
<ol start="5">
    <li><strong>Bulk operations with Specification API</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class BulkUserService {
    private final UserRepository repository;

    @Transactional
    public int bulkDeleteInactive(int inactiveDays) {
        LocalDate cutoffDate = LocalDate.now().minusDays(inactiveDays);

        Specification&lt;User&gt; spec = (root, query, cb) -&gt;
            cb.and(
                cb.equal(root.get(&quot;active&quot;), false),
                cb.lessThan(root.get(&quot;lastLogin&quot;), cutoffDate)
            );

        List&lt;User&gt; usersToDelete = repository.findAll(spec);
        repository.deleteAll(usersToDelete);

        return usersToDelete.size();
    }
}
</code></pre>
<h3 id="123-what-are-the-best-practices-for-writing-unit-and-integration-tests-in-spring-boot">123. What are the best practices for writing unit and integration tests in Spring Boot?</h3>
<p><strong>Answer:</strong> Best practices for testing in Spring Boot:</p>
<p><strong>Unit Testing:</strong></p>
<ol>
    <li><strong>Use appropriate annotations</strong>:</li>
</ol>
<pre><code class="language-java">@ExtendWith(MockitoExtension.class)
public class UserServiceTest {
    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    void shouldReturnUserWhenValidId() {
        // given
        User expected = new User(1L, &quot;John&quot;);
        when(userRepository.findById(1L)).thenReturn(Optional.of(expected));

        // when
        User actual = userService.getUserById(1L);

        // then
        assertEquals(expected, actual);
        verify(userRepository).findById(1L);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Test specific slices with targeted annotations</strong>:</li>
</ol>
<pre><code class="language-java">@WebMvcTest(UserController.class)
public class UserControllerTest {
    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;

    @Test
    void shouldReturnUser() throws Exception {
        // given
        User user = new User(1L, &quot;John&quot;);
        when(userService.getUserById(1L)).thenReturn(user);

        // when/then
        mockMvc.perform(get(&quot;/api/users/1&quot;))
            .andExpect(status().isOk())
            .andExpect(jsonPath(&quot;$.id&quot;).value(1))
            .andExpect(jsonPath(&quot;$.name&quot;).value(&quot;John&quot;));
    }
}
</code></pre>
<ol start="3">
    <li><strong>Use AssertJ for fluent assertions</strong>:</li>
</ol>
<pre><code class="language-java">@Test
void shouldFilterActiveUsers() {
    // given
    List&lt;User&gt; users = Arrays.asList(
        new User(1L, &quot;John&quot;, true),
        new User(2L, &quot;Jane&quot;, false),
        new User(3L, &quot;Bob&quot;, true)
    );

    // when
    List&lt;User&gt; activeUsers = userService.filterActiveUsers(users);

    // then
    assertThat(activeUsers)
        .hasSize(2)
        .extracting(User::getName)
        .containsExactlyInAnyOrder(&quot;John&quot;, &quot;Bob&quot;)
        .doesNotContain(&quot;Jane&quot;);
}
</code></pre>
<p><strong>Integration Testing:</strong></p>
<ol>
    <li><strong>Use @SpringBootTest for full integration tests</strong>:</li>
</ol>
<pre><code class="language-java">@SpringBootTest
@AutoConfigureMockMvc
public class UserIntegrationTest {
    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    @BeforeEach
    void setup() {
        userRepository.deleteAll();
        userRepository.save(new User(1L, &quot;John&quot;));
    }

    @Test
    void shouldCreateUser() throws Exception {
        mockMvc.perform(post(&quot;/api/users&quot;)
            .contentType(MediaType.APPLICATION_JSON)
            .content(&quot;{\&quot;name\&quot;:\&quot;Jane\&quot;}&quot;))
            .andExpect(status().isCreated())
            .andExpect(jsonPath(&quot;$.name&quot;).value(&quot;Jane&quot;));

        assertThat(userRepository.findAll()).hasSize(2);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Use TestContainers for external dependencies</strong>:</li>
</ol>
<pre><code class="language-java">@SpringBootTest
@Testcontainers
public class RepositoryIntegrationTest {
    @Container
    static PostgreSQLContainer&lt;?&gt; postgres = new PostgreSQLContainer&lt;&gt;(&quot;postgres:14&quot;)
        .withDatabaseName(&quot;test-db&quot;)
        .withUsername(&quot;test&quot;)
        .withPassword(&quot;test&quot;);

    @DynamicPropertySource
    static void postgresProperties(DynamicPropertyRegistry registry) {
        registry.add(&quot;spring.datasource.url&quot;, postgres::getJdbcUrl);
        registry.add(&quot;spring.datasource.username&quot;, postgres::getUsername);
        registry.add(&quot;spring.datasource.password&quot;, postgres::getPassword);
    }

    @Autowired
    private UserRepository userRepository;

    @Test
    void shouldSaveAndRetrieveUser() {
        // Integration test with real PostgreSQL database
        User user = new User(null, &quot;John&quot;);
        User saved = userRepository.save(user);

        assertThat(saved).isNotNull();
        assertThat(saved.getId()).isNotNull();
        assertThat(userRepository.findById(saved.getId())).isPresent();
    }
}
</code></pre>
<ol start="3">
    <li><strong>Testing REST endpoints with RestTemplate or WebTestClient</strong>:</li>
</ol>
<pre><code class="language-java">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
public class UserApiIntegrationTest {
    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    void shouldReturnUserById() {
        // Test actual HTTP request
        ResponseEntity&lt;User&gt; response = restTemplate.getForEntity(&quot;/api/users/1&quot;, User.class);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getId()).isEqualTo(1L);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Use @DataJpaTest for repository layer</strong>:</li>
</ol>
<pre><code class="language-java">@DataJpaTest
public class UserRepositoryTest {
    @Autowired
    private UserRepository userRepository;

    @Test
    void shouldFindByEmail() {
        // given
        User user = new User(null, &quot;John&quot;, &quot;john@example.com&quot;);
        userRepository.save(user);

        // when
        Optional&lt;User&gt; found = userRepository.findByEmail(&quot;john@example.com&quot;);

        // then
        assertThat(found).isPresent();
        assertThat(found.get().getName()).isEqualTo(&quot;John&quot;);
    }
}
</code></pre>
<h3 id="124-how-do-you-handle-database-transactions-in-spring-boot-applications">124. How do you handle database transactions in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Spring Boot offers several ways to handle database transactions:</p>
<ol>
    <li><strong>Using @Transactional annotation</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class UserService {
    private final UserRepository userRepository;
    private final AuditService auditService;

    @Transactional  // Wraps all operations in a transaction
    public User createUser(User user) {
        User savedUser = userRepository.save(user);
        auditService.logUserCreated(savedUser);
        return savedUser;
    }

    @Transactional(readOnly = true)  // Optimized for read operations
    public List&lt;User&gt; getAllUsers() {
        return userRepository.findAll();
    }

    @Transactional(timeout = 5)  // Timeout in seconds
    public void processLargeData() {
        // Long operation
    }

    @Transactional(rollbackFor = {CustomException.class})  // Custom rollback rules
    public void operationWithCustomRollback() throws CustomException {
        // Operation that may throw CustomException
    }
}
</code></pre>
<ol start="2">
    <li><strong>Programmatic transaction management</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderService {
    private final TransactionTemplate transactionTemplate;
    private final OrderRepository orderRepository;
    private final PaymentService paymentService;

    public Order createOrder(final Order order) {
        return transactionTemplate.execute(status -&gt; {
            try {
                Order savedOrder = orderRepository.save(order);
                paymentService.processPayment(savedOrder);
                return savedOrder;
            } catch (PaymentException e) {
                status.setRollbackOnly();
                throw e;
            }
        });
    }
}
</code></pre>
<ol start="3">
    <li><strong>Transaction propagation options</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderService {
    private final OrderRepository orderRepository;
    private final NotificationService notificationService;

    @Transactional
    public Order createOrder(Order order) {
        return orderRepository.save(order);
    }
}

@Service
public class NotificationService {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void sendNotification(String message) {
        // Always runs in a new transaction
    }

    @Transactional(propagation = Propagation.MANDATORY)
    public void recordActivity(String activity) {
        // Must be called from an existing transaction
    }

    @Transactional(propagation = Propagation.NEVER)
    public void logEvent(String event) {
        // Must not be called from within a transaction
    }
}
</code></pre>
<ol start="4">
    <li><strong>Transaction isolation levels</strong>:</li>
</ol>
<pre><code class="language-java">@Transactional(isolation = Isolation.READ_COMMITTED)
public void updateInventory(Long productId, int quantity) {
    // Uses READ_COMMITTED isolation level
}

@Transactional(isolation = Isolation.SERIALIZABLE)
public void transferFunds(Long sourceAccount, Long targetAccount, BigDecimal amount) {
    // Uses SERIALIZABLE isolation level (highest)
}
</code></pre>
<ol start="5">
    <li><strong>Custom transaction management with ChainedTransactionManager</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class TransactionConfig {
    @Bean
    public PlatformTransactionManager chainedTransactionManager(
            DataSourceTransactionManager dsTxManager,
            JpaTransactionManager jpaTxManager) {
        return new ChainedTransactionManager(dsTxManager, jpaTxManager);
    }
}
</code></pre>
<ol start="6">
    <li><strong>Exception handling and transaction status</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class PaymentService {
    @Transactional(noRollbackFor = ValidationException.class)
    public Payment processPayment(Payment payment) {
        if (!isValid(payment)) {
            // Transaction won&#39;t roll back for this exception
            throw new ValidationException(&quot;Invalid payment&quot;);
        }

        // Business logic
        return paymentRepository.save(payment);
    }

    @Transactional(rollbackFor = Exception.class)
    public void criticalOperation() {
        // Roll back on any exception, even unchecked ones
    }
}
</code></pre>
<h3 id="125-how-do-you-implement-lazy-loading-in-spring-boot-applications">125. How do you implement lazy loading in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Lazy loading in Spring Boot can be implemented in several areas:</p>
<ol>
    <li><strong>JPA Entity Relationships</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
public class User {
    @Id
    private Long id;
    private String name;

    @OneToMany(mappedBy = &quot;user&quot;, fetch = FetchType.LAZY)
    private List&lt;Order&gt; orders;

    // getters and setters
}

@Entity
public class Order {
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;user_id&quot;)
    private User user;

    // getters and setters
}
</code></pre>
<ol start="2">
    <li><strong>Handling LazyInitializationException</strong>:</li>
</ol>
<pre><code class="language-java">@Service
@Transactional(readOnly = true)  // Keep transaction open
public class UserService {
    public List&lt;Order&gt; getUserOrders(Long userId) {
        User user = userRepository.findById(userId).orElseThrow();
        return user.getOrders();  // Lazy collection accessed within transaction
    }
}
</code></pre>
<ol start="3">
    <li><strong>Using Entity Graphs</strong>:</li>
</ol>
<pre><code class="language-java">public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {
    // Load specific relationships eagerly
    @EntityGraph(attributePaths = {&quot;items&quot;, &quot;customer&quot;})
    Optional&lt;Order&gt; findWithDetailById(Long id);

    // Named entity graph
    @EntityGraph(value = &quot;Order.withItems&quot;)
    List&lt;Order&gt; findByStatus(OrderStatus status);
}

@Entity
@NamedEntityGraph(
    name = &quot;Order.withItems&quot;,
    attributeNodes = @NamedAttributeNode(&quot;items&quot;)
)
public class Order {
    // entity definition
}
</code></pre>
<ol start="4">
    <li><strong>Using DTO projections</strong>:</li>
</ol>
<pre><code class="language-java">public interface OrderSummaryDto {
    Long getId();
    LocalDate getOrderDate();
    String getCustomerName();
}

public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {
    // Interface-based projection
    List&lt;OrderSummaryDto&gt; findByStatus(OrderStatus status);

    // Class-based projection
    @Query(&quot;SELECT new com.example.dto.OrderDetailDto(o.id, o.date, c.name) &quot; +
           &quot;FROM Order o JOIN o.customer c WHERE o.status = :status&quot;)
    List&lt;OrderDetailDto&gt; findOrderDetailsByStatus(@Param(&quot;status&quot;) OrderStatus status);
}
</code></pre>
<ol start="5">
    <li><strong>Bean lazy initialization</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class AppConfig {
    @Bean
    @Lazy  // Only initialized when first requested
    public ExpensiveService expensiveService() {
        return new ExpensiveServiceImpl();
    }
}

@Service
public class ProductService {
    private final ExpensiveService expensiveService;

    @Autowired
    public ProductService(@Lazy ExpensiveService expensiveService) {
        this.expensiveService = expensiveService;
    }
}
</code></pre>
<ol start="6">
    <li><strong>Open Session in View configuration</strong>:</li>
</ol>
<pre><code class="language-properties"># Disable OSIV for better control and performance
spring.jpa.open-in-view=false
</code></pre>
<ol start="7">
    <li><strong>Fetching lazy collections outside of transactions</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class UserService {
    private final EntityManager entityManager;

    public List&lt;Order&gt; getUserOrders(Long userId) {
        User user = userRepository.findById(userId).orElseThrow();

        // Initialize the collection to avoid LazyInitializationException
        Hibernate.initialize(user.getOrders());

        return user.getOrders();
    }

    public List&lt;Order&gt; getOrdersWithHibernateUtil(Long userId) {
        User user = userRepository.findById(userId).orElseThrow();

        // Alternative using EntityManager
        PersistenceUtil persistenceUtil = Persistence.getPersistenceUtil();
        if (!persistenceUtil.isLoaded(user.getOrders())) {
            entityManager.refresh(user);
        }

        return user.getOrders();
    }
}
</code></pre>
<h2 id="advanced-configuration-and-best-practices">Advanced Configuration and Best Practices</h2>
<h3 id="126-how-do-you-implement-data-auditing-in-spring-boot-jpa-applications">126. How do you implement data auditing in Spring Boot JPA applications?</h3>
<p><strong>Answer:</strong> Spring Boot provides built-in support for entity auditing through Spring Data JPA:</p>
<ol>
    <li><strong>Enable auditing</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableJpaAuditing
public class AuditConfig {
    @Bean
    public AuditorAware&lt;String&gt; auditorProvider() {
        return () -&gt; Optional.ofNullable(SecurityContextHolder.getContext())
            .map(SecurityContext::getAuthentication)
            .filter(Authentication::isAuthenticated)
            .map(Authentication::getName)
            .or(() -&gt; Optional.of(&quot;system&quot;));
    }
}
</code></pre>
<ol start="2">
    <li><strong>Create audit base class</strong>:</li>
</ol>
<pre><code class="language-java">@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class Auditable {
    @CreatedBy
    @Column(nullable = false, updatable = false)
    private String createdBy;

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdDate;

    @LastModifiedBy
    @Column(nullable = false)
    private String lastModifiedBy;

    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime lastModifiedDate;

    // Getters and setters
}
</code></pre>
<ol start="3">
    <li><strong>Apply to entities</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
public class Product extends Auditable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private BigDecimal price;

    // Other fields, getters, setters
}
</code></pre>
<h3 id="127-how-do-you-implement-custom-validation-in-spring-boot">127. How do you implement custom validation in Spring Boot?</h3>
<p><strong>Answer:</strong> Custom validation in Spring Boot can be implemented using Bean Validation API:</p>
<ol>
    <li><strong>Create custom annotation</strong>:</li>
</ol>
<pre><code class="language-java">@Target({ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueUsernameValidator.class)
public @interface UniqueUsername {
    String message() default &quot;Username already exists&quot;;
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}
</code></pre>
<ol start="2">
    <li><strong>Implement validator</strong>:</li>
</ol>
<pre><code class="language-java">public class UniqueUsernameValidator implements ConstraintValidator&lt;UniqueUsername, String&gt; {
    private final UserRepository userRepository;

    public UniqueUsernameValidator(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true; // Let @NotNull handle this
        }
        return !userRepository.existsByUsername(value);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Use in model</strong>:</li>
</ol>
<pre><code class="language-java">public class UserRegistrationDto {
    @NotBlank(message = &quot;Username is required&quot;)
    @Size(min = 4, max = 20, message = &quot;Username must be between 4 and 20 characters&quot;)
    @UniqueUsername
    private String username;

    @Email(message = &quot;Email must be valid&quot;)
    private String email;

    // Other fields, getters, setters
}
</code></pre>
<ol start="4">
    <li><strong>Class-level validation</strong>:</li>
</ol>
<pre><code class="language-java">@PasswordMatches
public class RegistrationDto {
    private String password;
    private String confirmPassword;

    // Getters and setters
}

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PasswordMatchesValidator.class)
public @interface PasswordMatches {
    String message() default &quot;Passwords don&#39;t match&quot;;
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}

public class PasswordMatchesValidator implements ConstraintValidator&lt;PasswordMatches, Object&gt; {
    @Override
    public boolean isValid(Object obj, ConstraintValidatorContext context) {
        RegistrationDto dto = (RegistrationDto) obj;
        return dto.getPassword().equals(dto.getConfirmPassword());
    }
}
</code></pre>
<h3 id="128-how-do-you-handle-scheduled-tasks-in-spring-boot">128. How do you handle scheduled tasks in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot provides several ways to implement scheduled tasks:</p>
<ol>
    <li><strong>Using @Scheduled annotation</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableScheduling
public class SchedulingConfig {
    // Configuration
}

@Component
public class ScheduledTasks {
    private final Logger log = LoggerFactory.getLogger(ScheduledTasks.class);

    @Scheduled(fixedRate = 60000)  // Run every minute
    public void reportCurrentTime() {
        log.info(&quot;Current time: {}&quot;, LocalDateTime.now());
    }

    @Scheduled(fixedDelay = 30000)  // 30 seconds after previous execution completes
    public void processQueue() {
        log.info(&quot;Processing message queue&quot;);
    }

    @Scheduled(initialDelay = 60000, fixedRate = 300000)  // 1 min initial delay, then every 5 mins
    public void scheduledTaskWithInitialDelay() {
        log.info(&quot;Task with initial delay&quot;);
    }

    @Scheduled(cron = &quot;0 0 9 * * *&quot;)  // 9:00 AM every day
    public void scheduledTaskWithCron() {
        log.info(&quot;Daily task at 9 AM&quot;);
    }

    @Scheduled(cron = &quot;${app.scheduling.cron.expression}&quot;)  // From properties
    public void scheduledTaskWithConfigurableCron() {
        log.info(&quot;Configurable scheduled task&quot;);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Dynamic task scheduling</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class DynamicSchedulerService {
    private final TaskScheduler taskScheduler;
    private ScheduledFuture&lt;?&gt; scheduledTask;

    public void startScheduleTask(long intervalMs) {
        // Cancel existing task if it exists
        cancelScheduledTask();

        // Schedule new task
        scheduledTask = taskScheduler.scheduleAtFixedRate(
            () -&gt; System.out.println(&quot;Task executed at: &quot; + System.currentTimeMillis()),
            intervalMs
        );
    }

    public void cancelScheduledTask() {
        if (scheduledTask != null) {
            scheduledTask.cancel(true);
        }
    }
}
</code></pre>
<ol start="3">
    <li><strong>Task executor configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableScheduling
public class SchedulingConfig implements SchedulingConfigurer {
    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        taskRegistrar.setScheduler(taskExecutor());
    }

    @Bean(destroyMethod = &quot;shutdown&quot;)
    public Executor taskExecutor() {
        return Executors.newScheduledThreadPool(10);
    }
}
</code></pre>
<h3 id="129-how-do-you-implement-method-level-security-in-spring-boot">129. How do you implement method-level security in Spring Boot?</h3>
<p><strong>Answer:</strong> Method-level security in Spring Boot applies security rules directly to service methods:</p>
<ol>
    <li><strong>Enable method security</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableMethodSecurity
public class SecurityConfig {
    // Security configuration
}
</code></pre>
<ol start="2">
    <li><strong>Apply security annotations</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class UserService {
    @PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)
    public List&lt;User&gt; getAllUsers() {
        // Only accessible to admins
        return userRepository.findAll();
    }

    @PreAuthorize(&quot;hasAnyRole(&#39;ADMIN&#39;, &#39;MANAGER&#39;)&quot;)
    public User createUser(User user) {
        // Only accessible to admins and managers
        return userRepository.save(user);
    }

    @PreAuthorize(&quot;authentication.name == #username or hasRole(&#39;ADMIN&#39;)&quot;)
    public User getUserByUsername(String username) {
        // Users can only access their own data, admins can access any
        return userRepository.findByUsername(username);
    }

    @PostAuthorize(&quot;returnObject.username == authentication.name or hasRole(&#39;ADMIN&#39;)&quot;)
    public User getUserById(Long id) {
        // Check authorization after method execution using return value
        return userRepository.findById(id).orElse(null);
    }

    @Secured({&quot;ROLE_ADMIN&quot;})
    public void deleteUser(Long id) {
        // Alternative annotation style
        userRepository.deleteById(id);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Custom permission evaluator</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class CustomPermissionEvaluator implements PermissionEvaluator {
    private final UserRepository userRepository;

    @Override
    public boolean hasPermission(Authentication auth, Object targetDomainObject, Object permission) {
        // Implementation for object-level security
        if (auth == null || targetDomainObject == null) {
            return false;
        }

        String username = auth.getName();

        if (targetDomainObject instanceof Document) {
            Document document = (Document) targetDomainObject;
            return document.getOwner().equals(username);
        }

        return false;
    }

    @Override
    public boolean hasPermission(Authentication auth, Serializable targetId, String targetType, Object permission) {
        // Implementation for ID-based security
        if (auth == null || targetId == null || targetType == null) {
            return false;
        }

        if (targetType.equals(&quot;Document&quot;)) {
            Document document = documentRepository.findById((Long) targetId).orElse(null);
            if (document != null) {
                return hasPermission(auth, document, permission);
            }
        }

        return false;
    }
}
</code></pre>
<ol start="4">
    <li><strong>Using hasPermission in annotations</strong>:</li>
</ol>
<pre><code class="language-java">@PreAuthorize(&quot;hasPermission(#id, &#39;Document&#39;, &#39;EDIT&#39;)&quot;)
public Document editDocument(Long id, DocumentRequest request) {
    // Method can only be called if the user has EDIT permission on this document
}
</code></pre>
<h3 id="130-how-do-you-implement-a-custom-health-indicator-in-spring-boot-actuator">130. How do you implement a custom health indicator in Spring Boot Actuator?</h3>
<p><strong>Answer:</strong> Custom health indicators provide application-specific health status information:</p>
<ol>
    <li><strong>Create custom health indicator</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    private final DataSource dataSource;

    @Override
    public Health health() {
        try (Connection conn = dataSource.getConnection()) {
            try (Statement stmt = conn.createStatement()) {
                stmt.execute(&quot;SELECT 1&quot;);

                Map&lt;String, Object&gt; details = new HashMap&lt;&gt;();
                details.put(&quot;database&quot;, conn.getMetaData().getDatabaseProductName());
                details.put(&quot;version&quot;, conn.getMetaData().getDatabaseProductVersion());

                return Health.up()
                    .withDetails(details)
                    .build();
            }
        } catch (SQLException e) {
            return Health.down()
                .withException(e)
                .withDetail(&quot;error&quot;, &quot;Database connection failed: &quot; + e.getMessage())
                .build();
        }
    }
}
</code></pre>
<ol start="2">
    <li><strong>Create a composite health indicator</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ExternalSystemHealthIndicator implements CompositeHealthContributor {
    private final Map&lt;String, HealthContributor&gt; contributors;

    public ExternalSystemHealthIndicator(
            PaymentGatewayHealthIndicator paymentGateway,
            CacheHealthIndicator cache,
            MessagingHealthIndicator messaging) {

        contributors = Map.of(
            &quot;payment-gateway&quot;, paymentGateway,
            &quot;cache&quot;, cache,
            &quot;messaging&quot;, messaging
        );
    }

    @Override
    public HealthContributor getContributor(String name) {
        return contributors.get(name);
    }

    @Override
    public Iterator&lt;NamedContributor&lt;HealthContributor&gt;&gt; iterator() {
        return contributors.entrySet().stream()
            .map(entry -&gt; NamedContributor.of(entry.getKey(), entry.getValue()))
            .iterator();
    }
}
</code></pre>
<ol start="3">
    <li><strong>Configure health endpoint</strong>:</li>
</ol>
<pre><code class="language-properties"># Enable detailed health information
management.endpoint.health.show-details=always
management.endpoint.health.show-components=always

# Group health indicators
management.endpoint.health.group.liveness.include=ping,diskSpace
management.endpoint.health.group.liveness.show-details=always

management.endpoint.health.group.readiness.include=db,redis,externalServices
management.endpoint.health.group.readiness.show-details=always
</code></pre>
<ol start="4">
    <li><strong>Health indicator for external service</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ExternalApiHealthIndicator implements HealthIndicator {
    private final RestTemplate restTemplate;
    private final String apiUrl;

    @Override
    public Health health() {
        try {
            ResponseEntity&lt;Map&gt; response = restTemplate.getForEntity(apiUrl + &quot;/health&quot;, Map.class);

            if (response.getStatusCode().is2xxSuccessful()) {
                return Health.up()
                    .withDetail(&quot;status&quot;, response.getStatusCode())
                    .withDetails(response.getBody())
                    .build();
            } else {
                return Health.down()
                    .withDetail(&quot;status&quot;, response.getStatusCode())
                    .withDetail(&quot;reason&quot;, &quot;API returned non-2xx status&quot;)
                    .build();
            }
        } catch (Exception e) {
            return Health.down()
                .withException(e)
                .build();
        }
    }
}
</code></pre>
<h3 id="131-how-do-you-implement-custom-metrics-in-spring-boot-actuator">131. How do you implement custom metrics in Spring Boot Actuator?</h3>
<p><strong>Answer:</strong> Custom metrics in Spring Boot Actuator are implemented using the Micrometer API:</p>
<ol>
    <li><strong>Add dependency</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Using counter metrics</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderService {
    private final Counter orderCounter;
    private final Counter failedOrderCounter;

    public OrderService(MeterRegistry registry) {
        this.orderCounter = registry.counter(&quot;orders.created&quot;, &quot;type&quot;, &quot;total&quot;);
        this.failedOrderCounter = registry.counter(&quot;orders.failed&quot;);
    }

    public Order createOrder(OrderRequest request) {
        try {
            Order order = orderRepository.save(mapToEntity(request));
            orderCounter.increment();
            return order;
        } catch (Exception e) {
            failedOrderCounter.increment();
            throw e;
        }
    }
}
</code></pre>
<ol start="3">
    <li><strong>Using timer metrics</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class ProductService {
    private final Timer productLookupTimer;

    public ProductService(MeterRegistry registry) {
        this.productLookupTimer = registry.timer(&quot;product.lookup.time&quot;);
    }

    public Product getProductById(Long id) {
        return productLookupTimer.record(() -&gt; {
            // Timed operation
            return productRepository.findById(id)
                .orElseThrow(() -&gt; new ProductNotFoundException(id));
        });
    }

    public List&lt;Product&gt; searchProducts(String keyword) {
        Timer.Sample sample = Timer.start(registry);
        try {
            return productRepository.findByNameContaining(keyword);
        } finally {
            sample.stop(registry.timer(&quot;product.search.time&quot;,
                &quot;keyword&quot;, keyword.length() &gt; 10 ? &quot;long&quot; : &quot;short&quot;));
        }
    }
}
</code></pre>
<ol start="4">
    <li><strong>Using gauge metrics</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class QueueMetrics {
    public QueueMetrics(MeterRegistry registry, MessageQueue messageQueue) {
        // Register a gauge that reports the queue size
        Gauge.builder(&quot;message.queue.size&quot;, messageQueue::size)
            .description(&quot;Number of messages in queue&quot;)
            .register(registry);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Using distribution summary</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class FileUploadService {
    private final DistributionSummary fileSizeSummary;

    public FileUploadService(MeterRegistry registry) {
        this.fileSizeSummary = DistributionSummary
            .builder(&quot;file.upload.size&quot;)
            .baseUnit(&quot;bytes&quot;)
            .publishPercentiles(0.5, 0.95)
            .register(registry);
    }

    public void handleFileUpload(byte[] fileContent, String filename) {
        // Record file size metric
        fileSizeSummary.record(fileContent.length);

        // Process uploaded file
        fileStorage.store(filename, fileContent);
    }
}
</code></pre>
<ol start="6">
    <li><strong>Tag-based metrics</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class EndpointMetrics extends HandlerInterceptorAdapter {
    private final MeterRegistry registry;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        Timer.Sample sample = Timer.start(registry);
        request.setAttribute(&quot;timer.sample&quot;, sample);
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                              Object handler, Exception ex) {
        Timer.Sample sample = (Timer.Sample) request.getAttribute(&quot;timer.sample&quot;);
        if (sample != null) {
            String uri = request.getRequestURI();
            int status = response.getStatus();
            sample.stop(registry.timer(&quot;http.server.requests&quot;,
                &quot;uri&quot;, uri,
                &quot;method&quot;, request.getMethod(),
                &quot;status&quot;, String.valueOf(status),
                &quot;error&quot;, ex != null ? ex.getClass().getSimpleName() : &quot;none&quot;
            ));
        }
    }
}
</code></pre>
<h3 id="132-what-are-the-different-ways-to-externalize-configuration-in-spring-boot">132. What are the different ways to externalize configuration in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot provides multiple options to externalize configuration:</p>
<ol>
    <li><strong>Properties files</strong>:</li>
</ol>
<pre><code class="language-properties"># application.properties
app.name=MyApp
app.description=Spring Boot Application
app.version=1.0.0

# Custom properties
app.api.url=http://api.example.com
app.api.timeout=5000
</code></pre>
<ol start="2">
    <li><strong>YAML configuration</strong>:</li>
</ol>
<pre><code class="language-yaml"># application.yml
app:
  name: MyApp
  description: Spring Boot Application
  version: 1.0.0
  api:
    url: http://api.example.com
    timeout: 5000
</code></pre>
<ol start="3">
    <li><strong>Environment-specific configuration</strong>:</li>
</ol>
<pre><code>src/main/resources/application.properties     # Common properties
src/main/resources/application-dev.properties # Development environment
src/main/resources/application-qa.properties  # QA environment
src/main/resources/application-prod.properties # Production environment
</code></pre>
<pre><code class="language-bash"># Running with specific profile
java -jar app.jar --spring.profiles.active=dev

# Multiple profiles
java -jar app.jar --spring.profiles.active=dev,local
</code></pre>
<ol start="4">
    <li><strong>Command-line properties</strong>:</li>
</ol>
<pre><code class="language-bash">java -jar app.jar --app.api.url=http://localhost:8080 --server.port=9090
</code></pre>
<ol start="5">
    <li><strong>Environment variables</strong>:</li>
</ol>
<pre><code class="language-bash">export APP_API_URL=http://api.example.com
export SERVER_PORT=8080

# Using relaxed binding
# app.api.url can be set with:
export APP_API_URL=value
export APP_API_URL=value
export APP_API_URL=value
export app_api_url=value
</code></pre>
<ol start="6">
    <li><strong>ConfigurationProperties class</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@ConfigurationProperties(prefix = &quot;app.api&quot;)
@Validated
public class ApiProperties {
    @NotNull
    private String url;

    @Min(1000)
    private int timeout = 3000;

    private Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();

    // Getters and setters
}
</code></pre>
<ol start="7">
    <li><strong>Using @Value annotation</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class NotificationService {
    @Value(&quot;${app.notifications.enabled:true}&quot;)
    private boolean notificationsEnabled;

    @Value(&quot;${app.email.from}&quot;)
    private String fromAddress;

    @Value(&quot;#{systemProperties[&#39;user.region&#39;] ?: &#39;US&#39;}&quot;)
    private String region;

    @Value(&quot;#{@apiProperties.timeout}&quot;)
    private int timeout;
}
</code></pre>
<ol start="8">
    <li><strong>Spring Cloud Config</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># bootstrap.properties
spring.application.name=myapp
spring.cloud.config.uri=http://config-server:8888
</code></pre>
<ol start="9">
    <li><strong>Using PropertySource</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@PropertySource(&quot;classpath:custom-config.properties&quot;)
@PropertySource(value = &quot;file:${user.home}/config.properties&quot;, ignoreResourceNotFound = true)
public class AppConfig {
    @Autowired
    private Environment env;

    @Bean
    public DataSource dataSource() {
        BasicDataSource dataSource = new BasicDataSource();
        dataSource.setUrl(env.getProperty(&quot;app.datasource.url&quot;));
        dataSource.setUsername(env.getProperty(&quot;app.datasource.username&quot;));
        dataSource.setPassword(env.getProperty(&quot;app.datasource.password&quot;));
        return dataSource;
    }
}
</code></pre>
<ol start="10">
    <li><strong>Using configuration processor</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="133-what-are-the-best-practices-for-securing-sensitive-configuration-in-spring-boot">133. What are the best practices for securing sensitive configuration in Spring Boot?</h3>
<p><strong>Answer:</strong> Securing sensitive configuration in Spring Boot involves several best practices:</p>
<ol>
    <li><strong>Externalize credentials</strong>:</li>
</ol>
<pre><code class="language-properties"># Don&#39;t hardcode credentials in properties files
spring.datasource.url=jdbc:mysql://${DB_HOST}:${DB_PORT}/${DB_NAME}
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}
</code></pre>
<ol start="2">
    <li><strong>Use environment variables</strong>:</li>
</ol>
<pre><code class="language-bash">export DB_USERNAME=app_user
export DB_PASSWORD=s3cr3t
java -jar app.jar
</code></pre>
<ol start="3">
    <li><strong>Use Config Server with encryption</strong>:</li>
</ol>
<pre><code class="language-properties"># In Config Server
encrypt.key=your-secret-key

# In Git-backed config files
spring.datasource.password={cipher}a7f3bc4def123abc
</code></pre>
<ol start="4">
    <li><strong>Use Vault integration</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-vault-config&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties">spring.cloud.vault.token=s.KbvPTisEGBtG2xLzVQ7vvzKZ
spring.cloud.vault.scheme=http
spring.cloud.vault.host=localhost
spring.cloud.vault.port=8200

spring.cloud.vault.kv.enabled=true
spring.cloud.vault.kv.backend=secret
spring.cloud.vault.kv.default-context=application
</code></pre>
<ol start="5">
    <li><strong>Use JASYPT for property encryption</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;
    &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.0.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableEncryptableProperties
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<pre><code class="language-properties"># application.properties
spring.datasource.password=ENC(encrypted_password_here)
</code></pre>
<pre><code class="language-bash"># Start with password
java -jar app.jar --jasypt.encryptor.password=your-secret-key
</code></pre>
<ol start="6">
    <li><strong>Use Kubernetes Secrets</strong>:</li>
</ol>
<pre><code class="language-yaml"># secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
data:
  username: dXNlcm5hbWU=  # base64 encoded
  password: cGFzc3dvcmQ=  # base64 encoded
</code></pre>
<pre><code class="language-yaml"># deployment.yaml
containers:
- name: app
  image: myapp:latest
  env:
  - name: DB_USERNAME
    valueFrom:
      secretKeyRef:
        name: db-credentials
        key: username
  - name: DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: db-credentials
        key: password
</code></pre>
<ol start="7">
    <li><strong>Use AWS Parameter Store or Secrets Manager</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-aws-parameter-store-config&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties">aws.paramstore.enabled=true
aws.paramstore.prefix=/config
</code></pre>
<ol start="8">
    <li><strong>Never commit sensitive data to version control</strong>:</li>
</ol>
<pre><code># .gitignore
*.key
*.pem
*-secret.yml
*-secret.properties
</code></pre>
<ol start="9">
    <li><strong>Secure actuator endpoints</strong>:</li>
</ol>
<pre><code class="language-properties"># Expose only necessary endpoints
management.endpoints.web.exposure.include=health,info

# Hide sensitive details
management.endpoint.health.show-details=when_authorized
management.endpoint.env.keys-to-sanitize=password,secret,key,token,.*credentials.*
</code></pre>
<ol start="10">
    <li><strong>Use separate property files for sensitive data</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@PropertySource(&quot;file:${config.location}/security.properties&quot;)
public class SecurityConfig {
    // Security configuration
}
</code></pre>
<h3 id="134-what-are-the-different-strategies-for-handling-application-configuration-across-different-environments">134. What are the different strategies for handling application configuration across different environments?</h3>
<p><strong>Answer:</strong> Managing configuration across environments requires different strategies:</p>
<ol>
    <li><strong>Profile-specific properties</strong>:</li>
</ol>
<pre><code>application.properties      # Common properties
application-dev.properties  # Development environment
application-qa.properties   # QA environment
application-prod.properties # Production environment
</code></pre>
<pre><code class="language-bash"># Running with specific profile
java -jar app.jar --spring.profiles.active=dev
</code></pre>
<ol start="2">
    <li><strong>Profile groups</strong>:</li>
</ol>
<pre><code class="language-properties"># application.properties
spring.profiles.group.development=dev,local,debug
spring.profiles.group.production=prod,cloud,metrics
</code></pre>
<pre><code class="language-bash">java -jar app.jar --spring.profiles.active=development
</code></pre>
<ol start="3">
    <li><strong>Environment variables overrides</strong>:</li>
</ol>
<pre><code class="language-bash"># Development environment
export SERVER_PORT=8080
export LOGGING_LEVEL_ROOT=DEBUG

# Production environment
export SERVER_PORT=80
export LOGGING_LEVEL_ROOT=WARN
</code></pre>
<ol start="4">
    <li><strong>Cloud Config Server</strong>:</li>
</ol>
<pre><code>config-repo/
  application.properties          # Common properties
  application-dev.properties      # Development properties
  application-prod.properties     # Production properties
  myapp.properties                # Application-specific common properties
  myapp-dev.properties            # Application-specific development properties
  myapp-prod.properties           # Application-specific production properties
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Container environment variables</strong>:</li>
</ol>
<pre><code class="language-yaml"># Docker Compose for development
version: &#39;3&#39;
services:
  app:
    image: myapp:latest
    environment:
      - SPRING_PROFILES_ACTIVE=dev
      - DB_HOST=dev-db
</code></pre>
<pre><code class="language-yaml"># Kubernetes for production
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  template:
    spec:
      containers:
      - name: app
        image: myapp:latest
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: &quot;prod&quot;
        - name: DB_HOST
          value: &quot;prod-db.example.com&quot;
</code></pre>
<ol start="6">
    <li><strong>ConfigMap in Kubernetes</strong>:</li>
</ol>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  application.properties: |
    server.port=8080
    spring.datasource.url=jdbc:mysql://${DB_HOST}:3306/mydb
    app.cache.ttl=3600
</code></pre>
<pre><code class="language-yaml"># Mounting in pod
volumes:
- name: config-volume
  configMap:
    name: app-config
containers:
- name: app
  volumeMounts:
  - name: config-volume
    mountPath: /config
</code></pre>
<ol start="7">
    <li><strong>Configuration service pattern</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class ConfigurationService {
    private final Environment environment;

    public String getDatabaseUrl() {
        return environment.getProperty(&quot;spring.datasource.url&quot;);
    }

    public boolean isFeatureEnabled(String featureName) {
        return environment.getProperty(
            &quot;features.&quot; + featureName + &quot;.enabled&quot;,
            Boolean.class,
            false);
    }

    public String getConfigValue(String key, String defaultValue) {
        return environment.getProperty(key, defaultValue);
    }
}
</code></pre>
<ol start="8">
    <li><strong>Configuration classes for different environments</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@Profile(&quot;dev&quot;)
public class DevDataSourceConfig {
    @Bean
    public DataSource dataSource() {
        // Development datasource (e.g., H2)
    }
}

@Configuration
@Profile(&quot;prod&quot;)
public class ProdDataSourceConfig {
    @Bean
    public DataSource dataSource() {
        // Production datasource (e.g., MySQL)
    }
}
</code></pre>
<ol start="9">
    <li><strong>Feature toggles by environment</strong>:</li>
</ol>
<pre><code class="language-properties"># application-dev.properties
features.new-ui.enabled=true
features.analytics.enabled=false

# application-prod.properties
features.new-ui.enabled=false
features.analytics.enabled=true
</code></pre>
<ol start="10">
    <li><strong>Using Spring Factory pattern for environment-specific implementations</strong>:</li>
</ol>
<pre><code class="language-java">public interface NotificationService {
    void sendNotification(String message);
}

@Component
@Profile(&quot;dev&quot;)
public class ConsoleNotificationService implements NotificationService {
    @Override
    public void sendNotification(String message) {
        System.out.println(&quot;DEV NOTIFICATION: &quot; + message);
    }
}

@Component
@Profile(&quot;prod&quot;)
public class EmailNotificationService implements NotificationService {
    @Override
    public void sendNotification(String message) {
        // Send actual email
    }
}
</code></pre>
<h3 id="135-how-do-you-implement-global-exception-handling-in-spring-boot-applications">135. How do you implement global exception handling in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Global exception handling in Spring Boot is typically implemented using <code>@ControllerAdvice</code> or <code>@RestControllerAdvice</code>:</p>
<ol>
    <li><strong>Basic global exception handler</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ErrorResponse handleResourceNotFoundException(ResourceNotFoundException ex) {
        return new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            System.currentTimeMillis()
        );
    }

    @ExceptionHandler(BadRequestException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ErrorResponse handleBadRequestException(BadRequestException ex) {
        return new ErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            ex.getMessage(),
            System.currentTimeMillis()
        );
    }

    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ErrorResponse handleGenericException(Exception ex) {
        return new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            &quot;An unexpected error occurred&quot;,
            System.currentTimeMillis()
        );
    }
}
</code></pre>
<ol start="2">
    <li><strong>Handling validation exceptions</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice
public class ValidationExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ValidationErrorResponse handleValidationException(MethodArgumentNotValidException ex) {
        ValidationErrorResponse error = new ValidationErrorResponse();
        error.setTimestamp(System.currentTimeMillis());
        error.setStatus(HttpStatus.BAD_REQUEST.value());
        error.setMessage(&quot;Validation failed&quot;);

        ex.getBindingResult().getFieldErrors().forEach(fieldError -&gt;
            error.addError(fieldError.getField(), fieldError.getDefaultMessage())
        );

        return error;
    }

    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ValidationErrorResponse handleConstraintViolation(ConstraintViolationException ex) {
        ValidationErrorResponse error = new ValidationErrorResponse();
        error.setTimestamp(System.currentTimeMillis());
        error.setStatus(HttpStatus.BAD_REQUEST.value());
        error.setMessage(&quot;Validation failed&quot;);

        ex.getConstraintViolations().forEach(violation -&gt;
            error.addError(
                violation.getPropertyPath().toString(),
                violation.getMessage()
            )
        );

        return error;
    }
}
</code></pre>
<ol start="3">
    <li><strong>Custom error response</strong>:</li>
</ol>
<pre><code class="language-java">public class ErrorResponse {
    private int status;
    private String message;
    private long timestamp;

    // Constructor, getters, setters
}

public class ValidationErrorResponse extends ErrorResponse {
    private final Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();

    public void addError(String field, String message) {
        errors.put(field, message);
    }

    public Map&lt;String, String&gt; getErrors() {
        return errors;
    }
}
</code></pre>
<ol start="4">
    <li><strong>Using ProblemDetail (Spring 6)</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ProblemDetail handleResourceNotFoundException(ResourceNotFoundException ex) {
        ProblemDetail problemDetail = ProblemDetail
            .forStatusAndDetail(HttpStatus.NOT_FOUND, ex.getMessage());

        problemDetail.setTitle(&quot;Resource Not Found&quot;);
        problemDetail.setType(URI.create(&quot;https://api.example.com/problems/not-found&quot;));
        problemDetail.setProperty(&quot;timestamp&quot;, Instant.now());

        return problemDetail;
    }
}
</code></pre>
<ol start="5">
    <li><strong>Controller-specific exception handling</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice(assignableTypes = {UserController.class, AccountController.class})
public class UserExceptionHandler {

    @ExceptionHandler(UserNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ErrorResponse handleUserNotFoundException(UserNotFoundException ex) {
        return new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            System.currentTimeMillis()
        );
    }
}
</code></pre>
<ol start="6">
    <li><strong>Error response localization</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice
public class LocalizedExceptionHandler {
    private final MessageSource messageSource;

    @ExceptionHandler(BusinessException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ErrorResponse handleBusinessException(BusinessException ex, Locale locale) {
        String localizedMessage = messageSource.getMessage(
            ex.getMessageKey(),
            ex.getArgs(),
            ex.getMessage(),
            locale);

        return new ErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            localizedMessage,
            System.currentTimeMillis()
        );
    }
}
</code></pre>
<h2 id="advanced-topics-and-best-practices">Advanced Topics and Best Practices</h2>
<h3 id="136-how-do-you-implement-pagination-and-sorting-in-spring-boot-rest-apis">136. How do you implement pagination and sorting in Spring Boot REST APIs?</h3>
<p><strong>Answer:</strong> Spring Boot supports pagination and sorting through Spring Data:</p>
<ol>
    <li><strong>Repository methods with Pageable</strong>:</li>
</ol>
<pre><code class="language-java">public interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {
    Page&lt;Product&gt; findByCategory(String category, Pageable pageable);
    Page&lt;Product&gt; findByPriceGreaterThan(BigDecimal price, Pageable pageable);
}
</code></pre>
<ol start="2">
    <li><strong>Controller implementation</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    private final ProductRepository productRepository;

    @GetMapping
    public Page&lt;Product&gt; getProducts(
            @RequestParam(defaultValue = &quot;0&quot;) int page,
            @RequestParam(defaultValue = &quot;10&quot;) int size,
            @RequestParam(defaultValue = &quot;id&quot;) String sort,
            @RequestParam(required = false) String direction) {

        Sort.Direction sortDirection = direction != null &amp;&amp; direction.equalsIgnoreCase(&quot;desc&quot;)
            ? Sort.Direction.DESC : Sort.Direction.ASC;

        return productRepository.findAll(
            PageRequest.of(page, size, Sort.by(sortDirection, sort))
        );
    }

    @GetMapping(&quot;/by-category/{category}&quot;)
    public Page&lt;Product&gt; getProductsByCategory(
            @PathVariable String category,
            @PageableDefault(page = 0, size = 20, sort = &quot;name&quot;) Pageable pageable) {

        return productRepository.findByCategory(category, pageable);
    }
}
</code></pre>
<ol start="3">
    <li><strong>HATEOAS pagination support</strong>:</li>
</ol>
<pre><code class="language-java">@GetMapping
public PagedModel&lt;EntityModel&lt;Product&gt;&gt; getProducts(
        @RequestParam(defaultValue = &quot;0&quot;) int page,
        @RequestParam(defaultValue = &quot;10&quot;) int size,
        @RequestParam(defaultValue = &quot;id&quot;) String sort,
        PagedResourcesAssembler&lt;Product&gt; assembler) {

    Page&lt;Product&gt; products = productRepository.findAll(
        PageRequest.of(page, size, Sort.by(sort)));

    return assembler.toModel(products,
        product -&gt; EntityModel.of(product,
            linkTo(methodOn(ProductController.class).getProduct(product.getId())).withSelfRel()
        )
    );
}
</code></pre>
<ol start="4">
    <li><strong>Custom PagedResourcesAssembler</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ProductModelAssembler implements RepresentationModelAssembler&lt;Product, EntityModel&lt;Product&gt;&gt; {
    @Override
    public EntityModel&lt;Product&gt; toModel(Product product) {
        return EntityModel.of(product,
            linkTo(methodOn(ProductController.class).getProduct(product.getId())).withSelfRel(),
            linkTo(methodOn(ProductController.class).getProducts(0, 10, &quot;id&quot;, null))
                .withRel(&quot;products&quot;)
        );
    }
}

@GetMapping
public PagedModel&lt;EntityModel&lt;Product&gt;&gt; getAllProducts(
        Pageable pageable, PagedResourcesAssembler&lt;Product&gt; assembler) {
    Page&lt;Product&gt; products = productRepository.findAll(pageable);
    return assembler.toModel(products, productModelAssembler);
}
</code></pre>
<ol start="5">
    <li><strong>Advanced sorting</strong>:</li>
</ol>
<pre><code class="language-java">@GetMapping(&quot;/search&quot;)
public Page&lt;Product&gt; searchProducts(
        @RequestParam String keyword,
        @RequestParam(required = false) List&lt;String&gt; sort) {

    // Create dynamic Sort object from multiple fields
    Sort dynamicSort = Sort.unsorted();
    if (sort != null) {
        List&lt;Sort.Order&gt; orders = sort.stream()
            .map(field -&gt; {
                if (field.startsWith(&quot;-&quot;)) {
                    return Sort.Order.desc(field.substring(1));
                } else {
                    return Sort.Order.asc(field);
                }
            })
            .collect(Collectors.toList());

        dynamicSort = Sort.by(orders);
    }

    return productRepository.findByNameContaining(
        keyword,
        PageRequest.of(0, 20, dynamicSort)
    );
}
</code></pre>
<h3 id="137-what-is-spring-boot-devtools-and-how-does-it-enhance-development-productivity">137. What is Spring Boot DevTools and how does it enhance development productivity?</h3>
<p><strong>Answer:</strong> Spring Boot DevTools provides features to enhance developer productivity:</p>
<ol>
    <li><p><strong>Key features</strong>:</p>
        <ul>
            <li>Automatic application restart when classpath changes</li>
            <li>LiveReload support to automatically refresh browser</li>
            <li>Remote debugging and development</li>
            <li>Development-only property defaults</li>
            <li>Automatic H2 console enablement</li>
        </ul>
    </li>
    <li><p><strong>Setup</strong>:</p>
    </li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="3">
    <li><strong>Configuration</strong>:</li>
</ol>
<pre><code class="language-properties"># Enable/disable automatic restart
spring.devtools.restart.enabled=true

# Exclude specific paths
spring.devtools.restart.exclude=static/**,public/**

# Additional paths to watch
spring.devtools.restart.additional-paths=scripts/**

# Enable/disable LiveReload
spring.devtools.livereload.enabled=true

# Configure trigger file
spring.devtools.restart.trigger-file=.reloadtrigger
</code></pre>
<ol start="4">
    <li><strong>Remote development</strong>:</li>
</ol>
<pre><code class="language-properties"># Enable remote development
spring.devtools.remote.secret=mysecret
</code></pre>
<pre><code class="language-xml">&lt;!-- Remote application setup --&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;excludeDevtools&gt;false&lt;/excludeDevtools&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<ol start="5">
    <li><strong>Automatic restart for dynamic changes</strong> - DevTools uses two classloaders:<ul>
        <li>Base classloader for unchanging classes (libraries)</li>
        <li>Restart classloader for application code that changes frequently</li>
        <li>When changes detected, only restart classloader is reloaded (much faster)</li>
    </ul>
    </li>
</ol>
<h3 id="138-what-are-the-different-strategies-for-deploying-spring-boot-applications">138. What are the different strategies for deploying Spring Boot applications?</h3>
<p><strong>Answer:</strong> Spring Boot applications can be deployed in multiple ways:</p>
<ol>
    <li><strong>Standalone JAR</strong>:</li>
</ol>
<pre><code class="language-bash"># Build JAR
./mvnw package

# Run JAR
java -jar target/myapp-0.0.1-SNAPSHOT.jar
</code></pre>
<ol start="2">
    <li><strong>WAR deployment</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;!-- Change packaging to WAR --&gt;
&lt;packaging&gt;war&lt;/packaging&gt;

&lt;!-- Add provided scope for embedded server --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">// Extend SpringBootServletInitializer
@SpringBootApplication
public class Application extends SpringBootServletInitializer {
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(Application.class);
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Docker containerization</strong>:</li>
</ol>
<pre><code class="language-dockerfile">FROM eclipse-temurin:17-jre
VOLUME /tmp
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
</code></pre>
<pre><code class="language-bash"># Build image
docker build -t myapp .

# Run container
docker run -p 8080:8080 myapp
</code></pre>
<ol start="4">
    <li><strong>Docker multi-stage build</strong>:</li>
</ol>
<pre><code class="language-dockerfile"># Build stage
FROM maven:3.8-openjdk-17 AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

# Run stage
FROM eclipse-temurin:17-jre
COPY --from=build /app/target/*.jar app.jar
ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
</code></pre>
<ol start="5">
    <li><strong>Kubernetes deployment</strong>:</li>
</ol>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        ports:
        - containerPort: 8080
        resources:
          limits:
            memory: &quot;512Mi&quot;
            cpu: &quot;500m&quot;
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
</code></pre>
<ol start="6">
    <li><strong>Cloud platform deployment</strong>:</li>
</ol>
<pre><code class="language-properties"># For Cloud Foundry
java_buildpack.config.spring_auto_reconfiguration.enabled=true

# For Heroku
server.port=${PORT:8080}
</code></pre>
<ol start="7">
    <li><strong>Systemd service</strong>:</li>
</ol>
<pre><code># /etc/systemd/system/myapp.service
[Unit]
Description=My Spring Boot Application
After=syslog.target

[Service]
User=myapp
WorkingDirectory=/opt/myapp
ExecStart=/usr/bin/java -jar myapp.jar
SuccessExitStatus=143

[Install]
WantedBy=multi-user.target
</code></pre>
<ol start="8">
    <li><strong>Native image with GraalVM</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;
    &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;buildArgs&gt;
            &lt;buildArg&gt;--no-fallback&lt;/buildArg&gt;
        &lt;/buildArgs&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<pre><code class="language-bash"># Build native image
./mvnw -Pnative native:compile

# Run native executable
./target/myapp
</code></pre>
<h3 id="139-how-do-you-implement-resilience-patterns-in-spring-boot">139. How do you implement resilience patterns in Spring Boot?</h3>
<p><strong>Answer:</strong> Resilience patterns in Spring Boot can be implemented with Resilience4j:</p>
<ol>
    <li><strong>Setup</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt;
    &lt;artifactId&gt;resilience4j-spring-boot2&lt;/artifactId&gt;
    &lt;version&gt;1.7.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Circuit Breaker pattern</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class PaymentService {
    @CircuitBreaker(name = &quot;paymentService&quot;, fallbackMethod = &quot;paymentFallback&quot;)
    public PaymentResponse processPayment(PaymentRequest request) {
        return paymentGateway.processPayment(request);
    }

    public PaymentResponse paymentFallback(PaymentRequest request, Exception e) {
        return new PaymentResponse(&quot;offline-&quot; + UUID.randomUUID().toString());
    }
}
</code></pre>
<pre><code class="language-properties"># Circuit breaker configuration
resilience4j.circuitbreaker.instances.paymentService.registerHealthIndicator=true
resilience4j.circuitbreaker.instances.paymentService.failureRateThreshold=50
resilience4j.circuitbreaker.instances.paymentService.minimumNumberOfCalls=10
resilience4j.circuitbreaker.instances.paymentService.slidingWindowSize=20
resilience4j.circuitbreaker.instances.paymentService.waitDurationInOpenState=10s
</code></pre>
<ol start="3">
    <li><strong>Retry pattern</strong>:</li>
</ol>
<pre><code class="language-java">@Retry(name = &quot;orderService&quot;, fallbackMethod = &quot;fallbackOrder&quot;)
public Order placeOrder(OrderRequest request) {
    return orderProcessor.process(request);
}

public Order fallbackOrder(OrderRequest request, Exception e) {
    return new Order(OrderStatus.PENDING);
}
</code></pre>
<pre><code class="language-properties"># Retry configuration
resilience4j.retry.instances.orderService.maxAttempts=3
resilience4j.retry.instances.orderService.waitDuration=1s
resilience4j.retry.instances.orderService.enableExponentialBackoff=true
resilience4j.retry.instances.orderService.exponentialBackoffMultiplier=2
</code></pre>
<ol start="4">
    <li><strong>Rate Limiter pattern</strong>:</li>
</ol>
<pre><code class="language-java">@RateLimiter(name = &quot;apiLimiter&quot;)
public ApiResponse callExternalApi(ApiRequest request) {
    return externalApi.call(request);
}
</code></pre>
<pre><code class="language-properties"># Rate limiter configuration
resilience4j.ratelimiter.instances.apiLimiter.limitForPeriod=10
resilience4j.ratelimiter.instances.apiLimiter.limitRefreshPeriod=1s
resilience4j.ratelimiter.instances.apiLimiter.timeoutDuration=0
</code></pre>
<ol start="5">
    <li><strong>Bulkhead pattern</strong>:</li>
</ol>
<pre><code class="language-java">@Bulkhead(name = &quot;reportingService&quot;, fallbackMethod = &quot;fallbackReport&quot;)
public Report generateReport(ReportRequest request) {
    // Resource-intensive operation
    return reportGenerator.create(request);
}
</code></pre>
<pre><code class="language-properties"># Bulkhead configuration
resilience4j.bulkhead.instances.reportingService.maxConcurrentCalls=3
resilience4j.bulkhead.instances.reportingService.maxWaitDuration=1s
</code></pre>
<ol start="6">
    <li><strong>TimeLimiter (Timeout) pattern</strong>:</li>
</ol>
<pre><code class="language-java">@TimeLimiter(name = &quot;searchService&quot;, fallbackMethod = &quot;searchFallback&quot;)
public CompletableFuture&lt;SearchResult&gt; search(String query) {
    return CompletableFuture.supplyAsync(() -&gt; searchEngine.search(query));
}
</code></pre>
<pre><code class="language-properties"># Time limiter configuration
resilience4j.timelimiter.instances.searchService.timeoutDuration=5s
resilience4j.timelimiter.instances.searchService.cancelRunningFuture=true
</code></pre>
<ol start="7">
    <li><strong>Combining multiple patterns</strong>:</li>
</ol>
<pre><code class="language-java">@CircuitBreaker(name = &quot;paymentService&quot;, fallbackMethod = &quot;paymentFallback&quot;)
@RateLimiter(name = &quot;paymentService&quot;)
@Bulkhead(name = &quot;paymentService&quot;)
@Retry(name = &quot;paymentService&quot;)
public PaymentResponse processPayment(PaymentRequest request) {
    return paymentGateway.processPayment(request);
}
</code></pre>
<ol start="8">
    <li><strong>Programmatic usage</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class ResilentService {
    private final CircuitBreaker circuitBreaker;
    private final RateLimiter rateLimiter;
    private final Retry retry;

    public ResilentService(CircuitBreakerRegistry circuitBreakerRegistry,
                         RateLimiterRegistry rateLimiterRegistry,
                         RetryRegistry retryRegistry) {
        this.circuitBreaker = circuitBreakerRegistry.circuitBreaker(&quot;apiService&quot;);
        this.rateLimiter = rateLimiterRegistry.rateLimiter(&quot;apiService&quot;);
        this.retry = retryRegistry.retry(&quot;apiService&quot;);
    }

    public ApiResponse callExternalService(ApiRequest request) {
        Supplier&lt;ApiResponse&gt; decoratedSupplier = CircuitBreaker.decorateSupplier(
            circuitBreaker,
            () -&gt; apiClient.call(request)
        );

        // Add rate limiting
        decoratedSupplier = RateLimiter.decorateSupplier(
            rateLimiter,
            decoratedSupplier
        );

        // Add retry
        decoratedSupplier = Retry.decorateSupplier(
            retry,
            decoratedSupplier
        );

        try {
            return decoratedSupplier.get();
        } catch (Exception e) {
            return new ApiResponse(&quot;Fallback response&quot;);
        }
    }
}
</code></pre>
<h3 id="140-how-do-you-implement-error-handling-for-rest-apis-in-spring-boot">140. How do you implement error handling for REST APIs in Spring Boot?</h3>
<p><strong>Answer:</strong> REST API error handling in Spring Boot involves several patterns:</p>
<ol>
    <li><strong>Global exception handler</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ApiError handleResourceNotFoundException(ResourceNotFoundException ex) {
        return new ApiError(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            LocalDateTime.now()
        );
    }

    @ExceptionHandler(ValidationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ApiError handleValidationException(ValidationException ex) {
        return new ApiError(
            HttpStatus.BAD_REQUEST.value(),
            &quot;Validation failed&quot;,
            LocalDateTime.now(),
            ex.getViolations()
        );
    }
}
</code></pre>
<ol start="2">
    <li><strong>Standardized error response</strong>:</li>
</ol>
<pre><code class="language-java">public class ApiError {
    private int status;
    private String message;
    private LocalDateTime timestamp;
    private Map&lt;String, String&gt; errors;

    // Constructors, getters, setters
}
</code></pre>
<ol start="3">
    <li><strong>Custom exceptions</strong>:</li>
</ol>
<pre><code class="language-java">public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {
        super(String.format(&quot;%s not found with %s: &#39;%s&#39;&quot;, resourceName, fieldName, fieldValue));
    }
}

public class BadRequestException extends RuntimeException {
    public BadRequestException(String message) {
        super(message);
    }
}

public class ValidationException extends RuntimeException {
    private final Map&lt;String, String&gt; violations;

    public ValidationException(Map&lt;String, String&gt; violations) {
        super(&quot;Validation failed&quot;);
        this.violations = violations;
    }

    public Map&lt;String, String&gt; getViolations() {
        return violations;
    }
}
</code></pre>
<ol start="4">
    <li><strong>Bean validation handling</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice
public class ValidationErrorHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ApiError handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();

        ex.getBindingResult().getFieldErrors().forEach(error -&gt;
            errors.put(error.getField(), error.getDefaultMessage())
        );

        return new ApiError(
            HttpStatus.BAD_REQUEST.value(),
            &quot;Validation failure&quot;,
            LocalDateTime.now(),
            errors
        );
    }
}
</code></pre>
<ol start="5">
    <li><strong>Problem Details for HTTP APIs (RFC 7807)</strong>:</li>
</ol>
<pre><code class="language-java">@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity&lt;ProblemDetail&gt; handleResourceNotFoundException(
        ResourceNotFoundException ex, WebRequest request) {

    ProblemDetail problemDetail = ProblemDetail
        .forStatusAndDetail(HttpStatus.NOT_FOUND, ex.getMessage());

    problemDetail.setTitle(&quot;Resource Not Found&quot;);
    problemDetail.setType(URI.create(&quot;https://api.example.com/errors/not-found&quot;));
    problemDetail.setProperty(&quot;timestamp&quot;, LocalDateTime.now());
    problemDetail.setProperty(&quot;method&quot;, ((ServletWebRequest)request).getRequest().getMethod());

    return ResponseEntity.status(HttpStatus.NOT_FOUND)
        .contentType(MediaType.APPLICATION_PROBLEM_JSON)
        .body(problemDetail);
}
</code></pre>
<ol start="6">
    <li><strong>Error response with HATEOAS links</strong>:</li>
</ol>
<pre><code class="language-java">@ExceptionHandler(OrderNotFoundException.class)
public ResponseEntity&lt;EntityModel&lt;ApiError&gt;&gt; handleOrderNotFoundException(OrderNotFoundException ex) {
    ApiError error = new ApiError(
        HttpStatus.NOT_FOUND.value(),
        ex.getMessage(),
        LocalDateTime.now()
    );

    // Add HATEOAS links to help the client
    EntityModel&lt;ApiError&gt; model = EntityModel.of(error,
        linkTo(methodOn(OrderController.class).getAllOrders(null)).withRel(&quot;all-orders&quot;),
        linkTo(methodOn(OrderController.class).createOrder(null)).withRel(&quot;create-order&quot;)
    );

    return ResponseEntity.status(HttpStatus.NOT_FOUND).body(model);
}
</code></pre>
<ol start="7">
    <li><strong>Logging errors</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice
public class LoggingExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(LoggingExceptionHandler.class);

    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ApiError handleException(Exception ex, WebRequest request) {
        // Log all exceptions with details
        logger.error(&quot;Unhandled exception&quot;, ex);
        logger.error(&quot;Request: {}&quot;, request);

        // But return generic message to client
        return new ApiError(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            &quot;An unexpected error occurred&quot;,
            LocalDateTime.now()
        );
    }
}
</code></pre>
<ol start="8">
    <li><strong>Error codes for localization</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice
public class LocalizedErrorHandler {
    private final MessageSource messageSource;

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity&lt;ApiError&gt; handleBusinessException(
            BusinessException ex, Locale locale) {

        String localizedMessage = messageSource.getMessage(
            &quot;error.&quot; + ex.getErrorCode(),
            ex.getArgs(),
            ex.getMessage(),
            locale
        );

        ApiError error = new ApiError(
            HttpStatus.BAD_REQUEST.value(),
            localizedMessage,
            LocalDateTime.now(),
            ex.getErrorCode()
        );

        return ResponseEntity.badRequest().body(error);
    }
}
</code></pre>
<h3 id="141-what-is-the-spring-boot-autoconfiguration-mechanism">141. What is the Spring Boot Autoconfiguration mechanism?</h3>
<p><strong>Answer:</strong> Spring Boot Autoconfiguration automatically configures beans based on various conditions:</p>
<ol>
    <li><p><strong>Core components</strong>:</p>
        <ul>
            <li><code>@SpringBootApplication</code> includes <code>@EnableAutoConfiguration</code></li>
            <li>Auto-configurations are loaded from <code>META-INF/spring.factories</code> (Spring Boot 2.x)</li>
            <li>In Spring Boot 3.x, auto-configurations are loaded from <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code></li>
            <li>Conditional annotations control when auto-configuration is applied</li>
        </ul>
    </li>
    <li><p><strong>How auto-configuration works</strong>:</p>
    </li>
</ol>
<pre><code class="language-java">@Configuration
@ConditionalOnClass(DataSource.class)
@ConditionalOnMissingBean(DataSource.class)
@EnableConfigurationProperties(DataSourceProperties.class)
public class DataSourceAutoConfiguration {

    @Bean
    @ConditionalOnProperty(prefix = &quot;spring.datasource&quot;, name = &quot;url&quot;)
    public DataSource dataSource(DataSourceProperties properties) {
        return createDataSource(properties);
    }

    private DataSource createDataSource(DataSourceProperties properties) {
        // Create datasource
    }
}
</code></pre>
<ol start="3">
    <li><p><strong>Conditional annotations</strong>:</p>
        <ul>
            <li><code>@ConditionalOnClass</code>: Applies when class is on classpath</li>
            <li><code>@ConditionalOnMissingClass</code>: Applies when class is not on classpath</li>
            <li><code>@ConditionalOnBean</code>: Applies when bean exists</li>
            <li><code>@ConditionalOnMissingBean</code>: Applies when bean doesn&#39;t exist</li>
            <li><code>@ConditionalOnProperty</code>: Applies based on property values</li>
            <li><code>@ConditionalOnResource</code>: Applies when resource is available</li>
            <li><code>@ConditionalOnWebApplication</code>/<code>@ConditionalOnNotWebApplication</code>: Web context condition</li>
            <li><code>@ConditionalOnExpression</code>: Applies based on SpEL expression</li>
        </ul>
    </li>
    <li><p><strong>Auto-configuration ordering</strong>:</p>
    </li>
</ol>
<pre><code class="language-java">@Configuration
@AutoConfigureAfter(DataSourceAutoConfiguration.class)
@ConditionalOnClass({ LocalContainerEntityManagerFactoryBean.class, EntityManager.class })
@ConditionalOnMissingBean(LocalContainerEntityManagerFactoryBean.class)
public class JpaAutoConfiguration {
    // JPA configuration that depends on DataSource being configured first
}
</code></pre>
<ol start="5">
    <li><strong>Excluding auto-configuration</strong>:</li>
</ol>
<pre><code class="language-java">@SpringBootApplication(exclude = {
    DataSourceAutoConfiguration.class,
    SecurityAutoConfiguration.class
})
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<pre><code class="language-properties">spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
</code></pre>
<ol start="6">
    <li><strong>View applied auto-configurations</strong>:</li>
</ol>
<pre><code># Enable debug to see report
debug=true
</code></pre>
<ol start="7">
    <li><strong>Creating custom auto-configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@ConditionalOnClass(MyService.class)
@EnableConfigurationProperties(MyProperties.class)
public class MyServiceAutoConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public MyService myService(MyProperties properties) {
        return new MyServiceImpl(properties.getProperty());
    }
}
</code></pre>
<pre><code># META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
com.example.MyServiceAutoConfiguration
</code></pre>
<h3 id="142-how-does-spring-boot-handle-database-connections-and-connection-pooling">142. How does Spring Boot handle database connections and connection pooling?</h3>
<p><strong>Answer:</strong> Spring Boot manages database connections through connection pools:</p>
<ol>
    <li><strong>Default setup with HikariCP</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># Basic configuration
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=user
spring.datasource.password=password
</code></pre>
<ol start="2">
    <li><strong>Connection pool configuration</strong>:</li>
</ol>
<pre><code class="language-properties"># HikariCP Configuration
spring.datasource.hikari.maximum-pool-size=15
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=30000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.auto-commit=true
spring.datasource.hikari.pool-name=MyHikariPool
</code></pre>
<ol start="3">
    <li><strong>Multiple data sources</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableTransactionManagement
public class DatabaseConfig {
    @Bean
    @ConfigurationProperties(&quot;app.datasource.main&quot;)
    public DataSourceProperties mainDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    @Primary
    @ConfigurationProperties(&quot;app.datasource.main.hikari&quot;)
    public DataSource mainDataSource() {
        return mainDataSourceProperties()
            .initializeDataSourceBuilder()
            .type(HikariDataSource.class)
            .build();
    }

    @Bean
    @ConfigurationProperties(&quot;app.datasource.reporting&quot;)
    public DataSourceProperties reportingDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    @ConfigurationProperties(&quot;app.datasource.reporting.hikari&quot;)
    public DataSource reportingDataSource() {
        return reportingDataSourceProperties()
            .initializeDataSourceBuilder()
            .type(HikariDataSource.class)
            .build();
    }
}
</code></pre>
<pre><code class="language-properties"># Primary DataSource
app.datasource.main.url=jdbc:mysql://localhost:3306/maindb
app.datasource.main.username=user1
app.datasource.main.password=pass1
app.datasource.main.hikari.maximum-pool-size=10

# Secondary DataSource
app.datasource.reporting.url=jdbc:mysql://localhost:3306/reportdb
app.datasource.reporting.username=user2
app.datasource.reporting.password=pass2
app.datasource.reporting.hikari.maximum-pool-size=5
</code></pre>
<ol start="4">
    <li><strong>Custom DataSource without JPA</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class DataSourceConfig {
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/mydb&quot;);
        config.setUsername(&quot;user&quot;);
        config.setPassword(&quot;password&quot;);
        config.setMaximumPoolSize(10);
        config.setMinimumIdle(3);

        return new HikariDataSource(config);
    }

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Monitoring connection pool</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class HikariMetricsConfig {
    @Bean
    public DataSource dataSource(DataSourceProperties properties, MeterRegistry meterRegistry) {
        HikariDataSource dataSource = (HikariDataSource) properties
            .initializeDataSourceBuilder()
            .type(HikariDataSource.class)
            .build();

        dataSource.setMetricRegistry(new MicrometerMetricsTrackerFactory(meterRegistry));
        return dataSource;
    }
}
</code></pre>
<ol start="6">
    <li><strong>Connection pool health check</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class DataSourceHealthIndicator implements HealthIndicator {
    private final DataSource dataSource;

    @Override
    public Health health() {
        if (dataSource instanceof HikariDataSource) {
            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;
            HikariPoolMXBean poolMXBean = hikariDataSource.getHikariPoolMXBean();

            Map&lt;String, Object&gt; details = new HashMap&lt;&gt;();
            details.put(&quot;active&quot;, poolMXBean.getActiveConnections());
            details.put(&quot;idle&quot;, poolMXBean.getIdleConnections());
            details.put(&quot;total&quot;, poolMXBean.getTotalConnections());
            details.put(&quot;waiting&quot;, poolMXBean.getThreadsAwaitingConnection());

            if (poolMXBean.getThreadsAwaitingConnection() &gt; 10) {
                return Health.down()
                    .withDetails(details)
                    .build();
            }

            return Health.up()
                .withDetails(details)
                .build();
        }

        return Health.up().build();
    }
}
</code></pre>
<ol start="7">
    <li><strong>JNDI lookup for application servers</strong>:</li>
</ol>
<pre><code class="language-properties">spring.datasource.jndi-name=java:comp/env/jdbc/MyDatabase
</code></pre>
<h3 id="143-how-do-you-implement-websocket-communication-in-spring-boot">143. How do you implement WebSocket communication in Spring Boot?</h3>
<p><strong>Answer:</strong> WebSockets in Spring Boot enable full-duplex communication:</p>
<ol>
    <li><strong>Add dependencies</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>WebSocket configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        // Enable an application destination prefix
        config.setApplicationDestinationPrefixes(&quot;/app&quot;);

        // Enable a simple memory-based message broker
        config.enableSimpleBroker(&quot;/topic&quot;, &quot;/queue&quot;);

        // Set user destination prefix
        config.setUserDestinationPrefix(&quot;/user&quot;);
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // Register STOMP endpoints
        registry.addEndpoint(&quot;/ws&quot;)
            .setAllowedOrigins(&quot;*&quot;)
            .withSockJS();  // Fallback for browsers that don&#39;t support WebSocket
    }
}
</code></pre>
<ol start="3">
    <li><strong>Message controller</strong>:</li>
</ol>
<pre><code class="language-java">@Controller
public class ChatController {

    @MessageMapping(&quot;/chat.sendMessage&quot;)
    @SendTo(&quot;/topic/public&quot;)
    public ChatMessage sendMessage(ChatMessage chatMessage) {
        return chatMessage;
    }

    @MessageMapping(&quot;/chat.private&quot;)
    public ChatMessage privateMessage(@Payload ChatMessage chatMessage,
                                   Principal principal,
                                   @Header(&quot;simpSessionId&quot;) String sessionId) {

        // Send to specific user
        messagingTemplate.convertAndSendToUser(
            chatMessage.getRecipient(),
            &quot;/queue/messages&quot;,
            chatMessage
        );

        return chatMessage;
    }
}
</code></pre>
<ol start="4">
    <li><strong>WebSocket event listener</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class WebSocketEventListener {
    private final SimpMessageSendingOperations messagingTemplate;

    @EventListener
    public void handleWebSocketConnectListener(SessionConnectedEvent event) {
        logger.info(&quot;WebSocket connection established&quot;);
    }

    @EventListener
    public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {
        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());
        String username = (String) headerAccessor.getSessionAttributes().get(&quot;username&quot;);

        if (username != null) {
            logger.info(&quot;User disconnected: &quot; + username);

            ChatMessage chatMessage = new ChatMessage();
            chatMessage.setType(ChatMessage.MessageType.LEAVE);
            chatMessage.setSender(username);

            messagingTemplate.convertAndSend(&quot;/topic/public&quot;, chatMessage);
        }
    }
}
</code></pre>
<ol start="5">
    <li><strong>Client-side JavaScript</strong>:</li>
</ol>
<pre><code class="language-javascript">const socket = new SockJS(&#39;/ws&#39;);
const stompClient = Stomp.over(socket);

// Connect to WebSocket server
stompClient.connect({}, onConnected, onError);

function onConnected() {
    // Subscribe to public topic
    stompClient.subscribe(&#39;/topic/public&#39;, onMessageReceived);

    // Subscribe to private messages
    stompClient.subscribe(&#39;/user/queue/messages&#39;, onPrivateMessage);

    // Send join message
    stompClient.send(&quot;/app/chat.addUser&quot;,
        {},
        JSON.stringify({sender: username, type: &#39;JOIN&#39;})
    );
}

// Send message
function sendMessage() {
    if (message.trim() !== &#39;&#39;) {
        const chatMessage = {
            sender: username,
            content: message,
            type: &#39;CHAT&#39;
        };
        stompClient.send(&quot;/app/chat.sendMessage&quot;, {}, JSON.stringify(chatMessage));
    }
}

// Handle incoming message
function onMessageReceived(payload) {
    const message = JSON.parse(payload.body);
    // Display message in UI
}
</code></pre>
<ol start="6">
    <li><strong>WebSocket security</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {

    @Override
    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
            .simpDestMatchers(&quot;/app/**&quot;).authenticated()
            .simpSubscribeDestMatchers(&quot;/topic/public&quot;).permitAll()
            .simpSubscribeDestMatchers(&quot;/user/**&quot;).authenticated()
            .anyMessage().denyAll();
    }

    @Override
    protected boolean sameOriginDisabled() {
        // Disable CSRF for WebSocket
        return true;
    }
}
</code></pre>
<ol start="7">
    <li><strong>Using SockJS</strong>:</li>
</ol>
<pre><code class="language-html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/stomp-websocket@2.3.4-next/lib/stomp.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="144-what-is-the-spring-boot-actuator-and-how-do-you-secure-its-endpoints">144. What is the Spring Boot Actuator and how do you secure its endpoints?</h3>
<p><strong>Answer:</strong> Spring Boot Actuator provides production-ready features for monitoring and managing applications:</p>
<ol>
    <li><strong>Basic setup</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># Enable specific endpoints
management.endpoints.web.exposure.include=health,info,metrics,loggers,prometheus
</code></pre>
<ol start="2">
    <li><p><strong>Endpoint details</strong>:</p>
        <ul>
            <li><code>/actuator/health</code> - Application health information</li>
            <li><code>/actuator/info</code> - Application information</li>
            <li><code>/actuator/metrics</code> - Application metrics</li>
            <li><code>/actuator/loggers</code> - View and configure loggers</li>
            <li><code>/actuator/prometheus</code> - Metrics in Prometheus format</li>
            <li><code>/actuator/mappings</code> - Request mapping details</li>
            <li><code>/actuator/env</code> - Environment variables</li>
            <li><code>/actuator/beans</code> - Spring bean list</li>
            <li><code>/actuator/httptrace</code> - HTTP request traces</li>
        </ul>
    </li>
    <li><p><strong>Configuration</strong>:</p>
    </li>
</ol>
<pre><code class="language-properties"># Show health details
management.endpoint.health.show-details=always
management.endpoint.health.show-components=always

# Group endpoints
management.endpoint.health.group.readiness.include=db,redis,diskSpace
management.endpoint.health.group.liveness.include=ping

# Custom base path
management.endpoints.web.base-path=/management

# CORS configuration
management.endpoints.web.cors.allowed-origins=https://example.org
management.endpoints.web.cors.allowed-methods=GET,POST
</code></pre>
<ol start="4">
    <li><strong>Security with Spring Security</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class ActuatorSecurity {
    @Bean
    public SecurityFilterChain actuatorSecurityFilterChain(HttpSecurity http) throws Exception {
        http.securityMatcher(EndpointRequest.toAnyEndpoint())
            .authorizeHttpRequests(auth -&gt; {
                auth.requestMatchers(EndpointRequest.to(&quot;health&quot;, &quot;info&quot;)).permitAll();
                auth.requestMatchers(EndpointRequest.toAnyEndpoint()).hasRole(&quot;ACTUATOR&quot;);
                auth.anyRequest().authenticated();
            })
            .httpBasic(Customizer.withDefaults());

        return http.build();
    }
}
</code></pre>
<ol start="5">
    <li><strong>Securing with properties</strong>:</li>
</ol>
<pre><code class="language-properties"># Require role for details
management.endpoint.health.show-details=when_authorized
management.endpoint.health.roles=ACTUATOR_ADMIN

# Separate credentials for management endpoints
spring.security.user.name=admin
spring.security.user.password=admin
spring.security.user.roles=ACTUATOR_ADMIN
</code></pre>
<ol start="6">
    <li><strong>Custom health indicators</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    private final DataSource dataSource;

    @Override
    public Health health() {
        try (Connection conn = dataSource.getConnection()) {
            if (conn.isValid(1)) {
                return Health.up()
                    .withDetail(&quot;database&quot;, &quot;Available&quot;)
                    .build();
            } else {
                return Health.down()
                    .withDetail(&quot;database&quot;, &quot;Unavailable&quot;)
                    .build();
            }
        } catch (SQLException e) {
            return Health.down(e).build();
        }
    }
}
</code></pre>
<ol start="7">
    <li><strong>Custom actuator endpoint</strong>:</li>
</ol>
<pre><code class="language-java">@Component
@Endpoint(id = &quot;application&quot;)
public class ApplicationEndpoint {
    @ReadOperation
    public ApplicationInfo info() {
        return new ApplicationInfo(
            &quot;My Application&quot;,
            &quot;1.0.0&quot;,
            Runtime.getRuntime().availableProcessors(),
            Runtime.getRuntime().maxMemory()
        );
    }

    @WriteOperation
    public void triggerGC() {
        System.gc();
    }
}
</code></pre>
<h3 id="145-how-do-you-implement-asynchronous-operations-in-spring-boot">145. How do you implement asynchronous operations in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot supports asynchronous operations through several techniques:</p>
<ol>
    <li><strong>@Async annotation</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableAsync
public class AsyncConfig {
    @Bean
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix(&quot;Async-&quot;);
        executor.initialize();
        return executor;
    }
}
</code></pre>
<pre><code class="language-java">@Service
public class EmailService {
    @Async
    public CompletableFuture&lt;Boolean&gt; sendEmail(String to, String subject, String content) {
        // Long-running email sending operation
        return CompletableFuture.completedFuture(true);
    }

    @Async
    public void processNotifications() {
        // Fire-and-forget async operation
    }

    @Async
    public ListenableFuture&lt;String&gt; asyncMethod() {
        // Method returning ListenableFuture
        return AsyncResult.forValue(&quot;result&quot;);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Using CompletableFuture</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
public class AsyncController {
    private final AsyncService service;

    @GetMapping(&quot;/async-data&quot;)
    public CompletableFuture&lt;ResponseEntity&lt;Data&gt;&gt; getAsyncData() {
        return service.fetchData()
                .thenApply(data -&gt; ResponseEntity.ok(data))
                .exceptionally(ex -&gt; ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                        .body(null));
    }

    @GetMapping(&quot;/combined-data&quot;)
    public CompletableFuture&lt;CombinedData&gt; getCombinedData() {
        CompletableFuture&lt;UserData&gt; userData = service.fetchUserData();
        CompletableFuture&lt;ProductData&gt; productData = service.fetchProductData();

        return CompletableFuture.allOf(userData, productData)
                .thenApply(v -&gt; new CombinedData(userData.join(), productData.join()));
    }
}
</code></pre>
<ol start="3">
    <li><strong>Callable API controller</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
public class LongRunningController {

    @GetMapping(&quot;/process-long-running&quot;)
    public Callable&lt;String&gt; processLongRunning() {
        return () -&gt; {
            // Long-running operation
            Thread.sleep(5000);
            return &quot;Process completed!&quot;;
        };
    }
}
</code></pre>
<ol start="4">
    <li><strong>DeferredResult</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
public class DeferredController {
    @GetMapping(&quot;/deferred-result&quot;)
    public DeferredResult&lt;ResponseEntity&lt;String&gt;&gt; getDeferredResult() {
        DeferredResult&lt;ResponseEntity&lt;String&gt;&gt; result = new DeferredResult&lt;&gt;(5000L);

        // Process in another thread
        ForkJoinPool.commonPool().submit(() -&gt; {
            try {
                Thread.sleep(1000);
                result.setResult(ResponseEntity.ok(&quot;Deferred result&quot;));
            } catch (Exception e) {
                result.setErrorResult(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                        .body(&quot;Error occurred&quot;));
            }
        });

        return result;
    }
}
</code></pre>
<ol start="5">
    <li><strong>WebFlux reactive endpoints</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ReactiveProductController {
    private final ProductRepository productRepository;

    @GetMapping
    public Flux&lt;Product&gt; getAllProducts() {
        return productRepository.findAll();
    }

    @GetMapping(&quot;/{id}&quot;)
    public Mono&lt;ResponseEntity&lt;Product&gt;&gt; getProductById(@PathVariable String id) {
        return productRepository.findById(id)
                .map(product -&gt; ResponseEntity.ok(product))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}
</code></pre>
<ol start="6">
    <li><strong>Using SpringExecutor with custom thread pool</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableAsync
public class ThreadPoolConfig {
    @Bean(name = &quot;downloadTaskExecutor&quot;)
    public Executor downloadTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix(&quot;Download-&quot;);
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }

    @Bean(name = &quot;emailTaskExecutor&quot;)
    public Executor emailTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix(&quot;Email-&quot;);
        executor.initialize();
        return executor;
    }
}

@Service
public class MultiExecutorService {
    @Async(&quot;downloadTaskExecutor&quot;)
    public CompletableFuture&lt;byte[]&gt; downloadFile(String url) {
        // Download operation
    }

    @Async(&quot;emailTaskExecutor&quot;)
    public void sendEmails(List&lt;String&gt; recipients) {
        // Email sending operation
    }
}
</code></pre>
<h2 id="architecture-patterns-and-advanced-topics">Architecture Patterns and Advanced Topics</h2>
<h3 id="146-how-do-you-implement-database-sharding-in-spring-boot-applications">146. How do you implement database sharding in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Database sharding distributes data across multiple databases:</p>
<ol>
    <li><strong>Using custom routing data source</strong>:</li>
</ol>
<pre><code class="language-java">public class ShardedDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return ShardingContext.getCurrentShardKey();
    }
}

@Configuration
public class ShardingConfig {
    @Bean
    public DataSource shardedDataSource() {
        ShardedDataSource dataSource = new ShardedDataSource();

        Map&lt;Object, Object&gt; dataSources = new HashMap&lt;&gt;();
        dataSources.put(&quot;shard1&quot;, createDataSource(&quot;jdbc:mysql://shard1:3306/db&quot;));
        dataSources.put(&quot;shard2&quot;, createDataSource(&quot;jdbc:mysql://shard2:3306/db&quot;));
        dataSources.put(&quot;shard3&quot;, createDataSource(&quot;jdbc:mysql://shard3:3306/db&quot;));

        dataSource.setTargetDataSources(dataSources);
        dataSource.setDefaultTargetDataSource(dataSources.get(&quot;shard1&quot;));

        return dataSource;
    }

    private DataSource createDataSource(String url) {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl(url);
        ds.setUsername(&quot;user&quot;);
        ds.setPassword(&quot;password&quot;);
        return ds;
    }
}
</code></pre>
<ol start="2">
    <li><strong>Shard selection based on tenant ID</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class TenantShardInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request,
                           HttpServletResponse response,
                           Object handler) {
        String tenantId = request.getHeader(&quot;X-Tenant-ID&quot;);
        if (tenantId != null) {
            String shardKey = determineShardKey(tenantId);
            ShardingContext.setCurrentShardKey(shardKey);
        }
        return true;
    }

    private String determineShardKey(String tenantId) {
        // Simple hash-based shard selection
        int hash = Math.abs(tenantId.hashCode() % 3);
        return &quot;shard&quot; + (hash + 1);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Using Hibernate Shards</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate.shards&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-shards&lt;/artifactId&gt;
    &lt;version&gt;3.0.0.B2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class HibernateShardConfig {
    @Bean
    public SessionFactory shardedSessionFactory() {
        // Create session factories for individual shards
        List&lt;SessionFactory&gt; sessionFactories = new ArrayList&lt;&gt;();
        sessionFactories.add(createSessionFactory(&quot;shard0&quot;));
        sessionFactories.add(createSessionFactory(&quot;shard1&quot;));

        // Create shard configuration
        List&lt;ShardConfiguration&gt; shardConfigs = new ArrayList&lt;&gt;();
        shardConfigs.add(buildShardConfig(&quot;shard0&quot;));
        shardConfigs.add(buildShardConfig(&quot;shard1&quot;));

        // Create shard strategy
        ShardStrategyFactory shardStrategyFactory = buildShardStrategyFactory();

        // Create sharded session factory
        return new ShardedSessionFactoryImpl(
            sessionFactories,
            shardConfigs,
            shardStrategyFactory
        );
    }

    // Helper methods omitted for brevity
}
</code></pre>
<ol start="4">
    <li><strong>Horizontal partitioning with JPA</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Table(name = &quot;customer&quot;)
public class Customer {
    @Id
    private Long id;
    private String name;

    @Column(name = &quot;shard_key&quot;)
    private String shardKey;

    // getters and setters
}

@Repository
public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt; {
    @Query(value = &quot;SELECT * FROM customer WHERE id = :id AND shard_key = :shardKey&quot;,
           nativeQuery = true)
    Optional&lt;Customer&gt; findByIdAndShardKey(@Param(&quot;id&quot;) Long id, @Param(&quot;shardKey&quot;) String shardKey);
}

@Service
public class CustomerService {
    private final CustomerRepository repository;

    public Customer getCustomerById(Long id) {
        // Calculate shard key based on ID
        String shardKey = calculateShardKey(id);
        ShardingContext.setCurrentShardKey(shardKey);

        return repository.findByIdAndShardKey(id, shardKey)
                .orElseThrow(() -&gt; new EntityNotFoundException(&quot;Customer not found&quot;));
    }

    private String calculateShardKey(Long id) {
        return &quot;shard&quot; + (id % 3 + 1);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Using a third-party sharding library</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;
    &lt;artifactId&gt;shardingsphere-jdbc-core&lt;/artifactId&gt;
    &lt;version&gt;5.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class ShardingSphereConfig {
    @Bean
    public DataSource shardingDataSource() throws SQLException {
        // Configure actual data sources
        Map&lt;String, DataSource&gt; dataSourceMap = new HashMap&lt;&gt;();
        dataSourceMap.put(&quot;ds0&quot;, createDataSource(&quot;jdbc:mysql://shard1:3306/db&quot;));
        dataSourceMap.put(&quot;ds1&quot;, createDataSource(&quot;jdbc:mysql://shard2:3306/db&quot;));

        // Configure sharding rule
        ShardingRuleConfiguration shardingRuleConfig = new ShardingRuleConfiguration();

        // Configure table rules
        ShardingTableRuleConfiguration orderTableRule =
                new ShardingTableRuleConfiguration(&quot;orders&quot;, &quot;ds${0..1}.orders&quot;);

        // Configure sharding strategy
        orderTableRule.setDatabaseShardingStrategy(
                new StandardShardingStrategyConfiguration(&quot;customer_id&quot;, &quot;dbShardingAlgorithm&quot;));

        shardingRuleConfig.getTables().add(orderTableRule);

        // Create sharded data source
        return ShardingSphereDataSourceFactory.createDataSource(
                dataSourceMap,
                Collections.singleton(shardingRuleConfig),
                new Properties());
    }

    private DataSource createDataSource(String url) {
        // Create data source
    }
}
</code></pre>
<h3 id="147-how-do-you-implement-api-gateway-pattern-in-spring-boot">147. How do you implement API Gateway pattern in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Cloud Gateway provides API Gateway capabilities:</p>
<ol>
    <li><strong>Add dependency</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Route configuration with YAML</strong>:</li>
</ol>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://USER-SERVICE
          predicates:
            - Path=/api/users/**
          filters:
            - StripPrefix=1
            - AddRequestHeader=X-Source, gateway

        - id: product-service
          uri: lb://PRODUCT-SERVICE
          predicates:
            - Path=/api/products/**
            - Method=GET,POST
          filters:
            - StripPrefix=1
            - AddResponseHeader=X-Response-Source, gateway
</code></pre>
<ol start="3">
    <li><strong>Programmatic route configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class GatewayConfig {
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            .route(&quot;user-service&quot;, r -&gt; r
                .path(&quot;/api/users/**&quot;)
                .filters(f -&gt; f
                    .stripPrefix(1)
                    .addRequestHeader(&quot;X-Source&quot;, &quot;gateway&quot;))
                .uri(&quot;lb://USER-SERVICE&quot;))
            .route(&quot;order-service&quot;, r -&gt; r
                .path(&quot;/api/orders/**&quot;)
                .and().method(&quot;GET&quot;, &quot;POST&quot;)
                .filters(f -&gt; f
                    .stripPrefix(1)
                    .requestRateLimiter(c -&gt; c
                        .setRateLimiter(redisRateLimiter())
                        .setKeyResolver(userKeyResolver())))
                .uri(&quot;lb://ORDER-SERVICE&quot;))
            .build();
    }

    @Bean
    public RedisRateLimiter redisRateLimiter() {
        return new RedisRateLimiter(5, 10);
    }

    @Bean
    public KeyResolver userKeyResolver() {
        return exchange -&gt; Mono.just(
            exchange.getRequest().getHeaders().getFirst(&quot;X-User-ID&quot;) != null
                ? exchange.getRequest().getHeaders().getFirst(&quot;X-User-ID&quot;)
                : exchange.getRequest().getRemoteAddress().getAddress().getHostAddress()
        );
    }
}
</code></pre>
<ol start="4">
    <li><strong>Custom filter implementation</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class LoggingFilter implements GlobalFilter {
    private final Logger log = LoggerFactory.getLogger(LoggingFilter.class);

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String path = exchange.getRequest().getPath().toString();
        String method = exchange.getRequest().getMethod().toString();

        log.info(&quot;Request: {} {}&quot;, method, path);

        return chain.filter(exchange)
            .then(Mono.fromRunnable(() -&gt; {
                int statusCode = exchange.getResponse().getStatusCode().value();
                log.info(&quot;Response status: {} for {} {}&quot;, statusCode, method, path);
            }));
    }
}
</code></pre>
<ol start="5">
    <li><strong>Gateway filter factory</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class AuthenticationGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;AuthenticationGatewayFilterFactory.Config&gt; {

    public AuthenticationGatewayFilterFactory() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -&gt; {
            String authHeader = exchange.getRequest().getHeaders().getFirst(&quot;Authorization&quot;);

            if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {
                exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                return exchange.getResponse().setComplete();
            }

            // Validate JWT token

            return chain.filter(exchange);
        };
    }

    public static class Config {
        // Configuration properties
    }
}
</code></pre>
<ol start="6">
    <li><strong>Route configuration with custom filter</strong>:</li>
</ol>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      routes:
        - id: secure-service
          uri: lb://SECURE-SERVICE
          predicates:
            - Path=/api/secure/**
          filters:
            - StripPrefix=1
            - Authentication
</code></pre>
<ol start="7">
    <li><strong>Circuit breaker integration</strong>:</li>
</ol>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      routes:
        - id: payment-service
          uri: lb://PAYMENT-SERVICE
          predicates:
            - Path=/api/payments/**
          filters:
            - name: CircuitBreaker
              args:
                name: paymentServiceCircuitBreaker
                fallbackUri: forward:/fallback/payment
</code></pre>
<h3 id="148-what-are-the-different-ways-to-handle-transaction-management-in-spring-boot">148. What are the different ways to handle transaction management in Spring Boot?</h3>
<p><strong>Answer:</strong> Transaction management in Spring Boot offers several approaches:</p>
<ol>
    <li><strong>Declarative transaction management using @Transactional</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderService {
    private final OrderRepository orderRepository;
    private final PaymentService paymentService;

    @Transactional
    public Order placeOrder(Order order) {
        Order savedOrder = orderRepository.save(order);
        paymentService.processPayment(order.getPayment());
        return savedOrder;
    }

    @Transactional(readOnly = true)
    public List&lt;Order&gt; getAllOrders() {
        return orderRepository.findAll();
    }

    @Transactional(rollbackFor = PaymentFailedException.class)
    public Order updateOrder(Order order) throws PaymentFailedException {
        // Business logic
    }
}
</code></pre>
<ol start="2">
    <li><strong>Transaction propagation options</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class PaymentService {
    @Transactional(propagation = Propagation.REQUIRED)
    public void processPayment(Payment payment) {
        // Default behavior - uses current transaction or creates new one
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void auditPayment(Payment payment) {
        // Always creates a new transaction
    }

    @Transactional(propagation = Propagation.SUPPORTS)
    public Payment getPayment(String id) {
        // Runs in transaction if one exists, otherwise non-transactional
    }

    @Transactional(propagation = Propagation.MANDATORY)
    public void validatePayment(Payment payment) {
        // Must be called from within an existing transaction
    }

    @Transactional(propagation = Propagation.NEVER)
    public void logPayment(Payment payment) {
        // Must not be called from within a transaction
    }
}
</code></pre>
<ol start="3">
    <li><strong>Transaction isolation levels</strong>:</li>
</ol>
<pre><code class="language-java">@Transactional(isolation = Isolation.READ_COMMITTED)
public void updateInventory(Long productId, int quantity) {
    // Uses READ_COMMITTED isolation level
}

@Transactional(isolation = Isolation.SERIALIZABLE)
public void transferFunds(Long fromAccount, Long toAccount, BigDecimal amount) {
    // Uses SERIALIZABLE isolation level (highest)
}
</code></pre>
<ol start="4">
    <li><strong>Programmatic transaction management</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderService {
    private final TransactionTemplate transactionTemplate;
    private final OrderRepository orderRepository;

    public Order createOrder(final Order order) {
        return transactionTemplate.execute(status -&gt; {
            try {
                Order savedOrder = orderRepository.save(order);
                if (!paymentService.processPayment(order.getPayment())) {
                    status.setRollbackOnly();
                    throw new PaymentFailedException();
                }
                return savedOrder;
            } catch (Exception e) {
                status.setRollbackOnly();
                throw e;
            }
        });
    }

    public void deleteOrder(Long orderId) {
        transactionTemplate.executeWithoutResult(status -&gt; {
            orderRepository.deleteById(orderId);
        });
    }
}
</code></pre>
<ol start="5">
    <li><strong>TransactionTemplate configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class TransactionConfig {
    @Bean
    public TransactionTemplate transactionTemplate(PlatformTransactionManager transactionManager) {
        TransactionTemplate template = new TransactionTemplate(transactionManager);
        template.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
        template.setTimeout(30); // 30 seconds
        return template;
    }

    @Bean
    public TransactionTemplate readOnlyTransactionTemplate(PlatformTransactionManager transactionManager) {
        TransactionTemplate template = new TransactionTemplate(transactionManager);
        template.setReadOnly(true);
        return template;
    }
}
</code></pre>
<ol start="6">
    <li><strong>Low-level transaction management with TransactionManager</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class LowLevelTransactionService {
    private final PlatformTransactionManager transactionManager;
    private final OrderRepository orderRepository;

    public Order createOrderWithLowLevelTx(Order order) {
        TransactionStatus status = transactionManager.getTransaction(
            new DefaultTransactionDefinition());

        try {
            Order savedOrder = orderRepository.save(order);

            // Commit the transaction
            transactionManager.commit(status);

            return savedOrder;
        } catch (Exception e) {
            // Roll back the transaction
            transactionManager.rollback(status);
            throw e;
        }
    }
}
</code></pre>
<ol start="7">
    <li><strong>Multiple transaction managers</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class MultipleTransactionManagersConfig {
    @Bean
    public DataSourceTransactionManager ordersTxManager(
            @Qualifier(&quot;ordersDataSource&quot;) DataSource ordersDataSource) {
        return new DataSourceTransactionManager(ordersDataSource);
    }

    @Bean
    public JpaTransactionManager inventoryTxManager(EntityManagerFactory inventoryEmf) {
        return new JpaTransactionManager(inventoryEmf);
    }
}

@Service
public class OrderService {
    private final TransactionTemplate ordersTxTemplate;

    public OrderService(
            @Qualifier(&quot;ordersTxManager&quot;) PlatformTransactionManager txManager) {
        this.ordersTxTemplate = new TransactionTemplate(txManager);
    }

    @Transactional(&quot;ordersTxManager&quot;)
    public Order createOrder(Order order) {
        // Uses orders transaction manager
    }
}
</code></pre>
<h3 id="149-how-do-you-implement-a-distributed-cache-in-spring-boot-applications">149. How do you implement a distributed cache in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Spring Boot supports distributed caching through several providers:</p>
<ol>
    <li><strong>Redis cache implementation</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableCaching
public class RedisCacheConfig {
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration defaultConfig = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(10))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(defaultConfig)
            .withCacheConfiguration(&quot;products&quot;,
                defaultConfig.entryTtl(Duration.ofHours(1)))
            .withCacheConfiguration(&quot;users&quot;,
                defaultConfig.entryTtl(Duration.ofMinutes(5)))
            .build();
    }
}
</code></pre>
<ol start="2">
    <li><strong>Hazelcast distributed cache</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast-spring&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableCaching
public class HazelcastCacheConfig {
    @Bean
    public HazelcastInstance hazelcastInstance() {
        Config config = new Config();
        config.setInstanceName(&quot;cache-instance&quot;);

        NetworkConfig networkConfig = config.getNetworkConfig();
        JoinConfig joinConfig = networkConfig.getJoin();
        joinConfig.getMulticastConfig().setEnabled(true);
        joinConfig.getTcpIpConfig().setEnabled(false);

        MapConfig productsCache = new MapConfig(&quot;products&quot;);
        productsCache.setTimeToLiveSeconds(3600); // 1 hour
        productsCache.setMaxIdleSeconds(600);     // 10 minutes
        config.addMapConfig(productsCache);

        return Hazelcast.newHazelcastInstance(config);
    }

    @Bean
    public CacheManager cacheManager(HazelcastInstance hazelcastInstance) {
        return new HazelcastCacheManager(hazelcastInstance);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Memcached with XMemcached</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.googlecode.xmemcached&lt;/groupId&gt;
    &lt;artifactId&gt;xmemcached&lt;/artifactId&gt;
    &lt;version&gt;2.4.7&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableCaching
public class MemcachedConfig {
    @Bean
    public MemcachedClient memcachedClient() throws IOException {
        MemcachedClientBuilder builder = new XMemcachedClientBuilder(
            AddrUtil.getAddresses(&quot;memcached-server1:11211,memcached-server2:11211&quot;));
        builder.setConnectionPoolSize(10);
        builder.setOpTimeout(3000); // 3 seconds
        return builder.build();
    }

    @Bean
    public CacheManager cacheManager(MemcachedClient client) {
        SimpleCacheManager cacheManager = new SimpleCacheManager();

        MemcachedCache productsCache = new MemcachedCache(&quot;products&quot;, 3600, client);
        MemcachedCache usersCache = new MemcachedCache(&quot;users&quot;, 300, client);

        cacheManager.setCaches(Arrays.asList(productsCache, usersCache));
        return cacheManager;
    }
}
</code></pre>
<ol start="4">
    <li><strong>Caffeine with Redis fallback (multi-level cache)</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableCaching
public class MultiLevelCacheConfig {
    @Bean
    public CacheManager cacheManager(
            RedisConnectionFactory redisConnectionFactory) {
        // First level: Caffeine (local) cache
        CaffeineCacheManager caffeineCacheManager = new CaffeineCacheManager();
        caffeineCacheManager.setCaffeine(Caffeine.newBuilder()
            .expireAfterWrite(5, TimeUnit.MINUTES)
            .maximumSize(1000));

        // Second level: Redis (distributed) cache
        RedisCacheManager redisCacheManager = RedisCacheManager.builder(redisConnectionFactory)
            .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(1)))
            .build();

        // Combine into multi-level cache
        return new CompositeCacheManager(caffeineCacheManager, redisCacheManager);
    }
}

@Component
public class CompositeCacheManager implements CacheManager {
    private final CacheManager localCacheManager;
    private final CacheManager remoteCacheManager;

    @Override
    public Cache getCache(String name) {
        Cache localCache = localCacheManager.getCache(name);
        Cache remoteCache = remoteCacheManager.getCache(name);

        return new CompositeCache(name, localCache, remoteCache);
    }

    // CompositeCache implementation details omitted for brevity
}
</code></pre>
<ol start="5">
    <li><strong>Using cache with services</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class ProductService {
    private final ProductRepository productRepository;

    @Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;, unless = &quot;#result == null&quot;)
    public Product getProductById(Long id) {
        return productRepository.findById(id).orElse(null);
    }

    @CachePut(value = &quot;products&quot;, key = &quot;#product.id&quot;)
    public Product updateProduct(Product product) {
        return productRepository.save(product);
    }

    @CacheEvict(value = &quot;products&quot;, key = &quot;#id&quot;)
    public void deleteProduct(Long id) {
        productRepository.deleteById(id);
    }

    @CacheEvict(value = &quot;products&quot;, allEntries = true)
    public void clearProductCache() {
        // Method to clear all product cache entries
    }
}
</code></pre>
<ol start="6">
    <li><strong>Cache synchronization across nodes</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class CacheSyncConfig {
    @Bean
    public RedisCacheWriter redisCacheWriter(RedisConnectionFactory connectionFactory) {
        return RedisCacheWriter.lockingRedisCacheWriter(connectionFactory);
    }

    @Bean
    public RedisMessageListenerContainer redisMessageListenerContainer(
            RedisConnectionFactory connectionFactory) {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        return container;
    }

    @Bean
    public CacheMessageListener cacheMessageListener(
            RedisMessageListenerContainer listenerContainer,
            CaffeineCacheManager caffeineCacheManager) {
        CacheMessageListener listener = new CacheMessageListener(caffeineCacheManager);
        listenerContainer.addMessageListener(
            listener, new ChannelTopic(&quot;cache:invalidate&quot;));
        return listener;
    }
}

@Component
public class CacheInvalidationService {
    private final RedisTemplate&lt;String, String&gt; redisTemplate;

    public void invalidateCache(String cacheName, String key) {
        Map&lt;String, String&gt; message = new HashMap&lt;&gt;();
        message.put(&quot;cacheName&quot;, cacheName);
        message.put(&quot;key&quot;, key);

        redisTemplate.convertAndSend(
            &quot;cache:invalidate&quot;,
            new ObjectMapper().writeValueAsString(message)
        );
    }
}
</code></pre>
<h3 id="150-what-design-patterns-are-commonly-used-in-spring-boot-applications">150. What design patterns are commonly used in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Spring Boot applications frequently use these design patterns:</p>
<ol>
    <li><strong>Dependency Injection and Inversion of Control</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderService {
    private final ProductRepository productRepository;
    private final CustomerRepository customerRepository;
    private final PaymentGateway paymentGateway;

    // Constructor injection
    public OrderService(
            ProductRepository productRepository,
            CustomerRepository customerRepository,
            PaymentGateway paymentGateway) {
        this.productRepository = productRepository;
        this.customerRepository = customerRepository;
        this.paymentGateway = paymentGateway;
    }

    // Service methods
}
</code></pre>
<ol start="2">
    <li><strong>Singleton Pattern</strong> (default scope for Spring beans):</li>
</ol>
<pre><code class="language-java">@Service
public class UserService {
    // This is a singleton by default
}

@Service
@Scope(&quot;prototype&quot;)
public class NonSingletonService {
    // This is not a singleton
}
</code></pre>
<ol start="3">
    <li><strong>Factory Pattern</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class PaymentProcessorFactory {
    @Bean
    public PaymentProcessor paymentProcessor(
            @Value(&quot;${payment.gateway.type}&quot;) String gatewayType) {
        if (&quot;stripe&quot;.equals(gatewayType)) {
            return new StripePaymentProcessor();
        } else if (&quot;paypal&quot;.equals(gatewayType)) {
            return new PaypalPaymentProcessor();
        } else {
            return new DefaultPaymentProcessor();
        }
    }
}
</code></pre>
<ol start="4">
    <li><strong>Builder Pattern</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
public class ResponseBuilder {
    @GetMapping(&quot;/complex-data&quot;)
    public ResponseEntity&lt;ComplexResponse&gt; getComplexData() {
        ComplexResponse response = ComplexResponse.builder()
            .withId(123L)
            .withName(&quot;Sample&quot;)
            .withItems(Arrays.asList(&quot;Item1&quot;, &quot;Item2&quot;))
            .withValidUntil(LocalDate.now().plusDays(30))
            .build();

        return ResponseEntity.ok(response);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Strategy Pattern</strong>:</li>
</ol>
<pre><code class="language-java">public interface NotificationStrategy {
    void sendNotification(User user, String message);
}

@Component
@Qualifier(&quot;email&quot;)
public class EmailNotificationStrategy implements NotificationStrategy {
    @Override
    public void sendNotification(User user, String message) {
        // Send email
    }
}

@Component
@Qualifier(&quot;sms&quot;)
public class SmsNotificationStrategy implements NotificationStrategy {
    @Override
    public void sendNotification(User user, String message) {
        // Send SMS
    }
}

@Service
public class NotificationService {
    private final Map&lt;String, NotificationStrategy&gt; strategies;

    public NotificationService(List&lt;NotificationStrategy&gt; strategyList) {
        this.strategies = strategyList.stream()
            .collect(Collectors.toMap(strategy -&gt;
                strategy.getClass().getAnnotation(Qualifier.class).value(),
                Function.identity()));
    }

    public void sendNotification(User user, String message, String type) {
        NotificationStrategy strategy = strategies.get(type);
        if (strategy != null) {
            strategy.sendNotification(user, message);
        } else {
            throw new IllegalArgumentException(&quot;Unknown notification type: &quot; + type);
        }
    }
}
</code></pre>
<ol start="6">
    <li><strong>Template Method Pattern</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public abstract class PaymentProcessor {
    public final PaymentResult processPayment(Payment payment) {
        // Template method
        validatePayment(payment);
        PaymentResult result = doProcessPayment(payment);
        sendReceipt(payment, result);
        return result;
    }

    protected abstract PaymentResult doProcessPayment(Payment payment);

    protected void validatePayment(Payment payment) {
        // Default implementation
    }

    protected void sendReceipt(Payment payment, PaymentResult result) {
        // Default implementation
    }
}

@Component
public class CreditCardProcessor extends PaymentProcessor {
    @Override
    protected PaymentResult doProcessPayment(Payment payment) {
        // Credit card processing implementation
    }
}

@Component
public class PayPalProcessor extends PaymentProcessor {
    @Override
    protected PaymentResult doProcessPayment(Payment payment) {
        // PayPal processing implementation
    }

    @Override
    protected void validatePayment(Payment payment) {
        // PayPal-specific validation
    }
}
</code></pre>
<ol start="7">
    <li><strong>Observer Pattern</strong> (with Spring Events):</li>
</ol>
<pre><code class="language-java">// Event class
public class OrderCreatedEvent extends ApplicationEvent {
    private final Order order;

    public OrderCreatedEvent(Object source, Order order) {
        super(source);
        this.order = order;
    }

    public Order getOrder() {
        return order;
    }
}

// Publisher
@Service
public class OrderService {
    private final ApplicationEventPublisher eventPublisher;
    private final OrderRepository orderRepository;

    public Order createOrder(Order order) {
        Order savedOrder = orderRepository.save(order);
        eventPublisher.publishEvent(new OrderCreatedEvent(this, savedOrder));
        return savedOrder;
    }
}

// Listeners
@Component
public class EmailNotificationListener {
    @EventListener
    public void handleOrderCreatedEvent(OrderCreatedEvent event) {
        // Send order confirmation email
    }
}

@Component
public class InventoryListener {
    @EventListener
    public void handleOrderCreatedEvent(OrderCreatedEvent event) {
        // Update inventory
    }
}
</code></pre>
<ol start="8">
    <li><strong>Repository Pattern</strong>:</li>
</ol>
<pre><code class="language-java">public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {
    List&lt;Order&gt; findByCustomerId(Long customerId);
    List&lt;Order&gt; findByStatusAndCreatedDateAfter(OrderStatus status, LocalDateTime date);

    @Query(&quot;SELECT o FROM Order o WHERE o.total &gt; :amount&quot;)
    List&lt;Order&gt; findLargeOrders(@Param(&quot;amount&quot;) BigDecimal amount);
}
</code></pre>
<ol start="9">
    <li><strong>Proxy Pattern</strong> (via AOP):</li>
</ol>
<pre><code class="language-java">@Aspect
@Component
public class LoggingAspect {
    private final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

    @Around(&quot;@annotation(Loggable)&quot;)
    public Object logExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        logger.info(&quot;Starting execution of {}&quot;, methodName);

        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long end = System.currentTimeMillis();

        logger.info(&quot;Method {} executed in {} ms&quot;, methodName, (end - start));
        return result;
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Loggable {
}

@Service
public class ProductService {
    @Loggable
    public List&lt;Product&gt; findProducts(String query) {
        // Method implementation
    }
}
</code></pre>
<ol start="10">
    <li><strong>Chain of Responsibility Pattern</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public abstract class RequestValidator {
    private RequestValidator next;

    public void setNext(RequestValidator next) {
        this.next = next;
    }

    public void validate(Request request) throws ValidationException {
        doValidate(request);

        if (next != null) {
            next.validate(request);
        }
    }

    protected abstract void doValidate(Request request) throws ValidationException;
}

@Component
@Order(1)
public class AuthenticationValidator extends RequestValidator {
    @Override
    protected void doValidate(Request request) throws ValidationException {
        // Authentication validation
    }
}

@Component
@Order(2)
public class PermissionValidator extends RequestValidator {
    @Override
    protected void doValidate(Request request) throws ValidationException {
        // Permission validation
    }
}

@Configuration
public class ValidatorChainConfig {
    @Bean
    public RequestValidator validatorChain(List&lt;RequestValidator&gt; validators) {
        // Sort validators by @Order
        validators.sort(Comparator.comparing(v -&gt;
            v.getClass().getAnnotation(Order.class).value()));

        // Create chain
        for (int i = 0; i &lt; validators.size() - 1; i++) {
            validators.get(i).setNext(validators.get(i + 1));
        }

        // Return first validator in chain
        return validators.get(0);
    }
}
</code></pre>
<h3 id="151-how-do-you-handle-logging-in-spring-boot-applications">151. How do you handle logging in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Logging in Spring Boot is done through the included Logback implementation:</p>
<ol>
    <li><strong>Basic configuration</strong>:</li>
</ol>
<pre><code class="language-properties"># application.properties
logging.level.root=INFO
logging.level.org.springframework.web=DEBUG
logging.level.com.example.myapp=TRACE

# Output to file
logging.file.name=app.log
logging.file.path=/var/logs

# Log pattern
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
</code></pre>
<ol start="2">
    <li><strong>Custom logback configuration</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;!-- logback-spring.xml --&gt;
&lt;configuration&gt;
    &lt;property name=&quot;LOG_PATH&quot; value=&quot;${LOG_PATH:-./logs}&quot;/&gt;

    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;file&gt;${LOG_PATH}/application.log&lt;/file&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;${LOG_PATH}/application-%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;logger name=&quot;com.example.myapp&quot; level=&quot;DEBUG&quot;/&gt;
    &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;/&gt;

    &lt;root level=&quot;INFO&quot;&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<ol start="3">
    <li><strong>Profile-specific logging</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;configuration&gt;
    &lt;!-- Base configuration --&gt;

    &lt;springProfile name=&quot;dev&quot;&gt;
        &lt;root level=&quot;DEBUG&quot;&gt;
            &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
            &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;/root&gt;
    &lt;/springProfile&gt;

    &lt;springProfile name=&quot;prod&quot;&gt;
        &lt;root level=&quot;WARN&quot;&gt;
            &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;/root&gt;
    &lt;/springProfile&gt;
&lt;/configuration&gt;
</code></pre>
<ol start="4">
    <li><strong>JSON logging for production</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;configuration&gt;
    &lt;appender name=&quot;JSON_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;file&gt;${LOG_PATH}/application.json&lt;/file&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;${LOG_PATH}/application-%d{yyyy-MM-dd}-%i.json&lt;/fileNamePattern&gt;
            &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;/&gt;
    &lt;/appender&gt;

    &lt;springProfile name=&quot;prod&quot;&gt;
        &lt;root level=&quot;INFO&quot;&gt;
            &lt;appender-ref ref=&quot;JSON_FILE&quot;/&gt;
        &lt;/root&gt;
    &lt;/springProfile&gt;
&lt;/configuration&gt;
</code></pre>
<ol start="5">
    <li><strong>Using SLF4J in application code</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class UserService {
    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    public User createUser(User user) {
        logger.debug(&quot;Creating user: {}&quot;, user.getUsername());

        try {
            User savedUser = userRepository.save(user);
            logger.info(&quot;User created with ID: {}&quot;, savedUser.getId());
            return savedUser;
        } catch (Exception e) {
            logger.error(&quot;Error creating user: {}&quot;, user.getUsername(), e);
            throw e;
        }
    }
}
</code></pre>
<ol start="6">
    <li><strong>MDC (Mapped Diagnostic Context)</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class RequestLoggingFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        try {
            // Add context data to logs
            MDC.put(&quot;requestId&quot;, UUID.randomUUID().toString());
            MDC.put(&quot;clientIP&quot;, request.getRemoteAddr());
            MDC.put(&quot;userAgent&quot;, request.getHeader(&quot;User-Agent&quot;));

            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            if (auth != null &amp;&amp; auth.isAuthenticated()) {
                MDC.put(&quot;username&quot;, auth.getName());
            }

            filterChain.doFilter(request, response);
        } finally {
            MDC.clear();
        }
    }
}
</code></pre>
<pre><code class="language-xml">&lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] [%X{requestId}] [%X{username}] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
</code></pre>
<ol start="7">
    <li><strong>Customizing Log Levels at Runtime</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/actuator/loggers&quot;)
public class LoggersController {
    private final LoggerContext loggerContext;

    public LoggersController() {
        this.loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
    }

    @GetMapping(&quot;/{name}&quot;)
    public Map&lt;String, String&gt; getLoggerLevel(@PathVariable String name) {
        Logger logger = loggerContext.getLogger(name);
        Level level = logger.getLevel();
        Level effectiveLevel = logger.getEffectiveLevel();

        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();
        result.put(&quot;configuredLevel&quot;, level != null ? level.toString() : null);
        result.put(&quot;effectiveLevel&quot;, effectiveLevel.toString());
        return result;
    }

    @PutMapping(&quot;/{name}&quot;)
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void configureLogLevel(@PathVariable String name,
                                @RequestBody LogLevelRequest request) {
        Level level = request.getConfiguredLevel() != null ?
            Level.toLevel(request.getConfiguredLevel()) : null;
        loggerContext.getLogger(name).setLevel(level);
    }

    public static class LogLevelRequest {
        private String configuredLevel;

        // Getter and setter
    }
}
</code></pre>
<ol start="8">
    <li><strong>Setting up logging with ELK stack</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;
    &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;
    &lt;version&gt;6.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-xml">&lt;configuration&gt;
    &lt;appender name=&quot;LOGSTASH&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;
        &lt;destination&gt;logstash-host:5000&lt;/destination&gt;
        &lt;encoder class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&gt;
            &lt;customFields&gt;{&quot;app_name&quot;:&quot;my-application&quot;,&quot;env&quot;:&quot;${SPRING_PROFILES_ACTIVE}&quot;}&lt;/customFields&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;root level=&quot;INFO&quot;&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
        &lt;appender-ref ref=&quot;LOGSTASH&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="152-how-do-you-handle-authentication-and-authorization-in-spring-boot-applications">152. How do you handle authentication and authorization in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Spring Boot provides several approaches for authentication and authorization:</p>
<ol>
    <li><strong>Basic setup with Spring Security</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -&gt; auth
                .requestMatchers(&quot;/api/public/**&quot;).permitAll()
                .requestMatchers(&quot;/api/users/**&quot;).hasRole(&quot;USER&quot;)
                .requestMatchers(&quot;/api/admin/**&quot;).hasRole(&quot;ADMIN&quot;)
                .anyRequest().authenticated()
            )
            .formLogin(form -&gt; form
                .loginPage(&quot;/login&quot;)
                .permitAll()
            )
            .logout(logout -&gt; logout
                .logoutUrl(&quot;/logout&quot;)
                .logoutSuccessUrl(&quot;/login?logout&quot;)
            );

        return http.build();
    }
}
</code></pre>
<ol start="2">
    <li><strong>Custom user details service</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class CustomUserDetailsService implements UserDetailsService {
    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;User not found: &quot; + username));

        return new org.springframework.security.core.userdetails.User(
            user.getUsername(),
            user.getPassword(),
            getAuthorities(user.getRoles())
        );
    }

    private Collection&lt;? extends GrantedAuthority&gt; getAuthorities(Collection&lt;Role&gt; roles) {
        return roles.stream()
            .map(role -&gt; new SimpleGrantedAuthority(&quot;ROLE_&quot; + role.getName()))
            .collect(Collectors.toList());
    }
}
</code></pre>
<ol start="3">
    <li><strong>JWT authentication</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class JwtTokenProvider {
    private final String jwtSecret;
    private final long jwtExpirationMs;

    public String generateToken(Authentication authentication) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationMs);

        UserDetails userDetails = (UserDetails) authentication.getPrincipal();

        return Jwts.builder()
            .setSubject(userDetails.getUsername())
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(Keys.hmacShaKeyFor(jwtSecret.getBytes()), SignatureAlgorithm.HS512)
            .compact();
    }

    public String getUsernameFromToken(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(Keys.hmacShaKeyFor(jwtSecret.getBytes()))
            .build()
            .parseClaimsJws(token)
            .getBody()
            .getSubject();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(Keys.hmacShaKeyFor(jwtSecret.getBytes()))
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
</code></pre>
<ol start="4">
    <li><strong>JWT authentication filter</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtTokenProvider tokenProvider;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt) &amp;&amp; tokenProvider.validateToken(jwt)) {
                String username = tokenProvider.getUsernameFromToken(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                    );

                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            logger.error(&quot;Cannot set user authentication&quot;, e);
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader(&quot;Authorization&quot;);
        if (StringUtils.hasText(bearerToken) &amp;&amp; bearerToken.startsWith(&quot;Bearer &quot;)) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
</code></pre>
<ol start="5">
    <li><strong>JWT configuration with Spring Security</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
            .authorizeHttpRequests(auth -&gt; auth
                .requestMatchers(&quot;/api/auth/**&quot;).permitAll()
                .anyRequest().authenticated()
            );

        return http.build();
    }
}
</code></pre>
<ol start="6">
    <li><strong>Method-level security</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableMethodSecurity
public class MethodSecurityConfig {
    // Configuration if needed
}

@Service
public class UserService {
    @PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)
    public List&lt;User&gt; getAllUsers() {
        // Only accessible to admins
        return userRepository.findAll();
    }

    @PreAuthorize(&quot;hasRole(&#39;USER&#39;) and #username == authentication.name&quot;)
    public User getUserProfile(String username) {
        // Users can only access their own profile
        return userRepository.findByUsername(username);
    }
}
</code></pre>
<ol start="7">
    <li><strong>OAuth2 resource server</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class ResourceServerConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -&gt; auth
                .requestMatchers(&quot;/api/public/**&quot;).permitAll()
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .jwtAuthenticationConverter(jwtAuthenticationConverter())
                )
            );

        return http.build();
    }

    private JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
        converter.setAuthoritiesClaimName(&quot;roles&quot;);
        converter.setAuthorityPrefix(&quot;ROLE_&quot;);

        JwtAuthenticationConverter jwtConverter = new JwtAuthenticationConverter();
        jwtConverter.setJwtGrantedAuthoritiesConverter(converter);
        return jwtConverter;
    }
}
</code></pre>
<ol start="8">
    <li><strong>OAuth2 login</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class OAuth2ClientConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -&gt; auth
                .requestMatchers(&quot;/&quot;, &quot;/login**&quot;, &quot;/error**&quot;).permitAll()
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth2 -&gt; oauth2
                .loginPage(&quot;/login&quot;)
                .userInfoEndpoint(userInfo -&gt; userInfo
                    .userService(customOAuth2UserService)
                )
                .successHandler(oAuth2AuthenticationSuccessHandler)
            );

        return http.build();
    }
}
</code></pre>
<pre><code class="language-properties"># OAuth2 client configuration
spring.security.oauth2.client.registration.google.client-id=your-client-id
spring.security.oauth2.client.registration.google.client-secret=your-client-secret
spring.security.oauth2.client.registration.google.scope=email,profile

spring.security.oauth2.client.registration.facebook.client-id=your-client-id
spring.security.oauth2.client.registration.facebook.client-secret=your-client-secret
spring.security.oauth2.client.registration.facebook.scope=email,public_profile
</code></pre>
<h2 id="advanced-topics-and-best-practices-1">Advanced Topics and Best Practices</h2>
<h3 id="153-how-do-you-use-spring-boot-with-graphql">153. How do you use Spring Boot with GraphQL?</h3>
<p><strong>Answer:</strong> Spring Boot can be integrated with GraphQL using the spring-graphql module:</p>
<ol>
    <li><strong>Add dependencies</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-graphql&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Define GraphQL schema</strong>:</li>
</ol>
<pre><code class="language-graphql"># src/main/resources/graphql/schema.graphqls
type Query {
    bookById(id: ID!): Book
    allBooks: [Book!]!
}

type Mutation {
    createBook(title: String!, author: String!): Book!
    deleteBook(id: ID!): Boolean
}

type Book {
    id: ID!
    title: String!
    author: String!
    pageCount: Int
    publishedDate: String
}
</code></pre>
<ol start="3">
    <li><strong>Create data models</strong>:</li>
</ol>
<pre><code class="language-java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class Book {
    private String id;
    private String title;
    private String author;
    private Integer pageCount;
    private String publishedDate;
}
</code></pre>
<ol start="4">
    <li><strong>Implement GraphQL controllers</strong>:</li>
</ol>
<pre><code class="language-java">@Controller
public class BookController {
    private final BookRepository bookRepository;

    @QueryMapping
    public Book bookById(@Argument String id) {
        return bookRepository.findById(id)
            .orElse(null);
    }

    @QueryMapping
    public List&lt;Book&gt; allBooks() {
        return bookRepository.findAll();
    }

    @MutationMapping
    public Book createBook(@Argument String title, @Argument String author) {
        Book book = new Book();
        book.setId(UUID.randomUUID().toString());
        book.setTitle(title);
        book.setAuthor(author);
        return bookRepository.save(book);
    }

    @SchemaMapping(typeName = &quot;Book&quot;, field = &quot;pageCount&quot;)
    public int getPageCount(Book book) {
        // Custom resolver for the pageCount field
        return book.getPageCount() != null ? book.getPageCount() : 0;
    }
}
</code></pre>
<ol start="5">
    <li><strong>Configure GraphQL endpoints</strong>:</li>
</ol>
<pre><code class="language-yaml">spring:
  graphql:
    graphiql:
      enabled: true
    path: /graphql
</code></pre>
<ol start="6">
    <li><strong>Add error handling</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class GraphQLExceptionHandler implements DataFetcherExceptionResolver {
    @Override
    public Mono&lt;List&lt;GraphQLError&gt;&gt; resolveException(Throwable exception,
            Map&lt;String, Object&gt; context) {
        if (exception instanceof BookNotFoundException) {
            GraphQLError error = GraphQLError.newError()
                .message(&quot;Book not found&quot;)
                .path((List&lt;Object&gt;) context.get(&quot;path&quot;))
                .errorType(ErrorType.NOT_FOUND)
                .build();

            return Mono.just(Collections.singletonList(error));
        }

        // Handle other exceptions
        return Mono.empty();
    }
}
</code></pre>
<ol start="7">
    <li><strong>Use data loaders for batching</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class BookBatchLoader {
    private final BookRepository bookRepository;

    @SchemaMapping(typeName = &quot;Author&quot;, field = &quot;books&quot;)
    public CompletableFuture&lt;List&lt;Book&gt;&gt; books(Author author, DataLoader&lt;String, List&lt;Book&gt;&gt; dataLoader) {
        return dataLoader.load(author.getId());
    }

    @BatchMapping
    public Mono&lt;Map&lt;Author, List&lt;Book&gt;&gt;&gt; books(List&lt;Author&gt; authors) {
        List&lt;String&gt; authorIds = authors.stream().map(Author::getId).collect(Collectors.toList());

        return Mono.fromSupplier(() -&gt; {
            Map&lt;String, List&lt;Book&gt;&gt; booksByAuthorId = bookRepository.findByAuthorIdIn(authorIds)
                .stream()
                .collect(Collectors.groupingBy(Book::getAuthorId));

            return authors.stream()
                .collect(Collectors.toMap(
                    Function.identity(),
                    author -&gt; booksByAuthorId.getOrDefault(author.getId(), Collections.emptyList())
                ));
        });
    }
}
</code></pre>
<h3 id="154-how-do-you-implement-reactive-programming-with-spring-boot">154. How do you implement Reactive Programming with Spring Boot?</h3>
<p><strong>Answer:</strong> Reactive programming in Spring Boot uses Spring WebFlux and Project Reactor:</p>
<ol>
    <li><strong>Add dependencies</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li><strong>Reactive REST controller</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    private final ProductRepository productRepository;

    @GetMapping
    public Flux&lt;Product&gt; getAllProducts() {
        return productRepository.findAll();
    }

    @GetMapping(&quot;/{id}&quot;)
    public Mono&lt;ResponseEntity&lt;Product&gt;&gt; getProductById(@PathVariable String id) {
        return productRepository.findById(id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;Product&gt; createProduct(@RequestBody Product product) {
        return productRepository.save(product);
    }

    @DeleteMapping(&quot;/{id}&quot;)
    public Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteProduct(@PathVariable String id) {
        return productRepository.findById(id)
                .flatMap(existingProduct -&gt;
                    productRepository.delete(existingProduct)
                        .then(Mono.just(ResponseEntity.noContent().&lt;Void&gt;build()))
                )
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}
</code></pre>
<ol start="3">
    <li><strong>Reactive repository with MongoDB</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Repository
public interface ProductRepository extends ReactiveMongoRepository&lt;Product, String&gt; {
    Flux&lt;Product&gt; findByNameContaining(String name);
    Mono&lt;Product&gt; findByCode(String code);
}
</code></pre>
<ol start="4">
    <li><strong>WebClient for reactive HTTP calls</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class RemoteProductService {
    private final WebClient webClient;

    public RemoteProductService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder
                .baseUrl(&quot;https://api.example.com&quot;)
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

    public Flux&lt;Product&gt; getProductsByCategory(String category) {
        return webClient.get()
                .uri(&quot;/products?category={category}&quot;, category)
                .retrieve()
                .bodyToFlux(Product.class);
    }

    public Mono&lt;Product&gt; getProductById(String id) {
        return webClient.get()
                .uri(&quot;/products/{id}&quot;, id)
                .retrieve()
                .onStatus(HttpStatus::is4xxClientError,
                        error -&gt; Mono.error(new ProductNotFoundException(id)))
                .bodyToMono(Product.class);
    }
}
</code></pre>
<ol start="5">
    <li><strong>Error handling in reactive streams</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/users&quot;)
public class UserController {
    @GetMapping(&quot;/{id}&quot;)
    public Mono&lt;ResponseEntity&lt;User&gt;&gt; getUserById(@PathVariable String id) {
        return userService.findById(id)
            .map(ResponseEntity::ok)
            .onErrorResume(UserNotFoundException.class, e -&gt;
                Mono.just(ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(new User(id, &quot;Not Found&quot;, null)))
            )
            .onErrorResume(Exception.class, e -&gt;
                Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .build())
            );
    }
}
</code></pre>
<ol start="6">
    <li><strong>Reactive security</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {
    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        return http
            .authorizeExchange()
                .pathMatchers(&quot;/api/public/**&quot;).permitAll()
                .pathMatchers(&quot;/api/admin/**&quot;).hasRole(&quot;ADMIN&quot;)
                .anyExchange().authenticated()
                .and()
            .httpBasic()
                .and()
            .formLogin()
                .and()
            .build();
    }
}
</code></pre>
<ol start="7">
    <li><strong>Reactive WebSockets</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class WebSocketConfig {
    @Bean
    public HandlerMapping webSocketHandlerMapping() {
        Map&lt;String, WebSocketHandler&gt; handlers = new HashMap&lt;&gt;();
        handlers.put(&quot;/ws/messages&quot;, new ReactiveWebSocketHandler());

        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
        mapping.setUrlMap(handlers);
        mapping.setOrder(-1);
        return mapping;
    }

    @Bean
    public WebSocketHandlerAdapter handlerAdapter() {
        return new WebSocketHandlerAdapter();
    }
}

public class ReactiveWebSocketHandler implements WebSocketHandler {
    private final Sinks.Many&lt;String&gt; sink = Sinks.many().multicast().onBackpressureBuffer();

    @Override
    public Mono&lt;Void&gt; handle(WebSocketSession session) {
        Flux&lt;WebSocketMessage&gt; outbound = sink.asFlux()
            .map(session::textMessage);

        Mono&lt;Void&gt; inbound = session.receive()
            .map(WebSocketMessage::getPayloadAsText)
            .doOnNext(sink::tryEmitNext)
            .then();

        return Mono.zip(outbound, inbound).then();
    }

    public void sendMessage(String message) {
        sink.tryEmitNext(message);
    }
}
</code></pre>
<h3 id="155-how-do-you-implement-server-side-caching-in-spring-boot">155. How do you implement server-side caching in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot provides several caching options:</p>
<ol>
    <li><strong>Enable caching</strong>:</li>
</ol>
<pre><code class="language-java">@EnableCaching
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Using cache annotations</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class ProductService {
    private final ProductRepository productRepository;

    @Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;, condition = &quot;#id &gt; 0&quot;)
    public Product getProduct(Long id) {
        // Method called only when result not in cache
        return productRepository.findById(id).orElse(null);
    }

    @CachePut(value = &quot;products&quot;, key = &quot;#product.id&quot;)
    public Product updateProduct(Product product) {
        // Method always executed, result put in cache
        return productRepository.save(product);
    }

    @CacheEvict(value = &quot;products&quot;, key = &quot;#id&quot;)
    public void deleteProduct(Long id) {
        // Method executed and specified cache entry removed
        productRepository.deleteById(id);
    }

    @CacheEvict(value = &quot;products&quot;, allEntries = true)
    public void clearProductCache() {
        // Method executed and all entries in cache removed
    }

    @Cacheable(value = &quot;product-search&quot;, keyGenerator = &quot;customKeyGenerator&quot;)
    public List&lt;Product&gt; searchProducts(String keyword, int page, int size) {
        // Using custom key generator
        return productRepository.searchByKeyword(keyword, page, size);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Custom key generator</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class CustomKeyGenerator implements KeyGenerator {
    @Override
    public Object generate(Object target, Method method, Object... params) {
        StringBuilder sb = new StringBuilder();
        sb.append(target.getClass().getSimpleName());
        sb.append(&quot;-&quot;);
        sb.append(method.getName());

        for (Object param : params) {
            sb.append(&quot;-&quot;);
            sb.append(param != null ? param.toString() : &quot;null&quot;);
        }

        return sb.toString();
    }
}
</code></pre>
<ol start="4">
    <li><strong>Configure Caffeine cache</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;
    &lt;artifactId&gt;caffeine&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();

        cacheManager.setCacheNames(Arrays.asList(&quot;products&quot;, &quot;categories&quot;, &quot;inventory&quot;));
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .maximumSize(1000));

        return cacheManager;
    }

    @Bean
    public Caffeine&lt;Object, Object&gt; caffeineConfig() {
        return Caffeine.newBuilder()
                .expireAfterWrite(10, TimeUnit.MINUTES)
                .initialCapacity(100)
                .maximumSize(500)
                .recordStats();
    }

    @Bean
    public CacheManager cacheManagerWithMultipleConfigs() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();

        // Define caches with different configurations
        Map&lt;String, Caffeine&lt;Object, Object&gt;&gt; caches = new HashMap&lt;&gt;();

        caches.put(&quot;products&quot;, Caffeine.newBuilder()
                .expireAfterWrite(10, TimeUnit.MINUTES)
                .maximumSize(1000));

        caches.put(&quot;categories&quot;, Caffeine.newBuilder()
                .expireAfterWrite(60, TimeUnit.MINUTES)
                .maximumSize(100));

        caches.put(&quot;rates&quot;, Caffeine.newBuilder()
                .expireAfterWrite(5, TimeUnit.MINUTES)
                .maximumSize(50));

        caches.forEach((name, caffeine) -&gt; {
            cacheManager.registerCustomCache(name, caffeine.build());
        });

        return cacheManager;
    }
}
</code></pre>
<ol start="5">
    <li><strong>Using Redis cache</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class RedisCacheConfig {
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        // Default cache configuration
        RedisCacheConfiguration defaultConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer()));

        // Configure different TTL for specific caches
        Map&lt;String, RedisCacheConfiguration&gt; cacheConfigs = new HashMap&lt;&gt;();
        cacheConfigs.put(&quot;products&quot;, defaultConfig.entryTtl(Duration.ofHours(1)));
        cacheConfigs.put(&quot;categories&quot;, defaultConfig.entryTtl(Duration.ofDays(1)));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(defaultConfig)
                .withInitialCacheConfigurations(cacheConfigs)
                .build();
    }
}
</code></pre>
<ol start="6">
    <li><strong>Cache synchronization for multi-node environments</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class ProductService {
    private final ProductRepository productRepository;
    private final CacheManager cacheManager;

    @Cacheable(&quot;products&quot;)
    public Product getProduct(Long id) {
        return productRepository.findById(id).orElse(null);
    }

    @CacheEvict(&quot;products&quot;)
    public void updateProductAndNotifyOtherNodes(Long id) {
        productRepository.updateProduct(id);

        // Publish cache invalidation event to other nodes
        cacheEventPublisher.publishCacheInvalidationEvent(&quot;products&quot;, id);
    }
}

@Component
public class RedisCacheListener {
    private final CacheManager cacheManager;

    @EventListener
    public void handleCacheInvalidationEvent(CacheInvalidationEvent event) {
        Cache cache = cacheManager.getCache(event.getCacheName());
        if (cache != null) {
            cache.evict(event.getKey());
        }
    }
}
</code></pre>
<ol start="7">
    <li><strong>Using cache metrics</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class CacheMetricsConfig {
    @Bean
    public CacheMetricsRegistrar cacheMetricsRegistrar(CacheManager cacheManager, MeterRegistry registry) {
        return new CacheMetricsRegistrar(cacheManager, registry);
    }
}

@Component
public class CacheMetricsRegistrar {
    public CacheMetricsRegistrar(CacheManager cacheManager, MeterRegistry registry) {
        cacheManager.getCacheNames().forEach(cacheName -&gt; {
            // Register metrics for each cache
            Cache cache = cacheManager.getCache(cacheName);
            if (cache.getNativeCache() instanceof com.github.benmanes.caffeine.cache.Cache) {
                com.github.benmanes.caffeine.cache.Cache&lt;Object, Object&gt; nativeCache =
                        (com.github.benmanes.caffeine.cache.Cache&lt;Object, Object&gt;) cache.getNativeCache();
                registerCaffeineCacheMetrics(registry, nativeCache, cacheName);
            }
        });
    }

    private void registerCaffeineCacheMetrics(
            MeterRegistry registry,
            com.github.benmanes.caffeine.cache.Cache&lt;Object, Object&gt; cache,
            String cacheName) {
        // Register cache size
        Gauge.builder(&quot;cache.size&quot;, cache, c -&gt; c.estimatedSize())
                .tag(&quot;name&quot;, cacheName)
                .register(registry);

        // Register hit/miss ratio if stats available
        if (cache instanceof com.github.benmanes.caffeine.cache.LoadingCache) {
            com.github.benmanes.caffeine.cache.stats.CacheStats stats = cache.stats();
            Gauge.builder(&quot;cache.hit.ratio&quot;, stats, s -&gt; s.hitRate())
                    .tag(&quot;name&quot;, cacheName)
                    .register(registry);
        }
    }
}
</code></pre>
<h3 id="156-how-do-you-implement-custom-validations-in-spring-boot">156. How do you implement custom validations in Spring Boot?</h3>
<p><strong>Answer:</strong> Custom validations in Spring Boot can be implemented in several ways:</p>
<ol>
    <li><strong>Create custom validation annotation</strong>:</li>
</ol>
<pre><code class="language-java">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueUsernameValidator.class)
public @interface UniqueUsername {
    String message() default &quot;Username already exists&quot;;
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}
</code></pre>
<ol start="2">
    <li><strong>Implement validator class</strong>:</li>
</ol>
<pre><code class="language-java">public class UniqueUsernameValidator implements ConstraintValidator&lt;UniqueUsername, String&gt; {
    private final UserRepository userRepository;

    public UniqueUsernameValidator(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true; // Let @NotNull handle this
        }
        return !userRepository.existsByUsername(value);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Use custom validation in entity/DTO</strong>:</li>
</ol>
<pre><code class="language-java">public class UserRegistrationDto {
    @NotBlank(message = &quot;Username is required&quot;)
    @Size(min = 4, max = 20, message = &quot;Username must be between 4 and 20 characters&quot;)
    @UniqueUsername
    private String username;

    @NotBlank(message = &quot;Email is required&quot;)
    @Email(message = &quot;Email must be valid&quot;)
    private String email;

    @NotBlank(message = &quot;Password is required&quot;)
    @Size(min = 8, message = &quot;Password must be at least 8 characters&quot;)
    private String password;

    // Getters and setters
}
</code></pre>
<ol start="4">
    <li><strong>Class-level validation</strong>:</li>
</ol>
<pre><code class="language-java">@PasswordMatches
public class RegistrationDto {
    @NotBlank(message = &quot;Password is required&quot;)
    private String password;

    @NotBlank(message = &quot;Confirm password is required&quot;)
    private String confirmPassword;

    // Getters and setters
}

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PasswordMatchesValidator.class)
public @interface PasswordMatches {
    String message() default &quot;Passwords don&#39;t match&quot;;
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}

public class PasswordMatchesValidator implements ConstraintValidator&lt;PasswordMatches, Object&gt; {
    @Override
    public boolean isValid(Object obj, ConstraintValidatorContext context) {
        RegistrationDto dto = (RegistrationDto) obj;
        return dto.getPassword().equals(dto.getConfirmPassword());
    }
}
</code></pre>
<ol start="5">
    <li><strong>Custom validation with programmatic API</strong>:</li>
</ol>
<pre><code class="language-java">@Service
@Validated
public class ProductService {
    private final Validator validator;

    public void validateProduct(Product product) {
        Set&lt;ConstraintViolation&lt;Product&gt;&gt; violations = validator.validate(product);

        if (!violations.isEmpty()) {
            Map&lt;String, String&gt; validationErrors = new HashMap&lt;&gt;();

            for (ConstraintViolation&lt;Product&gt; violation : violations) {
                String propertyPath = violation.getPropertyPath().toString();
                String message = violation.getMessage();
                validationErrors.put(propertyPath, message);
            }

            throw new ValidationException(&quot;Product validation failed&quot;, validationErrors);
        }
    }

    public void validateProductField(String fieldName, Object value) {
        Product product = new Product();
        BeanUtils.setProperty(product, fieldName, value);

        Set&lt;ConstraintViolation&lt;Product&gt;&gt; violations = validator.validateProperty(
                product, fieldName);

        if (!violations.isEmpty()) {
            throw new ValidationException(violations.iterator().next().getMessage());
        }
    }
}
</code></pre>
<ol start="6">
    <li><strong>Custom validator factory</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class ValidationConfig {
    @Bean
    public LocalValidatorFactoryBean validator() {
        LocalValidatorFactoryBean bean = new LocalValidatorFactoryBean();
        bean.setValidationMessageSource(messageSource());
        return bean;
    }

    @Bean
    public MessageSource messageSource() {
        ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();
        messageSource.setBasename(&quot;classpath:messages&quot;);
        messageSource.setDefaultEncoding(&quot;UTF-8&quot;);
        return messageSource;
    }
}
</code></pre>
<ol start="7">
    <li><strong>Handling validation errors in controllers</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice
public class ValidationExceptionHandler {
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ValidationErrorResponse handleValidationExceptions(MethodArgumentNotValidException ex) {
        ValidationErrorResponse errors = new ValidationErrorResponse();

        ex.getBindingResult().getFieldErrors().forEach(error -&gt;
            errors.addError(error.getField(), error.getDefaultMessage()));

        return errors;
    }

    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ValidationErrorResponse handleConstraintViolation(ConstraintViolationException ex) {
        ValidationErrorResponse errors = new ValidationErrorResponse();

        ex.getConstraintViolations().forEach(violation -&gt; {
            String fieldName = violation.getPropertyPath().toString();
            String errorMessage = violation.getMessage();
            errors.addError(fieldName, errorMessage);
        });

        return errors;
    }
}

public class ValidationErrorResponse {
    private Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();

    public void addError(String field, String message) {
        errors.put(field, message);
    }

    public Map&lt;String, String&gt; getErrors() {
        return errors;
    }
}
</code></pre>
<ol start="8">
    <li><strong>Using validation groups for different scenarios</strong>:</li>
</ol>
<pre><code class="language-java">public interface ValidationGroups {
    interface Create {}
    interface Update {}
}

public class ProductDto {
    @Null(groups = ValidationGroups.Create.class)
    @NotNull(groups = ValidationGroups.Update.class)
    private Long id;

    @NotBlank(groups = {ValidationGroups.Create.class, ValidationGroups.Update.class})
    @Size(min = 2, max = 100)
    private String name;

    @Positive
    private BigDecimal price;

    // Getters and setters
}

@RestController
@RequestMapping(&quot;/api/products&quot;)
public class ProductController {
    @PostMapping
    public ResponseEntity&lt;Product&gt; createProduct(
            @Validated(ValidationGroups.Create.class) @RequestBody ProductDto dto) {
        // Create product
    }

    @PutMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;Product&gt; updateProduct(
            @PathVariable Long id,
            @Validated(ValidationGroups.Update.class) @RequestBody ProductDto dto) {
        // Update product
    }
}
</code></pre>
<h3 id="157-what-patterns-can-be-used-to-handle-eventual-consistency-in-spring-boot-microservices">157. What patterns can be used to handle eventual consistency in Spring Boot microservices?</h3>
<p><strong>Answer:</strong> Eventual consistency in microservices can be handled with several patterns:</p>
<ol>
    <li><strong>Event Sourcing pattern</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
public class OrderEvent {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String orderId;

    @Column(nullable = false)
    private String eventType;

    @Column(columnDefinition = &quot;TEXT&quot;)
    private String payload;

    @Column(nullable = false)
    private LocalDateTime timestamp;

    // Getters and setters
}

@Service
public class OrderEventService {
    private final OrderEventRepository eventRepository;
    private final ApplicationEventPublisher eventPublisher;

    public void createOrder(OrderCreateCommand command) {
        // Save event
        OrderEvent event = new OrderEvent();
        event.setOrderId(UUID.randomUUID().toString());
        event.setEventType(&quot;ORDER_CREATED&quot;);
        event.setPayload(JsonUtils.toJson(command));
        event.setTimestamp(LocalDateTime.now());

        OrderEvent savedEvent = eventRepository.save(event);

        // Publish domain event to notify other services
        eventPublisher.publishEvent(new OrderCreatedEvent(
                this, savedEvent.getOrderId(), command));
    }

    public List&lt;OrderEvent&gt; getOrderEvents(String orderId) {
        return eventRepository.findByOrderIdOrderByTimestamp(orderId);
    }
}
</code></pre>
<ol start="2">
    <li><strong>CQRS (Command Query Responsibility Segregation)</strong>:</li>
</ol>
<pre><code class="language-java">// Command side
@Service
public class OrderCommandService {
    private final OrderEventService eventService;

    public String createOrder(CreateOrderCommand command) {
        return eventService.createOrder(command);
    }

    public void updateOrderStatus(UpdateOrderStatusCommand command) {
        eventService.updateOrderStatus(command);
    }
}

// Query side
@Service
public class OrderQueryService {
    private final OrderRepository orderRepository;

    public OrderDto getOrderById(String id) {
        return orderRepository.findById(id)
                .map(this::mapToDto)
                .orElseThrow(() -&gt; new OrderNotFoundException(id));
    }

    public List&lt;OrderDto&gt; getOrdersByCustomer(String customerId) {
        return orderRepository.findByCustomerId(customerId)
                .stream()
                .map(this::mapToDto)
                .collect(Collectors.toList());
    }

    private OrderDto mapToDto(Order order) {
        // Mapping logic
    }
}

// Event handler for updating the read model
@Component
public class OrderEventHandler {
    private final OrderRepository orderRepository;

    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        Order order = new Order();
        order.setId(event.getOrderId());
        order.setCustomerId(event.getCommand().getCustomerId());
        order.setStatus(&quot;CREATED&quot;);
        order.setTotalAmount(event.getCommand().getTotalAmount());

        orderRepository.save(order);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Saga pattern for distributed transactions</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderSaga {
    private final OrderRepository orderRepository;
    private final PaymentService paymentService;
    private final InventoryService inventoryService;
    private final NotificationService notificationService;

    @Transactional
    public OrderResult processOrder(Order order) {
        // Start saga
        order.setStatus(&quot;PROCESSING&quot;);
        Order savedOrder = orderRepository.save(order);

        try {
            // Reserve inventory
            InventoryReservation reservation = inventoryService.reserveInventory(
                    mapToReservationRequest(order));

            // Process payment
            PaymentResult payment = paymentService.processPayment(
                    mapToPaymentRequest(order, reservation.getReservationId()));

            // Confirm order
            savedOrder.setStatus(&quot;CONFIRMED&quot;);
            savedOrder.setPaymentId(payment.getPaymentId());
            savedOrder.setReservationId(reservation.getReservationId());
            orderRepository.save(savedOrder);

            // Send notification
            notificationService.sendOrderConfirmation(savedOrder);

            return new OrderResult(savedOrder.getId(), &quot;ORDER_CONFIRMED&quot;);
        } catch (InventoryException e) {
            // Compensating transaction
            savedOrder.setStatus(&quot;FAILED&quot;);
            savedOrder.setFailureReason(&quot;INVENTORY_ERROR: &quot; + e.getMessage());
            orderRepository.save(savedOrder);

            return new OrderResult(savedOrder.getId(), &quot;ORDER_FAILED&quot;);
        } catch (PaymentException e) {
            // Compensating transaction - release inventory
            inventoryService.releaseInventory(savedOrder.getReservationId());

            savedOrder.setStatus(&quot;FAILED&quot;);
            savedOrder.setFailureReason(&quot;PAYMENT_ERROR: &quot; + e.getMessage());
            orderRepository.save(savedOrder);

            return new OrderResult(savedOrder.getId(), &quot;ORDER_FAILED&quot;);
        }
    }
}
</code></pre>
<ol start="4">
    <li><strong>Choreography-based saga with Spring Cloud Stream</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class OrderStreamConfig {
    @Bean
    public Function&lt;OrderCreatedEvent, Message&lt;InventoryReservationCommand&gt;&gt; processOrder() {
        return event -&gt; {
            InventoryReservationCommand command = new InventoryReservationCommand(
                    event.getOrderId(),
                    event.getItems()
            );

            return MessageBuilder.withPayload(command)
                    .setHeader(&quot;saga-id&quot;, event.getOrderId())
                    .build();
        };
    }
}

@Configuration
public class InventoryStreamConfig {
    @Bean
    public Function&lt;InventoryReservationCommand, Message&lt;?&gt;&gt; processInventory() {
        return command -&gt; {
            try {
                InventoryReservation reservation = inventoryService.reserveInventory(command);

                PaymentCommand paymentCommand = new PaymentCommand(
                        command.getOrderId(),
                        reservation.getTotalAmount()
                );

                return MessageBuilder.withPayload(paymentCommand)
                        .setHeader(&quot;saga-id&quot;, command.getOrderId())
                        .build();
            } catch (Exception e) {
                InventoryReservationFailedEvent failedEvent = new InventoryReservationFailedEvent(
                        command.getOrderId(),
                        e.getMessage()
                );

                return MessageBuilder.withPayload(failedEvent)
                        .setHeader(&quot;saga-id&quot;, command.getOrderId())
                        .build();
            }
        };
    }
}
</code></pre>
<ol start="5">
    <li><strong>Outbox pattern for reliable messaging</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Table(name = &quot;outbox_events&quot;)
public class OutboxEvent {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String aggregateType;

    @Column(nullable = false)
    private String aggregateId;

    @Column(nullable = false)
    private String eventType;

    @Column(columnDefinition = &quot;TEXT&quot;, nullable = false)
    private String payload;

    @Column(nullable = false)
    private LocalDateTime timestamp;

    @Column(nullable = false)
    private boolean processed;

    // Getters and setters
}

@Service
@Transactional
public class OrderService {
    private final OrderRepository orderRepository;
    private final OutboxEventRepository outboxRepository;

    public Order createOrder(OrderRequest request) {
        // Save order
        Order order = mapRequestToEntity(request);
        Order savedOrder = orderRepository.save(order);

        // Save event to outbox
        OutboxEvent outboxEvent = new OutboxEvent();
        outboxEvent.setAggregateType(&quot;Order&quot;);
        outboxEvent.setAggregateId(savedOrder.getId().toString());
        outboxEvent.setEventType(&quot;OrderCreated&quot;);
        outboxEvent.setPayload(JsonUtils.toJson(savedOrder));
        outboxEvent.setTimestamp(LocalDateTime.now());
        outboxEvent.setProcessed(false);

        outboxRepository.save(outboxEvent);

        return savedOrder;
    }
}

@Component
@EnableScheduling
public class OutboxEventPublisher {
    private final OutboxEventRepository outboxRepository;
    private final KafkaTemplate&lt;String, String&gt; kafkaTemplate;

    @Scheduled(fixedRate = 5000)
    public void publishEvents() {
        List&lt;OutboxEvent&gt; unpublishedEvents = outboxRepository.findByProcessedFalse();

        for (OutboxEvent event : unpublishedEvents) {
            try {
                String topic = event.getAggregateType().toLowerCase() + &quot;.&quot; +
                               event.getEventType().toLowerCase();

                kafkaTemplate.send(topic, event.getAggregateId(), event.getPayload());

                event.setProcessed(true);
                outboxRepository.save(event);
            } catch (Exception e) {
                // Log error, will retry on next scheduled execution
            }
        }
    }
}
</code></pre>
<ol start="6">
    <li><strong>Using a distributed event log (Kafka)</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class KafkaProducerConfig {
    @Value(&quot;${spring.kafka.bootstrap-servers}&quot;)
    private String bootstrapServers;

    @Bean
    public ProducerFactory&lt;String, String&gt; producerFactory() {
        Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.ACKS_CONFIG, &quot;all&quot;);
        return new DefaultKafkaProducerFactory&lt;&gt;(configProps);
    }

    @Bean
    public KafkaTemplate&lt;String, String&gt; kafkaTemplate() {
        return new KafkaTemplate&lt;&gt;(producerFactory());
    }
}

@Service
public class OrderEventPublisher {
    private final KafkaTemplate&lt;String, String&gt; kafkaTemplate;
    private final ObjectMapper objectMapper;

    public void publishOrderCreated(Order order) {
        try {
            String payload = objectMapper.writeValueAsString(order);
            kafkaTemplate.send(&quot;orders.created&quot;, order.getId().toString(), payload);
        } catch (JsonProcessingException e) {
            throw new EventPublishingException(&quot;Failed to serialize order&quot;, e);
        }
    }
}

@Configuration
public class KafkaConsumerConfig {
    @Value(&quot;${spring.kafka.bootstrap-servers}&quot;)
    private String bootstrapServers;

    @Bean
    public ConsumerFactory&lt;String, String&gt; consumerFactory() {
        Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;();
        configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;inventory-service&quot;);
        configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        return new DefaultKafkaConsumerFactory&lt;&gt;(configProps);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory =
                new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
        factory.setConsumerFactory(consumerFactory());
        return factory;
    }
}

@Component
public class OrderEventListener {
    private final ObjectMapper objectMapper;
    private final InventoryService inventoryService;

    @KafkaListener(topics = &quot;orders.created&quot;, groupId = &quot;inventory-service&quot;)
    public void handleOrderCreated(String message) throws JsonProcessingException {
        Order order = objectMapper.readValue(message, Order.class);

        // Update inventory based on order
        inventoryService.processOrder(order);
    }
}
</code></pre>
<ol start="7">
    <li><strong>Polling-based consistency verification</strong>:</li>
</ol>
<pre><code class="language-java">@Service
@EnableScheduling
public class OrderConsistencyService {
    private final OrderRepository orderRepository;
    private final PaymentServiceClient paymentServiceClient;
    private final InventoryServiceClient inventoryServiceClient;

    @Scheduled(fixedRate = 60000)  // Every minute
    public void verifyOrderConsistency() {
        LocalDateTime cutoffTime = LocalDateTime.now().minusMinutes(5);
        List&lt;Order&gt; processingOrders = orderRepository.findByStatusAndCreatedDateBefore(
                &quot;PROCESSING&quot;, cutoffTime);

        for (Order order : processingOrders) {
            // Check payment service
            PaymentStatus paymentStatus = paymentServiceClient.getPaymentStatus(
                    order.getPaymentId());

            // Check inventory service
            InventoryStatus inventoryStatus = inventoryServiceClient.getReservationStatus(
                    order.getReservationId());

            // Reconcile status
            if (paymentStatus.isCompleted() &amp;&amp; inventoryStatus.isReserved()) {
                order.setStatus(&quot;CONFIRMED&quot;);
            } else if (paymentStatus.isFailed() || inventoryStatus.isFailed()) {
                order.setStatus(&quot;FAILED&quot;);
                // Initiate compensating transactions if needed
            }

            orderRepository.save(order);
        }
    }
}
</code></pre>
<h3 id="158-how-do-you-implement-message-driven-microservices-with-spring-boot">158. How do you implement message-driven microservices with Spring Boot?</h3>
<p><strong>Answer:</strong> Message-driven microservices can be implemented using various technologies:</p>
<ol>
    <li><strong>Spring Cloud Stream with Kafka</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-stream-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class StreamConfig {
    @Bean
    public Consumer&lt;OrderCreatedEvent&gt; processOrder() {
        return event -&gt; {
            log.info(&quot;Processing order: {}&quot;, event.getOrderId());
            // Order processing logic
        };
    }

    @Bean
    public Function&lt;OrderCreatedEvent, PaymentEvent&gt; processPayment() {
        return order -&gt; {
            log.info(&quot;Processing payment for order: {}&quot;, order.getOrderId());

            // Payment logic
            PaymentEvent paymentEvent = new PaymentEvent();
            paymentEvent.setOrderId(order.getOrderId());
            paymentEvent.setStatus(&quot;COMPLETED&quot;);

            return paymentEvent;
        };
    }

    @Bean
    public Supplier&lt;StockUpdateEvent&gt; stockUpdates() {
        return () -&gt; {
            // Generate periodic stock updates
            return new StockUpdateEvent(
                UUID.randomUUID().toString(),
                &quot;PRODUCT-123&quot;,
                100,
                LocalDateTime.now()
            );
        };
    }
}
</code></pre>
<pre><code class="language-yaml">spring:
  cloud:
    function:
      definition: processOrder;processPayment;stockUpdates
    stream:
      kafka:
        binder:
          brokers: localhost:9092
      bindings:
        processOrder-in-0:
          destination: orders
          group: order-processing-service

        processPayment-in-0:
          destination: orders
          group: payment-service
        processPayment-out-0:
          destination: payments

        stockUpdates-out-0:
          destination: stock-updates
</code></pre>
<ol start="2">
    <li><strong>Spring Cloud Stream with RabbitMQ</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-yaml">spring:
  cloud:
    stream:
      rabbit:
        binder:
          nodes: localhost:5672
      bindings:
        processOrder-in-0:
          destination: orders
          group: order-processing-service
          consumer:
            max-attempts: 3
        processOrder-out-0:
          destination: processed-orders
</code></pre>
<ol start="3">
    <li><strong>Direct Spring AMQP with RabbitMQ</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean
    public Queue ordersQueue() {
        return new Queue(&quot;orders&quot;, true);
    }

    @Bean
    public DirectExchange orderExchange() {
        return new DirectExchange(&quot;order-exchange&quot;);
    }

    @Bean
    public Binding binding(Queue ordersQueue, DirectExchange orderExchange) {
        return BindingBuilder.bind(ordersQueue)
                .to(orderExchange)
                .with(&quot;order.created&quot;);
    }

    @Bean
    public MessageConverter jsonMessageConverter() {
        return new Jackson2JsonMessageConverter();
    }

    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate template = new RabbitTemplate(connectionFactory);
        template.setMessageConverter(jsonMessageConverter());
        return template;
    }
}

@Component
public class OrderListener {
    @RabbitListener(queues = &quot;orders&quot;)
    public void processOrder(Order order) {
        // Process the order
    }
}

@Service
public class OrderService {
    private final RabbitTemplate rabbitTemplate;

    public void createOrder(Order order) {
        // Persist the order

        // Publish event
        rabbitTemplate.convertAndSend(&quot;order-exchange&quot;, &quot;order.created&quot;, order);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Spring Kafka</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class KafkaConfig {
    @Bean
    public ProducerFactory&lt;String, Object&gt; producerFactory() {
        Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return new DefaultKafkaProducerFactory&lt;&gt;(configProps);
    }

    @Bean
    public KafkaTemplate&lt;String, Object&gt; kafkaTemplate() {
        return new KafkaTemplate&lt;&gt;(producerFactory());
    }

    @Bean
    public ConsumerFactory&lt;String, String&gt; consumerFactory() {
        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;);
        props.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;my-service&quot;);
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        return new DefaultKafkaConsumerFactory&lt;&gt;(props);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory =
                new ConcurrentKafkaListenerContainerFactory&lt;&gt;();
        factory.setConsumerFactory(consumerFactory());
        return factory;
    }
}

@Service
public class KafkaProducerService {
    private final KafkaTemplate&lt;String, Object&gt; kafkaTemplate;

    public void send(String topic, Object message) {
        kafkaTemplate.send(topic, message);
    }

    public void sendOrderCreated(Order order) {
        kafkaTemplate.send(&quot;orders&quot;, order.getId().toString(), order);
    }
}

@Service
public class KafkaConsumerService {
    @KafkaListener(topics = &quot;orders&quot;, groupId = &quot;order-service&quot;)
    public void consumeOrderEvent(String message) throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        Order order = mapper.readValue(message, Order.class);

        // Process order
    }

    @KafkaListener(topics = &quot;payments&quot;, groupId = &quot;order-service&quot;)
    public void consumePaymentEvent(String message) {
        // Process payment event
    }
}
</code></pre>
<ol start="5">
    <li><strong>Spring Integration</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-integration&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
@EnableIntegration
public class IntegrationConfig {
    @Bean
    public MessageChannel inputChannel() {
        return new DirectChannel();
    }

    @Bean
    public MessageChannel outputChannel() {
        return new DirectChannel();
    }

    @Bean
    public IntegrationFlow processOrderFlow() {
        return IntegrationFlows.from(&quot;inputChannel&quot;)
                .filter(payload -&gt; payload instanceof Order)
                .transform(Order.class, this::enrichOrder)
                .&lt;Order, String&gt;route(
                    order -&gt; order.getType(),
                    mapping -&gt; mapping
                        .subFlowMapping(&quot;STANDARD&quot;, sf -&gt; sf.channel(&quot;standardOrdersChannel&quot;))
                        .subFlowMapping(&quot;EXPRESS&quot;, sf -&gt; sf.channel(&quot;expressOrdersChannel&quot;))
                        .defaultSubFlowMapping(sf -&gt; sf.channel(&quot;defaultOrdersChannel&quot;))
                )
                .get();
    }

    private Order enrichOrder(Order order) {
        // Add additional information to the order
        order.setProcessedTimestamp(LocalDateTime.now());
        return order;
    }

    @ServiceActivator(inputChannel = &quot;standardOrdersChannel&quot;)
    public void processStandardOrder(Order order) {
        // Process standard order
    }

    @ServiceActivator(inputChannel = &quot;expressOrdersChannel&quot;)
    public void processExpressOrder(Order order) {
        // Process express order
    }
}

@Component
public class OrderGateway {
    @Autowired
    private MessageChannel inputChannel;

    public void processOrder(Order order) {
        inputChannel.send(MessageBuilder.withPayload(order).build());
    }
}
</code></pre>
<ol start="6">
    <li><strong>Event-driven with Spring Cloud Stream and error handling</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class StreamErrorHandlingConfig {
    @Bean
    public Consumer&lt;Message&lt;OrderEvent&gt;&gt; processOrderWithErrorHandling() {
        return message -&gt; {
            try {
                OrderEvent event = message.getPayload();
                // Process order
            } catch (Exception e) {
                // Get retry count from headers
                Integer retryCount = message.getHeaders()
                        .get(&quot;retryCount&quot;, Integer.class);

                if (retryCount == null) {
                    retryCount = 1;
                } else {
                    retryCount++;
                }

                if (retryCount &lt;= 3) {
                    // Retry by sending to DLQ
                    Message&lt;OrderEvent&gt; retryMessage = MessageBuilder
                            .fromMessage(message)
                            .setHeader(&quot;retryCount&quot;, retryCount)
                            .build();

                    // Send to retry topic
                    kafkaTemplate.send(&quot;order-retry&quot;, retryMessage);
                } else {
                    // Send to dead letter queue
                    kafkaTemplate.send(&quot;order-dlq&quot;, message);
                }
            }
        };
    }
}
</code></pre>
<pre><code class="language-yaml">spring:
  cloud:
    stream:
      kafka:
        bindings:
          processOrderWithErrorHandling-in-0:
            consumer:
              enableDlq: true
              dlqName: order-dlq
              dlqPartitions: 1
</code></pre>
<ol start="7">
    <li><strong>Implementing a message processing pipeline</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class MessagePipeline {
    @Bean
    public IntegrationFlow orderProcessingPipeline() {
        return IntegrationFlows.from(Http.inboundGateway(&quot;/orders&quot;)
                .requestMapping(m -&gt; m.methods(HttpMethod.POST))
                .requestPayloadType(OrderRequest.class))
            // Convert to domain model
            .transform(orderRequestTransformer())
            // Validate order
            .handle(orderValidator())
            // Save to database
            .handle(orderRepository(), &quot;save&quot;)
            // Publish event to message broker
            .handle(kafkaOrderPublisher())
            // Convert result to response
            .transform(orderResponseTransformer())
            .get();
    }

    @Bean
    public GenericTransformer&lt;OrderRequest, Order&gt; orderRequestTransformer() {
        return orderRequest -&gt; {
            // Transform OrderRequest to Order entity
            Order order = new Order();
            order.setId(UUID.randomUUID().toString());
            order.setCustomerId(orderRequest.getCustomerId());
            // Map other fields
            return order;
        };
    }

    @Bean
    public GenericHandler&lt;Order&gt; orderValidator() {
        return (order, headers) -&gt; {
            // Validation logic
            if (order.getCustomerId() == null) {
                throw new ValidationException(&quot;Customer ID is required&quot;);
            }
            return order;
        };
    }

    @Bean
    public MessageHandler kafkaOrderPublisher() {
        return message -&gt; {
            Order order = (Order) message.getPayload();
            kafkaTemplate.send(&quot;orders&quot;, order.getId(), order);
        };
    }

    @Bean
    public GenericTransformer&lt;Order, OrderResponse&gt; orderResponseTransformer() {
        return order -&gt; {
            OrderResponse response = new OrderResponse();
            response.setOrderId(order.getId());
            response.setStatus(&quot;CREATED&quot;);
            return response;
        };
    }
}
</code></pre>
<h3 id="159-how-do-you-implement-custom-spring-boot-starters">159. How do you implement custom Spring Boot starters?</h3>
<p><strong>Answer:</strong> Custom Spring Boot starters automate configuration for reusable components:</p>
<ol>
    <li><strong>Project structure</strong>:</li>
</ol>
<pre><code>custom-spring-boot-starter/
├── pom.xml
└── src/
    └── main/
        ├── java/
        │   └── com/example/starter/
        │       ├── CustomAutoConfiguration.java
        │       ├── CustomService.java
        │       └── CustomProperties.java
        └── resources/
            └── META-INF/
                └── spring/
                    └── org.springframework.boot.autoconfigure.AutoConfiguration.imports
</code></pre>
<ol start="2">
    <li><strong>Starter POM configuration</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;custom-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;

    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
        &lt;spring-boot.version&gt;3.1.0&lt;/spring-boot.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;${spring-boot.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
            &lt;version&gt;${spring-boot.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;version&gt;${spring-boot.version}&lt;/version&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ol start="3">
    <li><strong>Configuration properties class</strong>:</li>
</ol>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;example.custom&quot;)
public class CustomProperties {
    /**
     * Whether to enable the custom feature.
     */
    private boolean enabled = true;

    /**
     * Message prefix to use.
     */
    private String prefix = &quot;Hello&quot;;

    /**
     * Message suffix to use.
     */
    private String suffix = &quot;!&quot;;

    // Getters and setters
}
</code></pre>
<ol start="4">
    <li><strong>Service class</strong>:</li>
</ol>
<pre><code class="language-java">public class CustomService {
    private final String prefix;
    private final String suffix;

    public CustomService(String prefix, String suffix) {
        this.prefix = prefix;
        this.suffix = suffix;
    }

    public String formatMessage(String name) {
        return prefix + &quot; &quot; + name + suffix;
    }
}
</code></pre>
<ol start="5">
    <li><strong>Auto-configuration class</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@ConditionalOnClass(CustomService.class)
@EnableConfigurationProperties(CustomProperties.class)
@ConditionalOnProperty(prefix = &quot;example.custom&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
public class CustomAutoConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public CustomService customService(CustomProperties properties) {
        return new CustomService(
            properties.getPrefix(),
            properties.getSuffix()
        );
    }
}
</code></pre>
<ol start="6">
    <li><strong>Auto-configuration registration</strong> (Spring Boot 3.x):</li>
</ol>
<pre><code># META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
com.example.starter.CustomAutoConfiguration
</code></pre>
<ol start="7">
    <li><strong>Add detailed documentation</strong>:</li>
</ol>
<pre><code class="language-java">/**
 * Configuration properties for the Custom starter.
 *
 * @author Jane Developer
 * @since 1.0.0
 */
@ConfigurationProperties(prefix = &quot;example.custom&quot;)
public class CustomProperties {
    /**
     * Whether to enable the custom feature. Default is true.
     */
    private boolean enabled = true;

    /**
     * Message prefix to use. Default is &quot;Hello&quot;.
     */
    private String prefix = &quot;Hello&quot;;

    /**
     * Message suffix to use. Default is &quot;!&quot;.
     */
    private String suffix = &quot;!&quot;;

    // Getters and setters
}
</code></pre>
<ol start="8">
    <li><strong>Usage in other projects</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;custom-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Service
public class GreetingService {
    private final CustomService customService;

    public GreetingService(CustomService customService) {
        this.customService = customService;
    }

    public String greet(String name) {
        return customService.formatMessage(name);
    }
}
</code></pre>
<pre><code class="language-properties"># application.properties
example.custom.enabled=true
example.custom.prefix=Hi
example.custom.suffix=!!!
</code></pre>
<h2 id="advanced-topics-and-real-world-applications">Advanced Topics and Real-World Applications</h2>
<h3 id="160-how-does-spring-boot-handle-database-failover-and-high-availability">160. How does Spring Boot handle database failover and high availability?</h3>
<p><strong>Answer:</strong> (Continuing our discussion on database HA in Spring Boot)</p>
<pre><code class="language-java">@Service
public class DatabaseService {
    private final RetryTemplate retryTemplate;
    private final JdbcTemplate jdbcTemplate;

    @Retryable(
        value = {DataAccessException.class, TransientDataAccessException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000, multiplier = 2)
    )
    public List&lt;User&gt; findAllUsers() {
        return jdbcTemplate.query(&quot;SELECT * FROM users&quot;, userRowMapper);
    }

    public List&lt;User&gt; findAllUsersWithRetryTemplate() {
        return retryTemplate.execute(retryContext -&gt; {
            return jdbcTemplate.query(&quot;SELECT * FROM users&quot;, userRowMapper);
        });
    }

    @Recover
    public List&lt;User&gt; recoverFindAllUsers(DataAccessException e) {
        // Fallback implementation
        log.error(&quot;Failed to access database after retries&quot;, e);
        return Collections.emptyList();
    }
}
</code></pre>
<ol start="9">
    <li><strong>Database cluster configuration with Spring Cloud and Vault</strong>:</li>
</ol>
<pre><code class="language-yaml">spring:
  application:
    name: my-service
  cloud:
    vault:
      host: vault.example.com
      port: 8200
      scheme: https
      token: ${VAULT_TOKEN}
      kv:
        enabled: true
        backend: secret
        default-context: application
  datasource:
    url: ${spring.datasource.url}
    username: ${spring.datasource.username}
    password: ${spring.datasource.password}
</code></pre>
<ol start="10">
    <li><strong>Database health indicator</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class DatabaseClusterHealthIndicator implements HealthIndicator {
    private final JdbcTemplate primaryJdbcTemplate;
    private final JdbcTemplate replicaJdbcTemplate;

    @Override
    public Health health() {
        Map&lt;String, Object&gt; details = new HashMap&lt;&gt;();

        try {
            // Check primary database
            long primaryStartTime = System.currentTimeMillis();
            primaryJdbcTemplate.execute(&quot;SELECT 1&quot;);
            long primaryResponseTime = System.currentTimeMillis() - primaryStartTime;
            details.put(&quot;primary.status&quot;, &quot;UP&quot;);
            details.put(&quot;primary.responseTime&quot;, primaryResponseTime + &quot;ms&quot;);

            // Check replica database
            long replicaStartTime = System.currentTimeMillis();
            replicaJdbcTemplate.execute(&quot;SELECT 1&quot;);
            long replicaResponseTime = System.currentTimeMillis() - replicaStartTime;
            details.put(&quot;replica.status&quot;, &quot;UP&quot;);
            details.put(&quot;replica.responseTime&quot;, replicaResponseTime + &quot;ms&quot;);

            return Health.up().withDetails(details).build();
        } catch (Exception e) {
            details.put(&quot;error&quot;, e.getMessage());
            return Health.down().withDetails(details).build();
        }
    }
}
</code></pre>
<h3 id="161-how-do-you-implement-proper-error-handling-for-rest-apis-in-spring-boot">161. How do you implement proper error handling for REST APIs in Spring Boot?</h3>
<p><strong>Answer:</strong> Proper error handling for REST APIs involves several best practices:</p>
<ol>
    <li><strong>Global exception handler</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ErrorResponse handleResourceNotFoundException(ResourceNotFoundException ex) {
        return new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            Instant.now()
        );
    }

    @ExceptionHandler(InvalidRequestException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ErrorResponse handleInvalidRequestException(InvalidRequestException ex) {
        return new ErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            ex.getMessage(),
            Instant.now()
        );
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ValidationErrorResponse handleValidationExceptions(MethodArgumentNotValidException ex) {
        ValidationErrorResponse errors = new ValidationErrorResponse();
        ex.getBindingResult().getFieldErrors().forEach(error -&gt;
            errors.addError(error.getField(), error.getDefaultMessage()));

        errors.setTimestamp(Instant.now());
        errors.setStatus(HttpStatus.BAD_REQUEST.value());
        errors.setMessage(&quot;Validation failed&quot;);

        return errors;
    }

    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ErrorResponse handleAllUncaughtException(Exception ex) {
        log.error(&quot;Unexpected error occurred&quot;, ex);

        return new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            &quot;An unexpected error occurred&quot;,
            Instant.now()
        );
    }
}
</code></pre>
<ol start="2">
    <li><strong>Standard error response model</strong>:</li>
</ol>
<pre><code class="language-java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorResponse {
    private int status;
    private String message;
    private Instant timestamp;
    private String traceId;

    public ErrorResponse(int status, String message, Instant timestamp) {
        this.status = status;
        this.message = message;
        this.timestamp = timestamp;
        this.traceId = MDC.get(&quot;traceId&quot;);
    }
}

@Data
public class ValidationErrorResponse extends ErrorResponse {
    private Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();

    public void addError(String field, String message) {
        errors.put(field, message);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Custom exceptions</strong>:</li>
</ol>
<pre><code class="language-java">public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {
        super(String.format(&quot;%s not found with %s: &#39;%s&#39;&quot;, resourceName, fieldName, fieldValue));
    }
}

public class InvalidRequestException extends RuntimeException {
    public InvalidRequestException(String message) {
        super(message);
    }
}

public class BusinessLogicException extends RuntimeException {
    private final String errorCode;
    private final Object[] args;

    public BusinessLogicException(String errorCode, String message, Object... args) {
        super(message);
        this.errorCode = errorCode;
        this.args = args;
    }

    // Getters
}
</code></pre>
<ol start="4">
    <li><strong>Problem Details (RFC 7807) implementation</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice
public class ProblemDetailsExceptionHandler {
    private final MessageSource messageSource;

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity&lt;ProblemDetail&gt; handleResourceNotFoundException(
            ResourceNotFoundException ex, WebRequest request) {
        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(
            HttpStatus.NOT_FOUND, ex.getMessage());

        problemDetail.setTitle(&quot;Resource Not Found&quot;);
        problemDetail.setType(URI.create(&quot;https://api.example.com/errors/not-found&quot;));
        problemDetail.setProperty(&quot;timestamp&quot;, Instant.now());
        problemDetail.setProperty(&quot;traceId&quot;, MDC.get(&quot;traceId&quot;));

        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .contentType(MediaType.APPLICATION_PROBLEM_JSON)
            .body(problemDetail);
    }

    @ExceptionHandler(BusinessLogicException.class)
    public ResponseEntity&lt;ProblemDetail&gt; handleBusinessLogicException(
            BusinessLogicException ex, WebRequest request, Locale locale) {
        // Localize message
        String localizedMessage = messageSource.getMessage(
            ex.getErrorCode(), ex.getArgs(), ex.getMessage(), locale);

        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST, localizedMessage);

        problemDetail.setTitle(&quot;Business Rule Violation&quot;);
        problemDetail.setType(URI.create(&quot;https://api.example.com/errors/business-rule&quot;));
        problemDetail.setProperty(&quot;errorCode&quot;, ex.getErrorCode());

        return ResponseEntity.badRequest()
            .contentType(MediaType.APPLICATION_PROBLEM_JSON)
            .body(problemDetail);
    }

    // Other exception handlers
}
</code></pre>
<ol start="5">
    <li><strong>Request/response logging for troubleshooting</strong>:</li>
</ol>
<pre><code class="language-java">@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class RequestLoggingFilter extends OncePerRequestFilter {
    private final Logger log = LoggerFactory.getLogger(RequestLoggingFilter.class);

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain filterChain) throws ServletException, IOException {
        // Generate trace ID for request tracking
        String traceId = UUID.randomUUID().toString();
        MDC.put(&quot;traceId&quot;, traceId);

        // Capture request details
        String method = request.getMethod();
        String uri = request.getRequestURI();
        String queryString = request.getQueryString();

        log.debug(&quot;Request received: {} {} (TraceId: {})&quot;,
            method, queryString != null ? uri + &quot;?&quot; + queryString : uri, traceId);

        // Add trace ID to response headers
        response.setHeader(&quot;X-Trace-Id&quot;, traceId);

        try {
            // Continue with the request
            filterChain.doFilter(request, response);
        } finally {
            // Log response status
            log.debug(&quot;Response status: {} (TraceId: {})&quot;,
                response.getStatus(), traceId);

            MDC.remove(&quot;traceId&quot;);
        }
    }
}
</code></pre>
<ol start="6">
    <li><strong>Error handling in async operations</strong>:</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/async&quot;)
public class AsyncController {
    private final AsyncService asyncService;

    @GetMapping(&quot;/process&quot;)
    public CompletableFuture&lt;ResponseEntity&lt;Object&gt;&gt; processAsync() {
        return asyncService.processAsync()
            .thenApply(result -&gt; ResponseEntity.ok(result))
            .exceptionally(ex -&gt; {
                Throwable cause = ex.getCause();

                if (cause instanceof ResourceNotFoundException) {
                    ErrorResponse error = new ErrorResponse(
                        HttpStatus.NOT_FOUND.value(),
                        cause.getMessage(),
                        Instant.now()
                    );
                    return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
                }

                ErrorResponse error = new ErrorResponse(
                    HttpStatus.INTERNAL_SERVER_ERROR.value(),
                    &quot;An unexpected error occurred&quot;,
                    Instant.now()
                );
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
            });
    }
}
</code></pre>
<ol start="7">
    <li><strong>Content negotiation for error responses</strong>:</li>
</ol>
<pre><code class="language-java">@RestControllerAdvice
public class ContentNegotiationExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity&lt;Object&gt; handleResourceNotFound(
            ResourceNotFoundException ex, WebRequest request) {

        ErrorResponse errorResponse = new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            Instant.now()
        );

        return handleExceptionInternal(ex, errorResponse,
            new HttpHeaders(), HttpStatus.NOT_FOUND, request);
    }

    @Override
    protected ResponseEntity&lt;Object&gt; handleExceptionInternal(
            Exception ex, Object body, HttpHeaders headers,
            HttpStatus status, WebRequest request) {

        // Check if client accepts XML
        if (request.getHeader(&quot;Accept&quot;) != null &amp;&amp;
                request.getHeader(&quot;Accept&quot;).contains(&quot;application/xml&quot;)) {
            headers.setContentType(MediaType.APPLICATION_XML);
        } else {
            headers.setContentType(MediaType.APPLICATION_JSON);
        }

        return super.handleExceptionInternal(ex, body, headers, status, request);
    }
}
</code></pre>
<h3 id="162-how-do-you-implement-role-based-access-control-rbac-in-spring-boot">162. How do you implement role-based access control (RBAC) in Spring Boot?</h3>
<p><strong>Answer:</strong> Role-based access control in Spring Boot can be implemented in several ways:</p>
<ol>
    <li><strong>Basic security configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -&gt; auth
                .requestMatchers(&quot;/api/public/**&quot;).permitAll()
                .requestMatchers(&quot;/api/admin/**&quot;).hasRole(&quot;ADMIN&quot;)
                .requestMatchers(&quot;/api/manager/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;MANAGER&quot;)
                .requestMatchers(&quot;/api/profile/**&quot;).hasRole(&quot;USER&quot;)
                .anyRequest().authenticated()
            )
            .formLogin(form -&gt; form
                .loginPage(&quot;/login&quot;)
                .permitAll()
            )
            .logout(logout -&gt; logout
                .logoutUrl(&quot;/logout&quot;)
                .permitAll()
            );

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
</code></pre>
<ol start="2">
    <li><strong>Method-level security</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableMethodSecurity
public class MethodSecurityConfig {
    // Additional configuration if needed
}

@Service
public class UserService {
    private final UserRepository userRepository;

    @PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)
    public List&lt;User&gt; getAllUsers() {
        return userRepository.findAll();
    }

    @PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;) or @userSecurity.isUserOwner(authentication, #id)&quot;)
    public User getUser(Long id) {
        return userRepository.findById(id)
            .orElseThrow(() -&gt; new UserNotFoundException(id));
    }

    @PreAuthorize(&quot;hasAnyRole(&#39;ADMIN&#39;, &#39;MANAGER&#39;) or #user.id == authentication.principal.id&quot;)
    public User updateUser(User user) {
        return userRepository.save(user);
    }

    @PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)
    @PostAuthorize(&quot;returnObject.status != &#39;DELETED&#39;&quot;)
    public User restoreUser(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -&gt; new UserNotFoundException(id));
        user.setStatus(&quot;ACTIVE&quot;);
        return userRepository.save(user);
    }
}
</code></pre>
<ol start="3">
    <li><strong>Custom security expression</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class UserSecurity {
    private final UserRepository userRepository;

    public boolean isUserOwner(Authentication authentication, Long userId) {
        String username = authentication.getName();
        User user = userRepository.findById(userId).orElse(null);

        return user != null &amp;&amp; user.getUsername().equals(username);
    }

    public boolean hasPermission(Authentication authentication, String permission) {
        // Custom permission logic
        if (authentication == null) {
            return false;
        }

        return authentication.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .anyMatch(authority -&gt; authority.equals(&quot;PERMISSION_&quot; + permission));
    }
}

@RestController
@RequestMapping(&quot;/api/documents&quot;)
public class DocumentController {
    @GetMapping(&quot;/{id}&quot;)
    @PreAuthorize(&quot;@userSecurity.hasPermission(authentication, &#39;DOCUMENT_READ&#39;)&quot;)
    public Document getDocument(@PathVariable Long id) {
        // Method implementation
    }
}
</code></pre>
<ol start="4">
    <li><strong>Custom filter for role checking</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class RoleBasedAccessFilter extends OncePerRequestFilter {
    private final UserRepository userRepository;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain filterChain) throws ServletException, IOException {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || !auth.isAuthenticated()) {
            filterChain.doFilter(request, response);
            return;
        }

        // Check user role for specific paths
        String requestPath = request.getRequestURI();
        if (requestPath.startsWith(&quot;/api/special/&quot;) &amp;&amp; !hasAdminRole(auth)) {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            response.getWriter().write(&quot;Access denied: special API requires admin role&quot;);
            return;
        }

        filterChain.doFilter(request, response);
    }

    private boolean hasAdminRole(Authentication auth) {
        return auth.getAuthorities().stream()
            .anyMatch(authority -&gt; authority.getAuthority().equals(&quot;ROLE_ADMIN&quot;));
    }
}
</code></pre>
<ol start="5">
    <li><strong>Database-driven role and permission model</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Table(name = &quot;users&quot;)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;
    private String password;
    private boolean enabled;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = &quot;user_roles&quot;,
        joinColumns = @JoinColumn(name = &quot;user_id&quot;),
        inverseJoinColumns = @JoinColumn(name = &quot;role_id&quot;)
    )
    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();
}

@Entity
@Table(name = &quot;roles&quot;)
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = &quot;role_permissions&quot;,
        joinColumns = @JoinColumn(name = &quot;role_id&quot;),
        inverseJoinColumns = @JoinColumn(name = &quot;permission_id&quot;)
    )
    private Set&lt;Permission&gt; permissions = new HashSet&lt;&gt;();
}

@Entity
@Table(name = &quot;permissions&quot;)
public class Permission {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
}
</code></pre>
<ol start="6">
    <li><strong>Custom UserDetailsService</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class CustomUserDetailsService implements UserDetailsService {
    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;User not found: &quot; + username));

        Set&lt;GrantedAuthority&gt; authorities = new HashSet&lt;&gt;();

        // Add role-based authorities
        for (Role role : user.getRoles()) {
            authorities.add(new SimpleGrantedAuthority(&quot;ROLE_&quot; + role.getName()));

            // Add permission-based authorities
            for (Permission permission : role.getPermissions()) {
                authorities.add(new SimpleGrantedAuthority(&quot;PERMISSION_&quot; + permission.getName()));
            }
        }

        return new org.springframework.security.core.userdetails.User(
            user.getUsername(),
            user.getPassword(),
            user.isEnabled(),
            true, true, true,
            authorities
        );
    }
}
</code></pre>
<ol start="7">
    <li><strong>OAuth2 resource server with role-based access</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class OAuth2ResourceServerConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -&gt; auth
                .requestMatchers(&quot;/api/public/**&quot;).permitAll()
                .requestMatchers(&quot;/api/admin/**&quot;).hasAuthority(&quot;SCOPE_admin&quot;)
                .requestMatchers(&quot;/api/user/**&quot;).hasAuthority(&quot;SCOPE_user&quot;)
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .jwtAuthenticationConverter(jwtAuthenticationConverter())
                )
            );

        return http.build();
    }

    private Converter&lt;Jwt, AbstractAuthenticationToken&gt; jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthoritiesClaimName(&quot;roles&quot;);
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix(&quot;ROLE_&quot;);

        JwtAuthenticationConverter jwtConverter = new JwtAuthenticationConverter();
        jwtConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);
        return jwtConverter;
    }
}
</code></pre>
<h3 id="163-how-do-you-implement-distributed-tracing-in-a-spring-boot-microservices-architecture">163. How do you implement distributed tracing in a Spring Boot microservices architecture?</h3>
<p><strong>Answer:</strong> Distributed tracing can be implemented with Spring Cloud Sleuth and OpenTelemetry:</p>
<ol>
    <li><strong>Spring Cloud Sleuth with Zipkin</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-sleuth-zipkin&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># application.properties
spring.application.name=order-service

# Zipkin configuration
spring.zipkin.base-url=http://zipkin-server:9411
spring.zipkin.enabled=true
spring.zipkin.service.name=${spring.application.name}

# Sampling configuration
spring.sleuth.sampler.probability=1.0
</code></pre>
<ol start="2">
    <li><strong>Spring Boot 3.x with Micrometer Tracing</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
    &lt;artifactId&gt;micrometer-tracing-bridge-brave&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.zipkin.reporter2&lt;/groupId&gt;
    &lt;artifactId&gt;zipkin-reporter-brave&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-properties"># application.properties
management.tracing.sampling.probability=1.0
management.zipkin.tracing.endpoint=http://zipkin-server:9411/api/v2/spans
</code></pre>
<ol start="3">
    <li><strong>OpenTelemetry integration</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;
    &lt;artifactId&gt;opentelemetry-api&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;
    &lt;artifactId&gt;opentelemetry-sdk&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;
    &lt;artifactId&gt;opentelemetry-exporter-jaeger&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class OpenTelemetryConfig {
    @Bean
    public OpenTelemetry openTelemetry() {
        JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.builder()
            .setEndpoint(&quot;http://jaeger:14250&quot;)
            .build();

        BatchSpanProcessor spanProcessor = BatchSpanProcessor.builder(jaegerExporter)
            .setScheduleDelay(100, TimeUnit.MILLISECONDS)
            .build();

        SdkTracerProvider sdkTracerProvider = SdkTracerProvider.builder()
            .addSpanProcessor(spanProcessor)
            .setSampler(Sampler.alwaysOn())
            .build();

        return OpenTelemetrySdk.builder()
            .setTracerProvider(sdkTracerProvider)
            .buildAndRegisterGlobal();
    }

    @Bean
    public Tracer tracer(OpenTelemetry openTelemetry) {
        return openTelemetry.getTracer(&quot;com.example.application&quot;);
    }
}
</code></pre>
<ol start="4">
    <li><strong>Intercepting HTTP calls with RestTemplate</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class RestTemplateConfig {
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
</code></pre>
<p>The tracing context is automatically propagated with RestTemplate when using Spring Cloud Sleuth.</p>
<ol start="5">
    <li><strong>Using WebClient with tracing</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class WebClientConfig {
    @Bean
    public WebClient webClient() {
        return WebClient.builder().build();
    }
}
</code></pre>
<p>Spring Cloud Sleuth automatically enhances WebClient with tracing capabilities.</p>
<ol start="6">
    <li><strong>Manual span creation for custom operations</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class OrderProcessingService {
    private final Tracer tracer;

    public void processOrder(Order order) {
        Span span = tracer.nextSpan().name(&quot;process-order&quot;).start();
        try (Tracer.SpanInScope ws = tracer.withSpan(span)) {
            // Add metadata to the span
            span.tag(&quot;orderId&quot;, order.getId().toString());
            span.tag(&quot;customerId&quot;, order.getCustomerId().toString());

            // Business logic...
            validateOrder(order);

            // Create nested span for a specific operation
            Span nestedSpan = tracer.nextSpan().name(&quot;payment-processing&quot;).start();
            try (Tracer.SpanInScope nestedWs = tracer.withSpan(nestedSpan)) {
                processPayment(order);
            } finally {
                nestedSpan.finish();
            }

            updateInventory(order);

        } finally {
            span.finish();
        }
    }
}
</code></pre>
<ol start="7">
    <li><strong>Tracing asynchronous operations</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class AsyncConfig {
    @Bean
    public Executor asyncExecutor() {
        return new SimpleAsyncTaskExecutor(&quot;async-&quot;);
    }
}

@Service
public class AsyncService {
    private final Executor executor;
    private final Tracer tracer;

    @Async
    public CompletableFuture&lt;String&gt; processAsync(String input) {
        // Tracing context is automatically propagated for @Async methods
        return CompletableFuture.supplyAsync(() -&gt; {
            // Perform async operation
            return input.toUpperCase();
        }, executor);
    }

    public CompletableFuture&lt;String&gt; processWithManualContext(String input) {
        // Capture the current span
        Span currentSpan = tracer.currentSpan();

        return CompletableFuture.supplyAsync(() -&gt; {
            // Manually continue the trace in the new thread
            try (Tracer.SpanInScope ws = tracer.withSpan(currentSpan)) {
                return input.toUpperCase();
            }
        }, executor);
    }
}
</code></pre>
<ol start="8">
    <li><strong>Integrating with logging</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;
    &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;
    &lt;version&gt;7.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-xml">&lt;!-- logback-spring.xml --&gt;
&lt;configuration&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&gt;
            &lt;includeMdc&gt;true&lt;/includeMdc&gt;
            &lt;customFields&gt;{&quot;service_name&quot;:&quot;${spring.application.name}&quot;}&lt;/customFields&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;root level=&quot;INFO&quot;&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="164-how-do-you-implement-a-custom-health-indicator-in-spring-boot-actuator">164. How do you implement a custom health indicator in Spring Boot Actuator?</h3>
<p><strong>Answer:</strong> Custom health indicators provide application-specific health status information:</p>
<ol>
    <li><strong>Implement HealthIndicator interface</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    private final DataSource dataSource;

    @Override
    public Health health() {
        try (Connection conn = dataSource.getConnection()) {
            try (Statement stmt = conn.createStatement()) {
                stmt.execute(&quot;SELECT 1&quot;);

                Map&lt;String, Object&gt; details = new HashMap&lt;&gt;();
                details.put(&quot;database&quot;, conn.getMetaData().getDatabaseProductName());
                details.put(&quot;version&quot;, conn.getMetaData().getDatabaseProductVersion());
                details.put(&quot;connection_count&quot;, getConnectionCount());

                return Health.up()
                    .withDetails(details)
                    .build();
            }
        } catch (SQLException e) {
            return Health.down()
                .withException(e)
                .withDetail(&quot;error&quot;, &quot;Database connection failed: &quot; + e.getMessage())
                .build();
        }
    }

    private int getConnectionCount() {
        // Implementation to get active connection count
        return 0;
    }
}
</code></pre>
<ol start="2">
    <li><strong>Create a CompositeHealthContributor</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ExternalSystemHealthIndicator implements CompositeHealthContributor {
    private final Map&lt;String, HealthContributor&gt; contributors;

    public ExternalSystemHealthIndicator(
            PaymentGatewayHealthIndicator paymentGateway,
            CacheHealthIndicator cache,
            MessagingHealthIndicator messaging) {

        contributors = Map.of(
            &quot;payment-gateway&quot;, paymentGateway,
            &quot;cache&quot;, cache,
            &quot;messaging&quot;, messaging
        );
    }

    @Override
    public HealthContributor getContributor(String name) {
        return contributors.get(name);
    }

    @Override
    public Iterator&lt;NamedContributor&lt;HealthContributor&gt;&gt; iterator() {
        return contributors.entrySet().stream()
            .map(entry -&gt; NamedContributor.of(entry.getKey(), entry.getValue()))
            .iterator();
    }
}
</code></pre>
<ol start="3">
    <li><strong>Configure health groups</strong>:</li>
</ol>
<pre><code class="language-properties"># Configure health endpoints
management.endpoint.health.show-details=always
management.endpoint.health.show-components=always

# Define health groups
management.endpoint.health.group.readiness.include=db,redis,kafka
management.endpoint.health.group.readiness.show-details=always
management.endpoint.health.group.readiness.show-components=always

management.endpoint.health.group.liveness.include=ping,diskSpace
management.endpoint.health.group.liveness.show-details=always
</code></pre>
<ol start="4">
    <li><strong>Reactive health indicator</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ReactiveExternalServiceHealthIndicator implements ReactiveHealthIndicator {
    private final WebClient webClient;

    @Override
    public Mono&lt;Health&gt; health() {
        return webClient.get()
                .uri(&quot;https://api.example.com/health&quot;)
                .retrieve()
                .bodyToMono(Map.class)
                .map(response -&gt; {
                    boolean isUp = &quot;UP&quot;.equals(response.get(&quot;status&quot;));

                    if (isUp) {
                        return Health.up()
                            .withDetails(response)
                            .build();
                    } else {
                        return Health.down()
                            .withDetails(response)
                            .build();
                    }
                })
                .onErrorResume(e -&gt; Mono.just(Health.down()
                    .withException(e)
                    .build()));
    }
}
</code></pre>
<ol start="5">
    <li><strong>Advanced health indicator with status history</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ServiceHealthIndicator implements HealthIndicator {
    private final CircularFifoQueue&lt;HealthStatus&gt; statusHistory;
    private final ServiceClient serviceClient;

    public ServiceHealthIndicator(ServiceClient serviceClient) {
        this.serviceClient = serviceClient;
        this.statusHistory = new CircularFifoQueue&lt;&gt;(10);  // Keep last 10 statuses
    }

    @Override
    public Health health() {
        try {
            ResponseEntity&lt;String&gt; response = serviceClient.checkHealth();

            HealthStatus status = new HealthStatus(
                response.getStatusCode().value(),
                response.getBody(),
                System.currentTimeMillis()
            );
            statusHistory.add(status);

            if (response.getStatusCode().is2xxSuccessful()) {
                Health.Builder builder = Health.up()
                    .withDetail(&quot;status_code&quot;, response.getStatusCode().value())
                    .withDetail(&quot;history&quot;, statusHistory.toString());

                return builder.build();
            } else {
                return Health.down()
                    .withDetail(&quot;status_code&quot;, response.getStatusCode().value())
                    .withDetail(&quot;body&quot;, response.getBody())
                    .withDetail(&quot;history&quot;, statusHistory.toString())
                    .build();
            }
        } catch (Exception e) {
            HealthStatus status = new HealthStatus(
                -1,
                e.getMessage(),
                System.currentTimeMillis()
            );
            statusHistory.add(status);

            return Health.down()
                .withException(e)
                .withDetail(&quot;history&quot;, statusHistory.toString())
                .build();
        }
    }

    @Data
    @AllArgsConstructor
    private static class HealthStatus {
        private int statusCode;
        private String response;
        private long timestamp;
    }
}
</code></pre>
<ol start="6">
    <li><strong>Configure health indicator order</strong>:</li>
</ol>
<pre><code class="language-java">@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class CriticalHealthIndicator implements HealthIndicator {
    @Override
    public Health health() {
        // This will be evaluated first
        return Health.up().build();
    }
}
</code></pre>
<ol start="7">
    <li><strong>Custom health indicator with application events</strong>:</li>
</ol>
<pre><code class="language-java">@Component
public class ApplicationStateHealthIndicator implements HealthIndicator, ApplicationListener&lt;ApplicationEvent&gt; {
    private final Map&lt;String, Object&gt; applicationState = new HashMap&lt;&gt;();

    @Override
    public Health health() {
        return Health.up()
            .withDetails(applicationState)
            .build();
    }

    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        if (event instanceof ContextRefreshedEvent) {
            applicationState.put(&quot;contextRefreshed&quot;, true);
            applicationState.put(&quot;startupTime&quot;, System.currentTimeMillis());
        } else if (event instanceof OrderServiceStartedEvent) {
            applicationState.put(&quot;orderServiceStarted&quot;, true);
        }
    }

    public void recordMetric(String name, Object value) {
        applicationState.put(name, value);
    }
}
</code></pre>
<h3 id="165-how-do-you-handle-cross-cutting-concerns-in-spring-boot-applications">165. How do you handle cross-cutting concerns in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Cross-cutting concerns in Spring Boot are typically handled using Aspect-Oriented Programming (AOP):</p>
<ol>
    <li><strong>Logging aspect</strong>:</li>
</ol>
<pre><code class="language-java">@Aspect
@Component
public class LoggingAspect {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    @Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)
    public void serviceMethods() {}

    @Around(&quot;serviceMethods()&quot;)
    public Object logMethodExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getName();
        Object[] args = joinPoint.getArgs();

        logger.debug(&quot;Entering {}::{} with arguments {}&quot;, className, methodName, args);

        long start = System.currentTimeMillis();

        try {
            Object result = joinPoint.proceed();

            long executionTime = System.currentTimeMillis() - start;
            logger.debug(&quot;{}::{} completed in {} ms with result: {}&quot;,
                className, methodName, executionTime, result);

            return result;
        } catch (Exception e) {
            logger.error(&quot;{}::{} threw exception: {}&quot;, className, methodName, e.getMessage(), e);
            throw e;
        }
    }
}
</code></pre>
<ol start="2">
    <li><strong>Performance monitoring aspect</strong>:</li>
</ol>
<pre><code class="language-java">@Aspect
@Component
public class PerformanceAspect {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());
    private final MeterRegistry meterRegistry;

    @Around(&quot;@annotation(com.example.annotation.Monitored)&quot;)
    public Object monitorPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();

        Timer.Sample sample = Timer.start(meterRegistry);

        try {
            return joinPoint.proceed();
        } finally {
            long executionTime = sample.stop(meterRegistry.timer(
                &quot;method.execution.time&quot;,
                &quot;class&quot;, className,
                &quot;method&quot;, methodName
            ));

            if (executionTime &gt; 1000) {  // More than 1 second
                logger.warn(&quot;Slow method execution: {}::{} took {} ms&quot;,
                    className, methodName, executionTime / 1000000.0);
            }
        }
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Monitored {
}
</code></pre>
<ol start="3">
    <li><strong>Caching aspect</strong>:</li>
</ol>
<pre><code class="language-java">@Aspect
@Component
public class CacheAspect {
    private final Cache&lt;String, Object&gt; cache;

    public CacheAspect() {
        this.cache = Caffeine.newBuilder()
            .expireAfterWrite(5, TimeUnit.MINUTES)
            .maximumSize(1000)
            .build();
    }

    @Around(&quot;@annotation(com.example.annotation.Cacheable)&quot;)
    public Object cacheMethod(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        String methodName = signature.getName();
        String className = joinPoint.getTarget().getClass().getName();

        // Create cache key from class name, method name and arguments
        String cacheKey = className + &quot;.&quot; + methodName + &quot;.&quot; +
            Arrays.deepToString(joinPoint.getArgs());

        // Check cache
        Object cachedValue = cache.getIfPresent(cacheKey);
        if (cachedValue != null) {
            return cachedValue;
        }

        // Execute method and cache result
        Object result = joinPoint.proceed();
        cache.put(cacheKey, result);

        return result;
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Cacheable {
}
</code></pre>
<ol start="4">
    <li><strong>Transaction aspect using Spring&#39;s AOP</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableTransactionManagement
public class TransactionConfig {
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}

@Service
public class OrderService {
    private final OrderRepository orderRepository;
    private final PaymentService paymentService;

    @Transactional(rollbackFor = PaymentFailedException.class)
    public Order createOrder(Order order) {
        // Save order
        Order savedOrder = orderRepository.save(order);

        // Process payment
        paymentService.processPayment(order);

        return savedOrder;
    }
}
</code></pre>
<ol start="5">
    <li><strong>Security aspect</strong>:</li>
</ol>
<pre><code class="language-java">@Aspect
@Component
public class SecurityAspect {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    @Before(&quot;execution(* com.example.controller.*.*(..))&quot;)
    public void checkAuthorization(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getName();

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null &amp;&amp; auth.isAuthenticated()) {
            logger.debug(&quot;User {} accessing {}::{}&quot;,
                auth.getName(), className, methodName);
        } else {
            logger.warn(&quot;Unauthenticated access attempt to {}::{}&quot;,
                className, methodName);
        }
    }
}
</code></pre>
<ol start="6">
    <li><strong>Custom annotation for auditing</strong>:</li>
</ol>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Audited {
    String action();
}

@Aspect
@Component
public class AuditAspect {
    private final AuditRepository auditRepository;

    @Around(&quot;@annotation(audited)&quot;)
    public Object audit(ProceedingJoinPoint joinPoint, Audited audited) throws Throwable {
        String action = audited.action();
        String methodName = joinPoint.getSignature().getName();

        // Get current user
        String username = SecurityContextHolder.getContext().getAuthentication().getName();

        AuditLog auditLog = new AuditLog();
        auditLog.setAction(action);
        auditLog.setMethod(methodName);
        auditLog.setUsername(username);
        auditLog.setTimestamp(LocalDateTime.now());
        auditLog.setParameters(Arrays.toString(joinPoint.getArgs()));

        try {
            Object result = joinPoint.proceed();

            // Record successful outcome
            auditLog.setSuccess(true);
            auditRepository.save(auditLog);

            return result;
        } catch (Exception e) {
            // Record failure
            auditLog.setSuccess(false);
            auditLog.setErrorMessage(e.getMessage());
            auditRepository.save(auditLog);

            throw e;
        }
    }
}

@Service
public class UserAdminService {
    @Audited(action = &quot;USER_CREATE&quot;)
    public User createUser(User user) {
        // Implementation
    }

    @Audited(action = &quot;USER_DELETE&quot;)
    public void deleteUser(Long id) {
        // Implementation
    }
}
</code></pre>
<ol start="7">
    <li><strong>Exception handling aspect</strong>:</li>
</ol>
<pre><code class="language-java">@Aspect
@Component
public class ExceptionHandlingAspect {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    @Around(&quot;execution(* com.example.service.*.*(..))&quot;)
    public Object handleExceptions(ProceedingJoinPoint joinPoint) throws Throwable {
        try {
            return joinPoint.proceed();
        } catch (BusinessException e) {
            // Log and rethrow business exceptions
            logger.warn(&quot;Business exception in {}: {}&quot;,
                joinPoint.getSignature(), e.getMessage());
            throw e;
        } catch (Exception e) {
            // Log unexpected exceptions
            logger.error(&quot;Unexpected exception in {}: {}&quot;,
                joinPoint.getSignature(), e.getMessage(), e);

            // Wrap in application-specific exception
            throw new ApplicationException(&quot;Service error occurred&quot;, e);
        }
    }
}
</code></pre>
<ol start="8">
    <li><strong>Retry aspect</strong>:</li>
</ol>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Retry {
    int maxAttempts() default 3;
    long delay() default 1000; // ms
    Class&lt;? extends Throwable&gt;[] retryFor() default {Exception.class};
}

@Aspect
@Component
public class RetryAspect {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    @Around(&quot;@annotation(retry)&quot;)
    public Object retry(ProceedingJoinPoint joinPoint, Retry retry) throws Throwable {
        int maxAttempts = retry.maxAttempts();
        long delay = retry.delay();
        Class&lt;? extends Throwable&gt;[] retryForClasses = retry.retryFor();

        int attempts = 0;
        Throwable lastException = null;

        while (attempts &lt; maxAttempts) {
            try {
                return joinPoint.proceed();
            } catch (Throwable e) {
                lastException = e;

                if (shouldRetry(e, retryForClasses)) {
                    attempts++;
                    if (attempts &lt; maxAttempts) {
                        logger.warn(&quot;Retry attempt {} for {}: {}&quot;,
                            attempts, joinPoint.getSignature(), e.getMessage());
                        Thread.sleep(delay);
                    }
                } else {
                    throw e;
                }
            }
        }

        throw lastException;
    }

    private boolean shouldRetry(Throwable e, Class&lt;? extends Throwable&gt;[] retryForClasses) {
        for (Class&lt;? extends Throwable&gt; retryClass : retryForClasses) {
            if (retryClass.isInstance(e)) {
                return true;
            }
        }
        return false;
    }
}

@Service
public class ExternalServiceClient {
    @Retry(maxAttempts = 3, delay = 2000, retryFor = {SocketTimeoutException.class})
    public String fetchData(String endpoint) {
        // Implementation that might throw network exceptions
    }
}
</code></pre>


</body>
</html>