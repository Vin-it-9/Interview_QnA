<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>

    <link href="../style.css" rel="stylesheet" type="text/css" >
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11/build/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

</head>

<body>

<h1 id="spring-boot-interview-questions-and-answers">Spring Boot Interview Questions and Answers</h1>
<h3 id="1-what-is-spring-boot-">1. What is Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot is an extension of the Spring framework that simplifies the development of Java applications. It provides auto-configuration, standalone capabilities, and a production-ready environment, eliminating boilerplate code and configuration. Spring Boot uses an &quot;opinionated defaults, configure as needed&quot; approach to minimize setup and get applications running quickly.</p>
<h3 id="2-what-are-the-key-features-of-spring-boot-">2. What are the key features of Spring Boot?</h3>
<p><strong>Answer:</strong> Key Spring Boot features include auto-configuration that automatically configures beans based on classpath, embedded servers (Tomcat, Jetty, or Undertow) eliminating deployment complexity, starter dependencies that simplify build configuration, externalized configuration through properties files, actuator for monitoring and management, and Spring Boot CLI for rapid prototyping. These features dramatically reduce development time.</p>
<h3 id="3-what-is-spring-boot-starter-name-some-important-starters-">3. What is Spring Boot Starter? Name some important starters.</h3>
<p><strong>Answer:</strong> Spring Boot Starters are dependency descriptors that bundle related dependencies to simplify project setup. Important starters include spring-boot-starter-web (for web applications), spring-boot-starter-data-jpa (for database access), spring-boot-starter-security (for security), spring-boot-starter-test (for testing), and spring-boot-starter-actuator (for monitoring). Starters ensure compatible versions and reduce dependency management overhead.</p>
<h3 id="4-what-is-auto-configuration-in-spring-boot-">4. What is Auto-configuration in Spring Boot?</h3>
<p><strong>Answer:</strong> Auto-configuration automatically configures Spring application based on the dependencies present on the classpath. It creates and configures beans that would otherwise require manual configuration. For example, if H2 database is on the classpath, Spring Boot auto-configures an in-memory database. It works through conditional configuration using @Conditional annotations and follows a &quot;convention over configuration&quot; approach.</p>
<h3 id="5-how-can-you-disable-a-specific-auto-configuration-class-">5. How can you disable a specific auto-configuration class?</h3>
<p><strong>Answer:</strong> To disable a specific auto-configuration class, use the exclude attribute of @SpringBootApplication or @EnableAutoConfiguration annotations. For example: @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) disables database auto-configuration. You can also use the excludeName attribute with the fully qualified class name as a string, or configure spring.autoconfigure.exclude property in application.properties.</p>
<h3 id="6-what-is-spring-boot-devtools-">6. What is Spring Boot DevTools?</h3>
<p><strong>Answer:</strong> Spring Boot DevTools is a set of tools enhancing developer productivity. It offers automatic application restart when files change, live reload of browser resources, remote debugging support, and property defaults optimized for development. DevTools is automatically disabled when running a packaged application, ensuring production environments aren&#39;t affected by development-time features.</p>
<h3 id="7-what-is-the-difference-between-springbootapplication-and-enableautoconfiguration-">7. What is the difference between @SpringBootApplication and @EnableAutoConfiguration?</h3>
<p><strong>Answer:</strong> @SpringBootApplication is a convenience annotation that combines @EnableAutoConfiguration, @ComponentScan, and @Configuration. While @EnableAutoConfiguration enables Spring Boot&#39;s auto-configuration mechanism, @SpringBootApplication also enables component scanning and configuration class processing. In most cases, @SpringBootApplication is preferred as it provides all necessary annotations in one place.</p>
<h3 id="8-how-can-you-externalize-configuration-in-spring-boot-">8. How can you externalize configuration in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot externalizes configuration using application.properties or application.yml files. Configuration can be placed in the classpath, current directory, config subdirectory, or provided as command-line arguments. Spring Boot also supports environment variables and cloud config servers. The @ConfigurationProperties annotation allows binding configuration properties to Java objects for type-safe configuration access.</p>
<h3 id="9-what-is-the-difference-between-properties-and-yaml-for-configuration-">9. What is the difference between properties and YAML for configuration?</h3>
<p><strong>Answer:</strong> Properties files use simple key-value format (key=value) while YAML uses hierarchical format with indentation. YAML is more readable for complex configurations with nested properties, supports lists, and allows multi-document files. Properties files are simpler but can become verbose with hierarchical data. Both provide the same functionality, with Spring Boot supporting either format according to developer preference.</p>
<h3 id="10-what-are-profiles-in-spring-boot-">10. What are profiles in Spring Boot?</h3>
<p><strong>Answer:</strong> Profiles in Spring Boot provide a way to segregate parts of application configuration and make them available only in specific environments. You can define profile-specific properties files (application-{profile}.properties) and activate profiles using spring.profiles.active property. Profiles are commonly used to maintain different configurations for development, testing, and production environments.</p>
<h3 id="11-how-do-you-enable-debugging-in-spring-boot-">11. How do you enable debugging in Spring Boot?</h3>
<p><strong>Answer:</strong> Enable debugging in Spring Boot by adding the --debug flag when starting the application, setting debug=true in application.properties, or using the -Ddebug command line argument. This activates debug logging and produces auto-configuration report showing which auto-configurations were applied or not applied. For specific class debugging, configure logging.level.package=DEBUG in application.properties.</p>
<h3 id="12-what-are-conditional-annotations-in-spring-boot-">12. What are conditional annotations in Spring Boot?</h3>
<p><strong>Answer:</strong> Conditional annotations control when beans should be created based on specific conditions. Examples include @ConditionalOnClass (condition based on presence of a class), @ConditionalOnMissingBean (when a bean is not defined), @ConditionalOnProperty (based on property value), and @ConditionalOnWebApplication (when it&#39;s a web application). These annotations power Spring Boot&#39;s auto-configuration by creating beans only when appropriate.</p>
<h3 id="13-how-do-you-create-a-custom-starter-in-spring-boot-">13. How do you create a custom starter in Spring Boot?</h3>
<p><strong>Answer:</strong> Create a custom starter by first developing an auto-configuration module with @Configuration classes and @Conditional annotations. Then create a starter module that depends on the auto-configuration module and other necessary dependencies. Follow naming convention &quot;xxx-spring-boot-starter&quot;. Create META-INF/spring.factories file listing your auto-configuration classes under the org.springframework.boot.autoconfigure.EnableAutoConfiguration key to enable auto-discovery.</p>
<h3 id="14-what-is-spring-boot-actuator-">14. What is Spring Boot Actuator?</h3>
<p><strong>Answer:</strong> Spring Boot Actuator is a sub-project that adds production-ready features to applications. It provides endpoints for monitoring and managing the application, including health checks (/actuator/health), metrics (/actuator/metrics), environment information (/actuator/env), and more. Actuator helps with operations tasks like checking application health, viewing configuration details, and monitoring application metrics through HTTP endpoints or JMX.</p>
<h3 id="15-how-can-you-secure-spring-boot-actuator-endpoints-">15. How can you secure Spring Boot Actuator endpoints?</h3>
<p><strong>Answer:</strong> Secure Actuator endpoints by adding the spring-boot-starter-security dependency and configuring endpoint security in application.properties. You can expose only specific endpoints (management.endpoints.web.exposure.include=health,info), require authentication for sensitive endpoints, or configure a separate management port (management.server.port=8081). You can also use Spring Security to define role-based access to different actuator endpoints.</p>
<h3 id="16-what-is-the-restcontroller-annotation-">16. What is the @RestController annotation?</h3>
<p><strong>Answer:</strong> @RestController is a specialized version of @Controller that combines @Controller and @ResponseBody annotations. It indicates that the class handles HTTP requests and the return values from its methods should be bound to the web response body. Unlike regular @Controller, you don&#39;t need to annotate each method with @ResponseBody. It&#39;s commonly used for building RESTful APIs.</p>
<h3 id="17-what-is-the-difference-between-controller-and-restcontroller-">17. What is the difference between @Controller and @RestController?</h3>
<p><strong>Answer:</strong> @Controller is used in Spring MVC to mark a class as a web controller that returns views, typically rendering HTML. @RestController combines @Controller and @ResponseBody, automatically serializing return values to the response body (usually as JSON). Use @Controller for traditional web applications returning views, and @RestController for RESTful web services returning data.</p>
<h3 id="18-what-is-spring-boot-cli-">18. What is Spring Boot CLI?</h3>
<p><strong>Answer:</strong> Spring Boot CLI (Command Line Interface) is a tool that allows you to quickly prototype Spring applications using Groovy scripts. It automatically includes dependencies based on the code you write, eliminating the need for explicit import statements. The CLI supports running applications, testing, grabbing dependencies, and initializing new projects, making it ideal for rapid prototyping and learning.</p>
<h3 id="19-how-do-you-run-a-spring-boot-application-">19. How do you run a Spring Boot application?</h3>
<p><strong>Answer:</strong> Run a Spring Boot application using: 1) Maven command &quot;mvn spring-boot:run&quot; or Gradle command &quot;gradle bootRun&quot; 2) Running the packaged JAR with &quot;java -jar application.jar&quot; 3) Using the main() method in an IDE 4) Using Spring Boot CLI with &quot;spring run app.groovy&quot; for Groovy scripts. The embedded server starts automatically, eliminating the need for external server deployment.</p>
<h3 id="20-what-is-the-default-embedded-server-in-spring-boot-">20. What is the default embedded server in Spring Boot?</h3>
<p><strong>Answer:</strong> Tomcat is the default embedded server in Spring Boot. It&#39;s automatically included and configured when you add spring-boot-starter-web dependency. You can switch to alternative servers like Jetty or Undertow by excluding Tomcat and adding the desired server dependency. Embedded servers eliminate the need for deploying WAR files to external containers, simplifying deployment and development.</p>
<h3 id="21-what-is-spring-boot-initializer-">21. What is Spring Boot Initializer?</h3>
<p><strong>Answer:</strong> Spring Boot Initializer (start.spring.io) is a web-based tool for quickly bootstrapping Spring Boot applications. It allows you to select project type, language (Java, Kotlin, or Groovy), dependencies, Spring Boot version, build tool (Maven or Gradle), and packaging. It generates a project structure with the correct dependencies and configurations that you can download and import into your IDE.</p>
<h3 id="22-how-do-you-handle-exceptions-in-spring-boot-applications-">22. How do you handle exceptions in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Handle exceptions in Spring Boot using @ControllerAdvice or @RestControllerAdvice classes that define @ExceptionHandler methods. These methods catch specific exceptions and return appropriate responses. You can also use HandlerExceptionResolver implementations or customize the default error page by creating an /error view or implementing ErrorController. This centralized approach keeps exception handling separate from business logic.</p>
<h3 id="23-what-is-the-purpose-of-configurationproperties-">23. What is the purpose of @ConfigurationProperties?</h3>
<p><strong>Answer:</strong> @ConfigurationProperties binds external configuration properties to Java objects. It creates type-safe configuration beans where properties from application.properties/yml are mapped to fields in the class. For example, a property &quot;app.name=MyApp&quot; can be bound to a field in a class annotated with @ConfigurationProperties(prefix=&quot;app&quot;). This provides type safety, IDE auto-completion, and allows grouping related properties logically.</p>
<h3 id="24-what-is-the-spring-boot-starter-parent-">24. What is the Spring Boot Starter Parent?</h3>
<p><strong>Answer:</strong> Spring Boot Starter Parent is a special Maven parent POM that provides dependency management for Spring Boot applications. It defines default plugin configurations, Java version compatibility, and dependency versions to ensure compatibility between different Spring modules. By inheriting from this parent POM (via <parent>), projects don&#39;t need to specify versions for Spring Boot dependencies, reducing maintenance effort.</p>
<h3 id="25-how-can-you-change-the-port-of-embedded-tomcat-server-">25. How can you change the port of embedded Tomcat server?</h3>
<p><strong>Answer:</strong> Change the embedded Tomcat server port by setting the server.port property in application.properties or application.yml. You can also change it programmatically by customizing the WebServerFactoryCustomizer bean, by passing a command-line argument --server.port=8081, or by setting the SERVER_PORT environment variable. Use port 0 for a random port assignment useful in testing.</p>
<h3 id="26-what-is-spring-mvc-">26. What is Spring MVC?</h3>
<p><strong>Answer:</strong> Spring MVC (Model-View-Controller) is a web framework built on the Servlet API that implements the MVC design pattern. It separates application logic: the Model contains data, the View presents data, and the Controller handles requests. Spring MVC provides features like dispatcher servlet configuration, form handling, validation, internationalization, and view resolution, making it easier to create web applications.</p>
<h3 id="27-explain-the-spring-mvc-request-flow-">27. Explain the Spring MVC request flow.</h3>
<p><strong>Answer:</strong> When a request arrives, the DispatcherServlet receives it first and consults HandlerMapping to identify the appropriate Controller. The Controller processes the request, populating a Model with data. The Controller returns a logical view name, which the ViewResolver translates into an actual View implementation. Finally, the View renders the Model data, generating the response sent back to the client.</p>
<h3 id="28-what-is-the-requestmapping-annotation-used-for-">28. What is the @RequestMapping annotation used for?</h3>
<p><strong>Answer:</strong> @RequestMapping maps web requests to controller methods based on URL, HTTP method, request parameters, headers, or content type. It can be applied to classes (defining a base path) and methods. For example, @RequestMapping(value=&quot;/users&quot;, method=RequestMethod.GET) handles GET requests to &quot;/users&quot;. Spring Boot also provides shortcut annotations like @GetMapping, @PostMapping, @PutMapping, and @DeleteMapping.</p>
<h3 id="29-what-is-the-difference-between-requestparam-and-pathvariable-">29. What is the difference between @RequestParam and @PathVariable?</h3>
<p><strong>Answer:</strong> @RequestParam extracts query parameters or form data from the request (e.g., /users?id=1), while @PathVariable extracts values from the URL path (e.g., /users/1). @RequestParam is used for optional parameters with potential default values, whereas @PathVariable is for mandatory path segments identifying resources. Both convert string values to the declared parameter type automatically.</p>
<h3 id="30-how-do-you-handle-form-submissions-in-spring-mvc-">30. How do you handle form submissions in Spring MVC?</h3>
<p><strong>Answer:</strong> Handle form submissions with @Controller methods annotated with @PostMapping. Create a model class matching form fields, and use it as a parameter in the controller method. Spring automatically binds form data to the model object. Use @Valid for validation and BindingResult to check for errors. Return a view name to display results or redirect to another page using &quot;redirect:/path&quot;.</p>
<h3 id="31-what-is-responsebody-annotation-">31. What is @ResponseBody annotation?</h3>
<p><strong>Answer:</strong> @ResponseBody indicates that the return value of a controller method should be written directly to the HTTP response body, rather than being interpreted as a view name. When used with object return types, Spring automatically converts the object to JSON or XML based on content negotiation. @RestController includes this functionality by default for all methods.</p>
<h3 id="32-how-do-you-create-restful-web-services-in-spring-boot-">32. How do you create RESTful web services in Spring Boot?</h3>
<p><strong>Answer:</strong> Create RESTful services by using @RestController annotation on a class and HTTP method annotations (@GetMapping, @PostMapping, etc.) on methods. Return domain objects directly; Spring Boot automatically converts them to JSON. Use @PathVariable for URL path parameters, @RequestBody for request payloads, and appropriate HTTP status codes. Spring Boot&#39;s content negotiation handles serialization and media types.</p>
<h3 id="33-what-is-spring-hateoas-">33. What is Spring HATEOAS?</h3>
<p><strong>Answer:</strong> Spring HATEOAS (Hypermedia as the Engine of Application State) helps create REST APIs that follow HATEOAS principles by including hypermedia links with responses. It provides classes like EntityModel, CollectionModel, and WebMvcLinkBuilder to add links to resources. This enables clients to navigate the API dynamically through provided links, making the API more discoverable and self-documenting.</p>
<h3 id="34-how-do-you-document-rest-apis-in-spring-boot-">34. How do you document REST APIs in Spring Boot?</h3>
<p><strong>Answer:</strong> Document REST APIs in Spring Boot using SpringDoc OpenAPI (formerly Springfox Swagger). Add the springdoc-openapi-ui dependency, and it automatically generates OpenAPI documentation based on your controllers, request/response models, and annotations. Enhance documentation using @Operation, @ApiResponse, and @Parameter annotations. Access the API documentation UI at /swagger-ui.html and the OpenAPI JSON at /v3/api-docs.</p>
<h3 id="35-what-is-content-negotiation-in-spring-mvc-">35. What is content negotiation in Spring MVC?</h3>
<p><strong>Answer:</strong> Content negotiation determines the format of the response based on client preferences. Spring examines the Accept header, URL path extension (.json, .xml), or request parameter (format=json) to decide the format. Configure content negotiation in Spring Boot using the spring.mvc.contentnegotiation.* properties. Spring will automatically convert response objects to the requested format using appropriate HttpMessageConverter implementations.</p>
<h3 id="36-what-are-httpmessageconverters-in-spring-">36. What are HttpMessageConverters in Spring?</h3>
<p><strong>Answer:</strong> HttpMessageConverters transform HTTP request bodies to method parameters and convert return values to HTTP response bodies. Spring Boot registers default converters for common formats like JSON (using Jackson), XML, form data, and plain text. They enable @RequestBody to deserialize request content into objects and @ResponseBody to serialize objects into response content based on the Content-Type and Accept headers.</p>
<h3 id="37-how-do-you-handle-validation-in-spring-rest-apis-">37. How do you handle validation in Spring REST APIs?</h3>
<p><strong>Answer:</strong> Implement validation in Spring REST APIs using Bean Validation annotations (@NotNull, @Size, @Email) on model classes and the @Valid annotation on controller method parameters. Add the spring-boot-starter-validation dependency to enable validation support. Use BindingResult parameter to check validation errors or let Spring automatically throw MethodArgumentNotValidException, which can be handled by @ExceptionHandler methods.</p>
<h3 id="38-what-is-the-crossorigin-annotation-">38. What is the @CrossOrigin annotation?</h3>
<p><strong>Answer:</strong> @CrossOrigin enables Cross-Origin Resource Sharing (CORS) for controller methods, allowing web browsers to make requests to your API from different domains. It can be applied to classes or methods with parameters to configure allowed origins, HTTP methods, headers, and credentials. For global CORS configuration, implement WebMvcConfigurer and override addCorsMappings() method or use CorsFilter in a WebFilter configuration.</p>
<h3 id="39-how-do-you-implement-file-upload-in-spring-boot-">39. How do you implement file upload in Spring Boot?</h3>
<p><strong>Answer:</strong> Implement file upload by using MultipartFile parameter in controller methods and ensuring your form has enctype=&quot;multipart/form-data&quot;. Configure maximum file size with spring.servlet.multipart.max-file-size and spring.servlet.multipart.max-request-size properties. Use MultipartFile methods like getBytes(), getInputStream(), or transferTo() to process the uploaded file. Add appropriate error handling for file size exceptions.</p>
<h3 id="40-what-is-spring-webflux-">40. What is Spring WebFlux?</h3>
<p><strong>Answer:</strong> Spring WebFlux is Spring&#39;s reactive web framework that operates on non-blocking servers like Netty. It enables building asynchronous, non-blocking web applications that can handle many concurrent connections with fewer threads. WebFlux uses Reactor&#39;s Mono and Flux types to represent single and multiple asynchronous values. It&#39;s suitable for microservices with high concurrency requirements or stream processing applications.</p>
<h3 id="41-what-is-the-difference-between-requestbody-and-modelattribute-">41. What is the difference between @RequestBody and @ModelAttribute?</h3>
<p><strong>Answer:</strong> @RequestBody binds the HTTP request body to an object using HttpMessageConverter (typically for JSON/XML in REST APIs), while @ModelAttribute binds form data or query parameters to objects. @RequestBody expects the entire object in the request body, whereas @ModelAttribute can bind individual form fields or query parameters to object properties and supports nested properties.</p>
<h3 id="42-how-do-you-access-request-headers-in-a-spring-controller-">42. How do you access request headers in a Spring controller?</h3>
<p><strong>Answer:</strong> Access request headers in a Spring controller by: 1) Using @RequestHeader annotation on a method parameter (@RequestHeader(&quot;User-Agent&quot;) String userAgent), 2) Injecting HttpServletRequest and calling getHeader() method, 3) Using HttpHeaders parameter with @RequestHeader annotation, or 4) Using the headers() method of WebRequest object. For optional headers, set the required attribute to false.</p>
<h3 id="43-what-is-the-controlleradvice-annotation-">43. What is the @ControllerAdvice annotation?</h3>
<p><strong>Answer:</strong> @ControllerAdvice is a specialized annotation for global exception handling and binding configurations. Classes annotated with @ControllerAdvice contain @ExceptionHandler, @InitBinder, or @ModelAttribute methods that apply to all controllers. It provides centralized exception handling across multiple controllers, global data binding configuration, and pre-populating model attributes for all controllers.</p>
<h3 id="44-how-do-you-implement-pagination-in-spring-rest-apis-">44. How do you implement pagination in Spring REST APIs?</h3>
<p><strong>Answer:</strong> Implement pagination using Spring Data&#39;s Pageable parameter in controller methods. Return Page or Slice objects that contain both data and pagination metadata. Configure with request parameters like page, size, and sort (e.g., /api/users?page=0&amp;size=20&amp;sort=lastname,desc). Spring HATEOAS can enhance responses with navigation links. Spring Data repositories automatically support pagination when methods accept Pageable parameters.</p>
<h3 id="45-what-is-the-purpose-of-resttemplate-">45. What is the purpose of RestTemplate?</h3>
<p><strong>Answer:</strong> RestTemplate is Spring&#39;s synchronous HTTP client for consuming REST services. It simplifies HTTP requests by handling URL creation, data marshalling/unmarshalling, and exception translation. It provides methods like getForObject(), postForEntity(), and exchange() to perform HTTP operations and convert responses to Java objects. However, for new applications, Spring recommends using the reactive WebClient.</p>
<h3 id="46-what-is-webclient-in-spring-">46. What is WebClient in Spring?</h3>
<p><strong>Answer:</strong> WebClient is Spring&#39;s reactive HTTP client introduced as part of WebFlux. It provides non-blocking, asynchronous HTTP requests with a fluent API. Unlike RestTemplate, WebClient returns reactive types (Mono/Flux) allowing efficient resource utilization and composable asynchronous operations. It supports streaming scenarios, has better backpressure support, and works with both reactive and traditional servlet-based applications.</p>
<h3 id="47-how-do-you-handle-custom-http-response-status-codes-in-spring-">47. How do you handle custom HTTP response status codes in Spring?</h3>
<p><strong>Answer:</strong> Handle custom HTTP status codes by: 1) Using @ResponseStatus annotation on exception classes or controller methods, 2) Returning ResponseEntity with specific status code (return ResponseEntity.status(HttpStatus.CREATED).body(result)), 3) Using HttpServletResponse and setting the status directly, or 4) Implementing exception handlers that return specific status codes. Spring Boot also allows mapping status codes to custom error pages.</p>
<h3 id="48-what-is-the-purpose-of-initbinder-">48. What is the purpose of @InitBinder?</h3>
<p><strong>Answer:</strong> @InitBinder customizes the data binding process in Spring MVC. Methods annotated with @InitBinder register custom property editors, validators, or adjust binding configurations for specific form submissions. It&#39;s used to convert request parameters to complex objects, define acceptable fields, reject specific values, or transform data before binding. @InitBinder methods can be controller-specific or global when defined in @ControllerAdvice classes.</p>
<h3 id="49-how-do-you-implement-request-filtering-in-spring-boot-">49. How do you implement request filtering in Spring Boot?</h3>
<p><strong>Answer:</strong> Implement request filtering by creating a class that implements Filter interface and registering it as a @Component or using FilterRegistrationBean. For more integrated solutions, use Spring Security filters or create HandlerInterceptors by implementing the HandlerInterceptor interface and registering them via WebMvcConfigurer.addInterceptors(). Filters run outside the Spring context while interceptors run within it.</p>
<h3 id="50-what-is-the-difference-between-put-and-patch-methods-in-rest-">50. What is the difference between PUT and PATCH methods in REST?</h3>
<p><strong>Answer:</strong> PUT replaces an entire resource with the request payload, requiring the complete representation even for unchanged fields. PATCH applies partial modifications to a resource, updating only the fields included in the request. PUT is idempotent (multiple identical requests produce the same result), while PATCH may not be depending on implementation. Spring supports both with @PutMapping and @PatchMapping annotations.</p>
<h3 id="51-what-is-spring-data-jpa-">51. What is Spring Data JPA?</h3>
<p><strong>Answer:</strong> Spring Data JPA is a module of Spring Data that simplifies data access by reducing boilerplate code for JPA-based repositories. It provides a repository abstraction that implements CRUD operations automatically based on method names. By extending interfaces like JpaRepository, you get pre-implemented methods for common operations while still being able to define custom query methods using conventions or annotations.</p>
<h3 id="52-what-are-the-benefits-of-using-spring-data-jpa-">52. What are the benefits of using Spring Data JPA?</h3>
<p><strong>Answer:</strong> Spring Data JPA reduces boilerplate code with pre-implemented repository methods, supports query creation from method names (findByLastName), provides pagination and sorting without custom code, offers auditing capabilities (createdBy, lastModifiedDate), integrates with Spring&#39;s transaction management, and maintains database-agnostic code. It also supports specifications, query by example, and projection interfaces for custom result mappings.</p>
<h3 id="53-how-do-you-define-a-spring-data-repository-">53. How do you define a Spring Data repository?</h3>
<p><strong>Answer:</strong> Define a Spring Data repository by creating an interface that extends one of Spring Data&#39;s repository interfaces (JpaRepository, CrudRepository, PagingAndSortingRepository, etc.) and type it with your entity class and ID type: public interface UserRepository extends JpaRepository<User, Long> {}. Spring Data automatically generates an implementation with standard CRUD methods and any custom query methods you define.</p>
<h3 id="54-explain-the-spring-data-repository-hierarchy-">54. Explain the Spring Data repository hierarchy.</h3>
<p><strong>Answer:</strong> Spring Data&#39;s repository hierarchy starts with Repository (marker interface), followed by CrudRepository (basic CRUD operations), then PagingAndSortingRepository (adds pagination and sorting). JpaRepository extends both and adds JPA-specific methods like flush() and saveAndFlush(). Each level adds functionality, allowing you to choose an interface based on required capabilities while maintaining loose coupling between your code and Spring Data.</p>
<h3 id="55-what-is-the-difference-between-crudrepository-and-jparepository-">55. What is the difference between CrudRepository and JpaRepository?</h3>
<p><strong>Answer:</strong> CrudRepository provides basic CRUD operations (save, findById, findAll, delete, etc.) for any data store, while JpaRepository extends it with JPA-specific functionality like flushing the persistence context, batch deletes, and improved pagination support with JPA queries. JpaRepository returns List instead of Iterable and includes methods like saveAndFlush() and deleteInBatch(). Use CrudRepository for more generic code or JpaRepository for JPA-specific features.</p>
<h3 id="56-how-does-spring-data-jpa-create-queries-from-method-names-">56. How does Spring Data JPA create queries from method names?</h3>
<p><strong>Answer:</strong> Spring Data JPA parses method names following conventions to generate queries automatically. Method names start with find/get/query/read/count/delete followed by By and then property names connected by And/Or (findByFirstNameAndLastName). It supports operators like Between, LessThan, GreaterThan, Like, and OrderBy. During application startup, Spring Data validates and creates the actual query implementation from these method names.</p>
<h3 id="57-how-do-you-write-custom-queries-in-spring-data-jpa-">57. How do you write custom queries in Spring Data JPA?</h3>
<p><strong>Answer:</strong> Write custom queries using the @Query annotation above repository methods, specifying JPQL or native SQL. For example, @Query(&quot;SELECT u FROM User u WHERE u.email = ?1&quot;) or @Query(value = &quot;SELECT * FROM users WHERE email = ?1&quot;, nativeQuery = true). Use named parameters with @Param annotation: @Query(&quot;SELECT u FROM User u WHERE u.email = :email&quot;) User findByEmail(@Param(&quot;email&quot;) String email);</p>
<h3 id="58-what-is-entityscan-annotation-in-spring-boot-">58. What is @EntityScan annotation in Spring Boot?</h3>
<p><strong>Answer:</strong> @EntityScan tells Spring Boot where to find JPA entity classes when they&#39;re not in the default package or its sub-packages. By default, Spring Boot scans the package containing the main application class. Use @EntityScan when entities are in different packages: @EntityScan(basePackages = &quot;com.example.domain&quot;) or @EntityScan(basePackageClasses = User.class). This ensures EntityManagerFactory can discover and manage all entities.</p>
<h3 id="59-how-do-you-configure-multiple-data-sources-in-spring-boot-">59. How do you configure multiple data sources in Spring Boot?</h3>
<p><strong>Answer:</strong> Configure multiple data sources by defining separate DataSource, EntityManagerFactory, and TransactionManager beans for each database. Use @Primary for the default data source. Create configuration classes for each data source with @EnableJpaRepositories specifying basePackages and entityManagerFactoryRef. Use @Qualifier when autowiring repositories to indicate which data source to use. Configure connection properties with prefixes like spring.datasource.primary and spring.datasource.secondary.</p>
<h3 id="60-what-is-the-modifying-annotation-in-spring-data-jpa-">60. What is the @Modifying annotation in Spring Data JPA?</h3>
<p><strong>Answer:</strong> @Modifying indicates that a @Query method performs an update operation (INSERT, UPDATE, DELETE, or DDL) rather than a select. It must be used with @Transactional and can be configured with clearAutomatically=true to flush the persistence context after execution. Without @Modifying, Spring Data assumes the query is read-only, and update operations would cause an InvalidDataAccessApiUsageException.</p>
<h3 id="61-what-is-the-difference-between-findbyid-and-getbyid-in-jparepository-">61. What is the difference between findById and getById in JpaRepository?</h3>
<p><strong>Answer:</strong> findById returns Optional<T> containing the entity or empty if not found, eagerly loading the entity. getById (or getOne in older versions) returns a reference proxy without hitting the database immediately (lazy loading). The proxy resolves to the actual entity when its properties are accessed, throwing EntityNotFoundException if the entity doesn&#39;t exist. Use findById for immediate access and getById for performance when you&#39;ll use the entity later.</p>
<h3 id="62-how-do-you-implement-pagination-and-sorting-in-spring-data-jpa-">62. How do you implement pagination and sorting in Spring Data JPA?</h3>
<p><strong>Answer:</strong> Implement pagination and sorting by adding Pageable parameter to repository methods: Page<User> findByLastName(String lastName, Pageable pageable);. In controllers, receive page, size, and sort parameters and create a Pageable object using PageRequest.of(page, size, Sort.by(&quot;field&quot;)). The Page<T> return type contains both data and metadata (total pages, elements, etc.). Use Sort objects for standalone sorting without pagination.</p>
<h3 id="63-what-are-spring-data-jpa-projections-">63. What are Spring Data JPA projections?</h3>
<p><strong>Answer:</strong> Projections limit query results to specific fields instead of fetching entire entities. Define an interface with getter methods matching entity property names (interface UserSummary { String getName(); String getEmail(); }). Use it as the return type in repository methods: List<UserSummary> findByLastName(String lastName);. This improves performance by reducing data transfer. Supports interface, class-based (DTO), and dynamic projections for flexible data retrieval.</p>
<h3 id="64-what-is-the-version-annotation-in-jpa-">64. What is the @Version annotation in JPA?</h3>
<p><strong>Answer:</strong> @Version marks a field for optimistic locking, preventing concurrent modifications. JPA increments this field (typically an Integer or Timestamp) with each update. If two transactions try to update the same record, the second will fail with OptimisticLockException because the version doesn&#39;t match the expected value. This ensures data integrity without pessimistic locks, working well in high-read, low-write scenarios.</p>
<h3 id="65-how-do-you-implement-auditing-in-spring-data-jpa-">65. How do you implement auditing in Spring Data JPA?</h3>
<p><strong>Answer:</strong> Implement auditing by adding @EnableJpaAuditing to a configuration class, implementing AuditorAware<T> bean to provide current user, and using annotations on entity fields: @CreatedDate, @LastModifiedDate, @CreatedBy, @LastModifiedBy. Entity classes should extend AbstractAuditable or use @EntityListeners(AuditingEntityListener.class). Spring automatically populates these fields during persist/update operations, tracking who modified records and when.</p>
<h3 id="66-what-is-dynamicupdate-in-hibernate-">66. What is @DynamicUpdate in Hibernate?</h3>
<p><strong>Answer:</strong> @DynamicUpdate instructs Hibernate to include only modified columns in UPDATE statements rather than all columns. This optimization reduces SQL statement size and database load, especially for entities with many properties where only a few change frequently. Without @DynamicUpdate, Hibernate generates UPDATE statements with all columns regardless of which properties were actually changed.</p>
<h3 id="67-what-is-the-difference-between-lazy-and-eager-fetching-in-jpa-">67. What is the difference between lazy and eager fetching in JPA?</h3>
<p><strong>Answer:</strong> Eager fetching loads associated entities immediately with the parent entity (one SQL join), while lazy fetching loads them only when accessed (separate SQL queries). JPA defaults: @OneToOne/@ManyToOne are EAGER, @OneToMany/@ManyToMany are LAZY. Lazy loading requires an open persistence context when accessing associations to avoid LazyInitializationException. Choose eager for small, frequently accessed associations and lazy for large or rarely accessed collections.</p>
<h3 id="68-how-do-you-handle-entity-relationships-in-jpa-">68. How do you handle entity relationships in JPA?</h3>
<p><strong>Answer:</strong> Define entity relationships using annotations: @OneToOne, @OneToMany, @ManyToOne, and @ManyToMany. Configure fetch type, cascade operations, and orphan removal as needed. Use mappedBy attribute on the non-owning side of bidirectional relationships to avoid duplicate tables. For @ManyToMany, create join tables with @JoinTable. Manage both sides of bidirectional relationships in entity methods to maintain consistency.</p>
<h3 id="69-what-is-a-derived-query-method-in-spring-data-jpa-">69. What is a derived query method in Spring Data JPA?</h3>
<p><strong>Answer:</strong> A derived query method is created by following Spring Data&#39;s naming conventions, allowing Spring to automatically generate the query implementation. Method names start with find/get/count followed by By and property names: findByEmailAndActive(String email, boolean active). Spring Data parses these method names at startup and generates appropriate JPQL queries, eliminating the need for manual query writing for common operations.</p>
<h3 id="70-what-is-the-difference-between-save-and-saveandflush-in-jparepository-">70. What is the difference between save() and saveAndFlush() in JpaRepository?</h3>
<p><strong>Answer:</strong> save() persists entities to the persistence context but doesn&#39;t guarantee immediate database synchronization (occurs at transaction commit or explicit flush). saveAndFlush() persists the entity and immediately flushes changes to the database. Use save() for multiple operations within a transaction for better performance, and saveAndFlush() when you need to see the effects of a save operation immediately (like generated IDs).</p>
<h3 id="71-how-do-you-implement-custom-repository-methods-in-spring-data-jpa-">71. How do you implement custom repository methods in Spring Data JPA?</h3>
<p><strong>Answer:</strong> Implement custom repository methods by: 1) Defining the method in a separate interface: interface CustomUserRepository { void someCustomMethod(); }, 2) Creating an implementation class: class CustomUserRepositoryImpl implements CustomUserRepository { }, 3) Extending both interfaces in your repository: interface UserRepository extends JpaRepository<User, Long>, CustomUserRepository {}. Spring Data automatically finds and wires the implementation class using the Impl suffix convention.</p>
<h3 id="72-what-is-a-native-query-in-spring-data-jpa-">72. What is a native query in Spring Data JPA?</h3>
<p><strong>Answer:</strong> A native query is plain SQL rather than JPQL, useful for database-specific features or optimized queries. Use it with @Query annotation and nativeQuery=true flag: @Query(value = &quot;SELECT * FROM users WHERE last_login &lt; ?1&quot;, nativeQuery = true). Native queries bypass the JPA abstraction layer, making them less portable but potentially more efficient for complex queries or when using database-specific functions.</p>
<h3 id="73-how-do-you-implement-transactions-in-spring-boot-">73. How do you implement transactions in Spring Boot?</h3>
<p><strong>Answer:</strong> Implement transactions using the @Transactional annotation on service methods or classes. Spring Boot auto-configures a transaction manager when a supported database dependency is detected. Configure isolation levels, propagation behavior, timeout, and rollback rules as annotation attributes. For example, @Transactional(rollbackFor = Exception.class, isolation = Isolation.READ_COMMITTED). Service layer transactions are recommended over repository-level transactions for business logic encapsulation.</p>
<h3 id="74-what-is-the-query-annotation-in-spring-data-jpa-">74. What is the @Query annotation in Spring Data JPA?</h3>
<p><strong>Answer:</strong> @Query defines custom JPQL or SQL queries on repository methods when method name derivation is insufficient. For example, @Query(&quot;SELECT u FROM User u WHERE u.status = :status&quot;) List<User> findByStatus(@Param(&quot;status&quot;) String status);. It supports named parameters, native queries (nativeQuery=true), pagination (with Pageable parameter), and SpEL expressions. @Query overrides the query that would be generated from the method name.</p>
<h3 id="75-what-is-the-difference-between-jpa-and-hibernate-">75. What is the difference between JPA and Hibernate?</h3>
<p><strong>Answer:</strong> JPA (Jakarta Persistence API) is a specification/standard for ORM in Java, while Hibernate is a specific implementation of JPA. JPA defines the API (annotations, interfaces) but doesn&#39;t provide implementation. Hibernate adds features beyond the JPA specification like custom types, filters, and caching strategies. Spring Data JPA uses the JPA standard but typically runs with Hibernate as the implementation, keeping your code vendor-neutral.</p>
<h3 id="76-what-is-the-hibernate-session-object-">76. What is the Hibernate Session object?</h3>
<p><strong>Answer:</strong> Hibernate Session is the primary runtime interface between a Java application and Hibernate. It&#39;s a lightweight, single-threaded object representing a conversation with the database. Session objects create, read, update and delete persistent objects, act as a transaction factory, and provide a first-level cache. In JPA terms, Session is similar to EntityManager but with Hibernate-specific extra functionality.</p>
<h3 id="77-what-is-the-difference-between-entitymanager-and-session-in-hibernate-">77. What is the difference between EntityManager and Session in Hibernate?</h3>
<p><strong>Answer:</strong> EntityManager is the JPA standard interface for persistence operations, while Session is Hibernate&#39;s equivalent with additional features. Session extends beyond JPA&#39;s specification with methods like createFilter(), enableFilter(), and more flexible caching options. When using Hibernate with JPA, you can unwrap the EntityManager to access the underlying Session: Session session = entityManager.unwrap(Session.class);</p>
<h3 id="78-what-are-the-different-states-of-a-hibernate-entity-">78. What are the different states of a Hibernate entity?</h3>
<p><strong>Answer:</strong> Hibernate entities exist in one of four states: 1) Transient: new objects not associated with any Session or database record, 2) Persistent: objects associated with a Session and database record, changes are tracked, 3) Detached: objects previously persistent but no longer associated with a Session, and 4) Removed: objects scheduled for deletion. Transitions occur via methods like persist(), merge(), remove(), and detach().</p>
<h3 id="79-what-is-the-hibernate-criteria-api-">79. What is the Hibernate criteria API?</h3>
<p><strong>Answer:</strong> The Hibernate Criteria API is a programmatic, type-safe way to build queries without string-based HQL. It provides methods for restrictions, projections, ordering, and grouping. The JPA Criteria API (which Hibernate implements) is the standard alternative. Both allow for dynamic query construction using a fluent API: CriteriaBuilder cb = session.getCriteriaBuilder(); CriteriaQuery<User> query = cb.createQuery(User.class);. They&#39;re useful when queries must be built at runtime.</p>
<h3 id="80-what-is-hibernate-caching-">80. What is Hibernate caching?</h3>
<p><strong>Answer:</strong> Hibernate caching improves performance by storing frequently accessed data in memory, reducing database access. It has two levels: First-level cache (Session scope, always enabled) keeps objects during a single transaction. Second-level cache (SessionFactory scope, optional) shares data across sessions for all users. Implementation options include EHCache, Hazelcast, and Redis. Entity and query caching strategies are configured per entity class.</p>
<h3 id="81-what-is-the-difference-between-get-and-load-methods-in-hibernate-">81. What is the difference between get() and load() methods in Hibernate?</h3>
<p><strong>Answer:</strong> get() returns null if the entity doesn&#39;t exist and always hits the database or cache, returning a fully initialized object. load() returns a proxy without hitting the database and throws ObjectNotFoundException when accessing the unexisting entity&#39;s properties. get() confirms existence immediately while load() assumes existence and creates a proxy, improving performance when you&#39;re certain the entity exists or only need its ID.</p>
<h3 id="82-what-is-hql-hibernate-query-language-">82. What is HQL (Hibernate Query Language)?</h3>
<p><strong>Answer:</strong> HQL is Hibernate&#39;s object-oriented query language, similar to SQL but operating on persistent objects rather than database tables. It uses class and property names instead of tables and columns, supports polymorphism, associations, and pagination. HQL is database-independent and can be parameterized to prevent SQL injection. For example, &quot;FROM User u WHERE u.email = :email&quot; queries the User entity rather than a &quot;users&quot; table.</p>
<h3 id="83-what-is-dirty-checking-in-hibernate-">83. What is dirty checking in Hibernate?</h3>
<p><strong>Answer:</strong> Dirty checking is Hibernate&#39;s automatic detection of changes in persistent entities during a transaction. When a transaction commits, Hibernate compares entity properties with their original values (snapshot) and generates SQL updates only for changed fields. This happens automatically for persistent entities without explicit save() calls, simplifying code by eliminating explicit update operations while maintaining database synchronization.</p>
<h3 id="84-what-is-the-cascade-annotation-in-hibernate-">84. What is the @Cascade annotation in Hibernate?</h3>
<p><strong>Answer:</strong> @Cascade specifies operations that should be cascaded to associated entities. It&#39;s a Hibernate-specific annotation with options like SAVE_UPDATE, DELETE, MERGE, PERSIST, and ALL. JPA&#39;s standard equivalent is @Cascade with CascadeType values (PERSIST, MERGE, REMOVE, REFRESH, ALL). Cascading allows operations on parent entities to automatically apply to related entities, reducing code needed to maintain relationship consistency.</p>
<h3 id="85-what-are-value-types-in-hibernate-">85. What are value types in Hibernate?</h3>
<p><strong>Answer:</strong> Value types in Hibernate are objects without identity, owned by entities. They include basic types (String, Integer), embeddable types (@Embeddable classes), and collections of basic/embeddable types. Unlike entities, value types don&#39;t have their own lifecycle or database identity. They&#39;re persisted as part of their owning entity and cannot be shared between entities. Use @Embeddable and @ElementCollection annotations to define custom value types.</p>
<h3 id="86-what-is-the-difference-between-fetchtype-lazy-and-fetchtype-eager-">86. What is the difference between FetchType.LAZY and FetchType.EAGER?</h3>
<p><strong>Answer:</strong> FetchType.LAZY loads associated data only when explicitly accessed, reducing initial query load, while FetchType.EAGER loads associations immediately with the parent entity. LAZY improves performance for large collections or rarely accessed associations but requires active persistence context to avoid LazyInitializationException. EAGER simplifies programming by ensuring data is available but can hurt performance with large associations or deep graphs.</p>
<h3 id="87-what-is-hibernate-inheritance-mapping-">87. What is Hibernate inheritance mapping?</h3>
<p><strong>Answer:</strong> Hibernate inheritance mapping persists class hierarchies to database tables using strategies like: 1) Single Table: all classes in one table with discriminator column (simplest, best performance), 2) Joined: one table per class with foreign keys (normalized but slower joins), 3) Table Per Class: one complete table per concrete class (duplicate columns, no polymorphic queries), and 4) Mapped Superclass: parent properties in child tables (no parent table).</p>
<h3 id="88-what-is-the-n-1-query-problem-and-how-do-you-solve-it-">88. What is the N+1 query problem, and how do you solve it?</h3>
<p><strong>Answer:</strong> The N+1 query problem occurs when accessing a collection of N associated entities, causing N additional database queries (1 for parent + N for children). Solve it by using fetch joins in JPQL/HQL (@Query(&quot;SELECT u FROM User u JOIN FETCH u.roles&quot;)), entity graphs (@EntityGraph), or batch fetching configuration (@BatchSize). These approaches load associated entities in advance or with fewer queries, significantly improving performance.</p>
<h3 id="89-what-is-the-formula-annotation-in-hibernate-">89. What is the @Formula annotation in Hibernate?</h3>
<p><strong>Answer:</strong> @Formula maps a non-column database expression to an entity property. It contains SQL that&#39;s executed when the entity is loaded, useful for calculated fields, database functions, or denormalized data: @Formula(&quot;(SELECT AVG(r.rating) FROM reviews r WHERE r.product_id = id)&quot;). The formula is read-only and exists only in Java, not as a database column. It&#39;s helpful for complex calculations that are better handled by the database.</p>
<h3 id="90-how-do-you-implement-composite-keys-in-jpa-">90. How do you implement composite keys in JPA?</h3>
<p><strong>Answer:</strong> Implement composite keys by creating an @Embeddable class containing the key fields, then use @EmbeddedId in the entity: @Embeddable class OrderItemPK { Long orderId; Long productId; } and @Entity class OrderItem { @EmbeddedId OrderItemPK id; }. Alternatively, use @IdClass with separate ID fields. Both approaches require implementing equals() and hashCode() in the key class and properly handling key components in repository operations.</p>
<h3 id="91-what-is-mapsid-in-jpa-">91. What is @MapsId in JPA?</h3>
<p><strong>Answer:</strong> @MapsId makes a foreign key part of the primary key in one-to-one and many-to-one relationships. It maps the primary key of an entity to a foreign key referencing another entity: @Entity class UserProfile { @OneToOne @MapsId private User user; @Id private Long id; }. This creates shared primary key associations where the child entity&#39;s primary key is also a foreign key to the parent, simplifying key management.</p>
<h3 id="92-what-is-the-difference-between-persist-and-merge-in-jpa-">92. What is the difference between persist() and merge() in JPA?</h3>
<p><strong>Answer:</strong> persist() makes a transient entity persistent, throwing exception if the entity already exists, and doesn&#39;t return a value. merge() copies state from a detached entity to a persistent instance, creating a new persistent entity if none exists, and returns the managed instance. Use persist() for new entities and merge() for detached entities (e.g., entities from previous sessions or updated from the web tier).</p>
<h3 id="93-what-are-named-queries-in-jpa-">93. What are named queries in JPA?</h3>
<p><strong>Answer:</strong> Named queries are predefined, reusable JPQL queries declared in entity classes using @NamedQuery or @NamedQueries annotations: @NamedQuery(name = &quot;User.findByEmail&quot;, query = &quot;SELECT u FROM User u WHERE u.email = :email&quot;). They&#39;re validated at startup, centralize query logic, improve code organization, and can improve performance through prepared statement caching. Access them via EntityManager.createNamedQuery() or in Spring Data repository methods with @Query(name = &quot;User.findByEmail&quot;).</p>
<h3 id="94-how-do-you-implement-optimistic-locking-in-jpa-">94. How do you implement optimistic locking in JPA?</h3>
<p><strong>Answer:</strong> Implement optimistic locking by adding a version field to entities with @Version annotation: @Version private Long version;. JPA automatically increments this field during updates and verifies it hasn&#39;t changed since the entity was loaded. If another transaction changes the version in between, OptimisticLockException is thrown. This prevents concurrent modifications without database locks, ideal for applications with more reads than writes.</p>
<h3 id="95-what-is-the-idclass-annotation-in-jpa-">95. What is the @IdClass annotation in JPA?</h3>
<p><strong>Answer:</strong> @IdClass specifies a composite primary key class for an entity. The entity must duplicate all fields from the key class and mark them with @Id: @Entity @IdClass(EmployeePK.class) class Employee { @Id private String department; @Id private Long employeeNumber; }. The key class must be serializable with equals() and hashCode(). Unlike @EmbeddedId, @IdClass keeps primary key fields visible in the entity class.</p>
<h3 id="96-what-is-the-entitymanager-flush-method-">96. What is the EntityManager.flush() method?</h3>
<p><strong>Answer:</strong> EntityManager.flush() synchronizes the persistence context with the database, executing pending SQL statements for entity changes. It doesn&#39;t commit the transaction but makes changes visible to subsequent JPQL queries within the same transaction. Flushing happens automatically at transaction commit, before queries, or when explicitly called. It&#39;s useful when you need changes to be visible to native queries or other processes.</p>
<h3 id="97-what-is-a-bidirectional-relationship-in-jpa-">97. What is a bidirectional relationship in JPA?</h3>
<p><strong>Answer:</strong> A bidirectional relationship allows navigation in both directions between entities. Define it with complementary annotations on both sides (@OneToMany and @ManyToOne, or @OneToOne on both). Use mappedBy on the non-owning side to indicate the owning side property: @Entity class Department { @OneToMany(mappedBy = &quot;department&quot;) Set<Employee> employees; } and @Entity class Employee { @ManyToOne Department department; }. Maintain both sides when modifying relationships to ensure consistency.</p>
<h3 id="98-how-do-you-implement-soft-delete-in-jpa-">98. How do you implement soft delete in JPA?</h3>
<p><strong>Answer:</strong> Implement soft delete by adding a boolean deleted or timestamp deletedAt field to entities, then filter queries to exclude deleted records. Use @SQLDelete and @Where annotations in Hibernate: @SQLDelete(sql=&quot;UPDATE users SET deleted=true WHERE id=?&quot;) @Where(clause=&quot;deleted=false&quot;) class User { boolean deleted; }. Alternatively, implement @PreRemove entity listener that sets the deleted flag instead of removing the record or create filtered repositories with custom query methods.</p>
<h3 id="99-what-is-the-difference-between-unidirectional-and-bidirectional-relationships-">99. What is the difference between unidirectional and bidirectional relationships?</h3>
<p><strong>Answer:</strong> Unidirectional relationships allow navigation in only one direction (e.g., Order can access Customer, but Customer cannot access Orders), while bidirectional relationships allow navigation in both directions. Bidirectional relationships provide convenience but require maintaining both sides when modifying the relationship and specifying mappedBy to avoid duplicate join tables. Unidirectional relationships are simpler to maintain but may require additional queries.</p>
<h3 id="100-what-is-a-fetching-strategy-in-jpa-">100. What is a fetching strategy in JPA?</h3>
<p><strong>Answer:</strong> A fetching strategy determines when associated entities are loaded from the database. JPA offers LAZY (load when accessed) and EAGER (load immediately) strategies, configurable via fetch attribute in relationship annotations. Select strategies based on access patterns: use EAGER for small, always-needed associations and LAZY for large or rarely accessed associations. Also consider fetch joins (JOIN FETCH) for specific queries to override default strategies.</p>
<h3 id="101-what-are-spring-profiles-and-how-do-you-use-them-">101. What are Spring Profiles and how do you use them?</h3>
<p><strong>Answer:</strong> Spring Profiles provide a way to segregate parts of application configuration and make them available only in specific environments. Activate profiles using spring.profiles.active property (via properties file, command line, or environment variable). Use @Profile annotation on beans to make them active only in specific profiles. Profile-specific properties files (application-{profile}.properties) override default settings when that profile is active.</p>
<h3 id="102-how-does-spring-boot-handle-database-migrations-">102. How does Spring Boot handle database migrations?</h3>
<p><strong>Answer:</strong> Spring Boot integrates with migration tools like Flyway and Liquibase through auto-configuration. With Flyway, place SQL scripts in resources/db/migration with naming convention V1<strong>Description.sql, V2</strong>Description.sql. With Liquibase, define changesets in resources/db/changelog. Both execute migrations automatically on startup, ensuring database schema stays in sync across environments and preventing inconsistencies during deployments.</p>
<h3 id="103-what-is-spring-boot-actuator-and-what-endpoints-does-it-provide-">103. What is Spring Boot Actuator and what endpoints does it provide?</h3>
<p><strong>Answer:</strong> Spring Boot Actuator adds production-ready monitoring and management capabilities to applications. Key endpoints include /health (application health status), /metrics (application metrics), /env (environment properties), /mappings (request mappings), /beans (application context beans), and /loggers (logging configuration). These HTTP endpoints provide insights into application internals, configure components at runtime, and help with troubleshooting.</p>
<h3 id="104-how-do-you-implement-custom-error-pages-in-spring-boot-">104. How do you implement custom error pages in Spring Boot?</h3>
<p><strong>Answer:</strong> Create custom error pages by: 1) Adding error.html in templates directory for Thymeleaf or other view engines to handle all errors, 2) Creating specific pages like 404.html to handle specific error codes, 3) Implementing ErrorController interface, or 4) Using @ControllerAdvice with @ExceptionHandler methods returning custom error views. Spring Boot uses a sensible resolution algorithm to find the most specific match for an error scenario.</p>
<h3 id="105-what-are-conditional-annotations-in-spring-boot-and-how-do-they-work-">105. What are conditional annotations in Spring Boot and how do they work?</h3>
<p><strong>Answer:</strong> Conditional annotations control when beans are created based on conditions. Common annotations include @ConditionalOnClass (requires class on classpath), @ConditionalOnMissingBean (applies when no bean of type exists), @ConditionalOnProperty (checks property values), and @ConditionalOnExpression (SpEL expressions). Spring Boot uses these extensively in auto-configuration classes to create beans only when appropriate and avoid conflicts with user-defined beans.</p>
<h3 id="106-how-do-you-configure-connection-pooling-in-spring-boot-">106. How do you configure connection pooling in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot automatically configures connection pooling when it detects connection pool dependencies. By default, it uses HikariCP if available, then Tomcat pooling, and finally Commons DBCP2. Configure pool properties in application.properties/yml with spring.datasource.hikari.* properties (e.g., maximum-pool-size, connection-timeout). For specific needs, define a custom DataSource bean with desired pool implementation and configuration.</p>
<h3 id="107-what-is-the-difference-between-component-service-repository-and-controller-">107. What is the difference between @Component, @Service, @Repository, and @Controller?</h3>
<p><strong>Answer:</strong> All four are stereotype annotations marking classes as Spring-managed components, but with different semantics: @Component is a generic stereotype for any Spring-managed component; @Repository indicates a persistence layer bean with automatic exception translation; @Service marks service layer components with business logic; @Controller designates web controller beans handling HTTP requests. @Service, @Repository, and @Controller are specializations of @Component with identical runtime behavior but improved semantics.</p>
<h3 id="108-how-do-you-implement-scheduled-tasks-in-spring-boot-">108. How do you implement scheduled tasks in Spring Boot?</h3>
<p><strong>Answer:</strong> Enable scheduling with @EnableScheduling on a configuration class. Then create methods annotated with @Scheduled, specifying timing using fixedRate (milliseconds between starts), fixedDelay (milliseconds between end and next start), cron (cron expression), or initialDelay attributes. For example: @Scheduled(fixedRate=60000) for execution every minute or @Scheduled(cron=&quot;0 0 12 <em> </em> ?&quot;) for daily noon execution. Methods should return void and take no parameters.</p>
<h3 id="109-what-is-the-spring-boot-devtools-module-and-what-features-does-it-provide-">109. What is the Spring Boot DevTools module and what features does it provide?</h3>
<p><strong>Answer:</strong> Spring Boot DevTools is a set of tools that enhance development experience. Key features include automatic restart when classpath changes (reloads application when code is modified), live reload (automatically refreshes browser when resources change), global settings (DevTools properties shared across projects), and remote development support (update running applications remotely). DevTools is automatically disabled in production deployments to avoid performance impact.</p>
<h3 id="110-how-does-spring-boot-handle-json-serialization-and-deserialization-">110. How does Spring Boot handle JSON serialization and deserialization?</h3>
<p><strong>Answer:</strong> Spring Boot auto-configures Jackson for JSON processing when its on the classpath. It handles serialization (Java objects to JSON) and deserialization (JSON to Java objects) automatically for HTTP request/response bodies. Customize behavior with jackson.* properties or by providing Jackson2ObjectMapperBuilder bean. Common configurations include date formats, property inclusion rules, and serialization features. For alternative libraries, exclude Jackson and include Gson or JSON-B.</p>
<h3 id="111-what-is-spring-security-and-how-do-you-implement-it-in-spring-boot-">111. What is Spring Security and how do you implement it in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Security is a framework that provides authentication, authorization, and protection against common security vulnerabilities. Implement it in Spring Boot by adding the spring-boot-starter-security dependency, which auto-configures basic security with form login. Customize by creating a SecurityFilterChain bean with @Bean method in a @Configuration class that extends WebSecurityConfigurerAdapter or implements WebSecurityConfigurer, defining authentication providers, access rules, and security features.</p>
<h3 id="112-how-do-you-implement-jwt-authentication-in-spring-boot-">112. How do you implement JWT authentication in Spring Boot?</h3>
<p><strong>Answer:</strong> Implement JWT authentication by adding spring-security-jwt and jjwt dependencies, then configure a filter chain with JwtAuthenticationFilter to validate tokens. Create utility classes for token generation and validation. Configure SecurityFilterChain to use the JWT filter before UsernamePasswordAuthenticationFilter. Implement endpoints for token issuance upon successful login, and configure CORS and CSRF settings appropriately. Return tokens in Authentication responses for clients to store and include in subsequent requests.</p>
<h3 id="113-what-is-spring-aop-and-how-is-it-used-in-spring-boot-">113. What is Spring AOP and how is it used in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring AOP (Aspect-Oriented Programming) modularizes cross-cutting concerns like logging, security, and transactions. In Spring Boot, it&#39;s used through annotations like @Aspect, @Before, @After, and @Around. Define aspects as beans with @Component and @Aspect annotations, then define pointcuts (where to apply aspects) and advices (what to do). Spring Boot auto-configures AOP when spring-boot-starter-aop is added, enabling features like method execution monitoring and cross-cutting functionality.</p>
<h3 id="114-how-do-you-handle-database-transactions-in-spring-boot-">114. How do you handle database transactions in Spring Boot?</h3>
<p><strong>Answer:</strong> Handle transactions declaratively with @Transactional annotation on service methods or classes. Spring Boot auto-configures a transaction manager when it detects a supported database dependency. Configure transaction attributes like propagation (REQUIRED, REQUIRES_NEW), isolation levels (READ_COMMITTED, SERIALIZABLE), timeout, and rollback rules. For example: @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class) ensures transaction integrity with specific behavior.</p>
<h3 id="115-what-are-spring-boot-starters-for-testing-and-what-do-they-provide-">115. What are Spring Boot Starters for testing and what do they provide?</h3>
<p><strong>Answer:</strong> Spring Boot Starter Test (spring-boot-starter-test) includes tools for unit and integration testing: JUnit (test framework), Spring Test &amp; Spring Boot Test (testing utilities), AssertJ (assertions), Hamcrest (matchers), Mockito (mocking), JSONassert (JSON assertions), and JsonPath (JSON parsing). It provides annotations like @SpringBootTest for integration tests, @WebMvcTest for controller tests, @DataJpaTest for repository tests, and @MockBean for mocking dependencies, streamlining test setup.</p>
<h3 id="116-how-do-you-implement-internationalization-i18n-in-spring-boot-">116. How do you implement internationalization (i18n) in Spring Boot?</h3>
<p><strong>Answer:</strong> Implement internationalization by configuring MessageSource bean (auto-configured by Spring Boot) and placing message files (messages.properties, messages_fr.properties, etc.) in the resources folder. Use @Configuration to customize the base name and encoding if needed. In templates, access messages with Spring&#39;s message tags or ThymeleafMessageSource. Handle locale changes with LocaleResolver (e.g., SessionLocaleResolver) and LocaleChangeInterceptor. Access messages programmatically with the autowired MessageSource.</p>
<h3 id="117-what-is-spring-webflux-and-how-does-it-differ-from-spring-mvc-">117. What is Spring WebFlux and how does it differ from Spring MVC?</h3>
<p><strong>Answer:</strong> Spring WebFlux is a reactive-stack web framework that handles high concurrency with fewer threads using non-blocking I/O. Unlike Spring MVC&#39;s servlet-based, thread-per-request model, WebFlux uses event loops with Reactor&#39;s Mono/Flux types. WebFlux supports both annotated controllers similar to MVC and functional programming style with RouterFunctions. Choose WebFlux for applications requiring high throughput and scalability with limited resources, or when using reactive libraries is beneficial.</p>
<h3 id="118-how-do-you-implement-method-level-security-in-spring-boot-">118. How do you implement method-level security in Spring Boot?</h3>
<p><strong>Answer:</strong> Enable method-level security with @EnableMethodSecurity (or @EnableGlobalMethodSecurity in older versions). Then secure methods with annotations: @Secured(&quot;ROLE_ADMIN&quot;), @PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;), or @PostAuthorize(&quot;returnObject.owner == authentication.name&quot;). For fine-grained control, use SpEL expressions in @PreAuthorize like &quot;@userRepository.findById(#id).orElse(null)?.owner == authentication.name&quot;. Method security is evaluated at runtime, preventing unauthorized access to business methods regardless of entry point.</p>
<h3 id="119-what-are-the-options-for-caching-in-spring-boot-">119. What are the options for caching in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot supports caching through the @EnableCaching annotation and cache abstractions. Configure providers like Caffeine (in-memory), Redis, Hazelcast, or EhCache by adding their dependencies. Use @Cacheable to cache method results, @CacheEvict to remove entries, and @CachePut to update cache without affecting method execution. Configure cache properties in application.properties with spring.cache.* properties. For distributed applications, use Redis or Hazelcast for synchronized caching across instances.</p>
<h3 id="120-how-do-you-implement-global-exception-handling-in-spring-boot-">120. How do you implement global exception handling in Spring Boot?</h3>
<p><strong>Answer:</strong> Implement global exception handling with a @ControllerAdvice or @RestControllerAdvice class containing @ExceptionHandler methods. These handle exceptions across all controllers, returning appropriate responses: @ExceptionHandler(UserNotFoundException.class) public ResponseEntity<ErrorResponse> handleUserNotFound(). Create custom exception classes for different error scenarios. Configure default error attributes with ErrorAttributes bean. For REST APIs, return consistent error structures with proper HTTP status codes and meaningful messages.</p>
<h3 id="121-what-is-spring-cloud-and-how-does-it-relate-to-spring-boot-">121. What is Spring Cloud and how does it relate to Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Cloud is a framework that provides tools for building cloud-native applications, especially distributed systems and microservices. It builds on top of Spring Boot, adding features for service discovery (Eureka), configuration management (Config Server), circuit breaking (Resilience4j, previously Hystrix), API gateway (Gateway, previously Zuul), distributed tracing (Sleuth), and more. While Spring Boot focuses on standalone application development, Spring Cloud adds coordination and resilience patterns for multi-service architectures.</p>
<h3 id="122-what-is-spring-cloud-config-and-why-is-it-useful-">122. What is Spring Cloud Config and why is it useful?</h3>
<p><strong>Answer:</strong> Spring Cloud Config provides externalized configuration for distributed systems. It stores configuration in a central Git repository and serves it to applications via REST API. Client applications use spring-cloud-starter-config to fetch configuration on startup and can reload it without restart using refresh endpoints. This enables managing configuration across multiple environments and services from a single location, supporting versioning, auditing, and environment-specific settings.</p>
<h3 id="123-how-does-service-discovery-work-in-spring-cloud-">123. How does service discovery work in Spring Cloud?</h3>
<p><strong>Answer:</strong> Service discovery in Spring Cloud typically uses Netflix Eureka. Service instances register themselves with the Eureka server on startup (using spring-cloud-starter-netflix-eureka-client). Client applications discover services by name rather than hardcoded URLs, using either @LoadBalanced RestTemplate or declarative Feign clients. This enables dynamic scaling, resilience to instance failures, and environment portability since service locations are resolved at runtime.</p>
<h3 id="124-what-is-spring-cloud-gateway-and-how-does-it-work-">124. What is Spring Cloud Gateway and how does it work?</h3>
<p><strong>Answer:</strong> Spring Cloud Gateway is an API gateway built on Spring WebFlux, providing routing, filtering, and cross-cutting concerns like security and monitoring for microservices. It receives client requests, routes them to appropriate services based on configurable predicates, and applies filters before/after forwarding. Gateway supports dynamic routing, load balancing via service discovery integration, circuit breaking, rate limiting, and request transformation, acting as a single entry point to the system.</p>
<h3 id="125-how-do-you-implement-circuit-breaking-in-spring-cloud-">125. How do you implement circuit breaking in Spring Cloud?</h3>
<p><strong>Answer:</strong> Implement circuit breaking using Spring Cloud Circuit Breaker with providers like Resilience4j (recommended) or Netflix Hystrix. Add appropriate dependency (spring-cloud-starter-circuitbreaker-resilience4j) and annotate methods with @CircuitBreaker, configuring parameters like failureThreshold, waitDurationInOpenState, and slidingWindowSize. Define fallback methods for graceful degradation when downstream services fail. This prevents cascading failures by failing fast when a service is unavailable.</p>
<h3 id="126-what-is-the-purpose-of-spring-cloud-sleuth-">126. What is the purpose of Spring Cloud Sleuth?</h3>
<p><strong>Answer:</strong> Spring Cloud Sleuth implements distributed tracing for microservices by adding trace and span IDs to service calls. It automatically instruments communication channels (REST calls, message brokers) to propagate trace context between services. When combined with Zipkin or Jaeger, it provides visualization of request flows through multiple services, helping identify bottlenecks and troubleshoot issues in distributed systems. Trace IDs also appear in logs, correlating log entries across services.</p>
<h3 id="127-how-do-you-implement-oauth2-security-in-spring-boot-applications-">127. How do you implement OAuth2 security in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Implement OAuth2 with spring-boot-starter-oauth2-client for clients or spring-boot-starter-oauth2-resource-server for resource servers. Configure properties like spring.security.oauth2.client.registration.<em> for client registration or spring.security.oauth2.resourceserver.jwt.</em> for JWT validation. Use annotations like @EnableWebSecurity and configure SecurityFilterChain bean with OAuth2 authentication. For client applications, use OAuth2AuthorizedClientService to access tokens; for resource servers, configure JWT converter and authorities mapping.</p>
<h3 id="128-what-are-spring-cloud-streams-and-how-are-they-used-">128. What are Spring Cloud Streams and how are they used?</h3>
<p><strong>Answer:</strong> Spring Cloud Stream is a framework for building message-driven microservices that abstract messaging systems like Kafka and RabbitMQ. Define interfaces with @Input and @Output annotations or use functional programming model with Consumer/Supplier interfaces. The binder implementation (Kafka, RabbitMQ) is selected via dependencies, allowing messaging infrastructure to change without code changes. It supports content-type negotiation, partitioning, error handling, and consumer groups for scalable event processing.</p>
<h3 id="129-how-do-you-handle-distributed-sessions-in-spring-boot-">129. How do you handle distributed sessions in Spring Boot?</h3>
<p><strong>Answer:</strong> Handle distributed sessions using Spring Session, which provides transparent integration with various session backends. Add dependencies like spring-session-jdbc, spring-session-redis, or spring-session-data-mongodb based on your store preference. Configure session repository type with spring.session.store-type property. Spring Session replaces the application container&#39;s HttpSession implementation, storing session data in the chosen backend and making it available across multiple application instances.</p>
<h3 id="130-what-is-the-difference-between-imperative-and-reactive-programming-in-spring-">130. What is the difference between imperative and reactive programming in Spring?</h3>
<p><strong>Answer:</strong> Imperative programming in Spring (Spring MVC) follows a thread-per-request model with synchronous, blocking operations using servlets. Reactive programming (Spring WebFlux) uses event loops with non-blocking I/O, handling more requests with fewer threads using reactive streams (Mono/Flux types). Imperative is simpler and more familiar but can waste resources waiting for I/O. Reactive offers better resource utilization for I/O-intensive applications but has a steeper learning curve and requires reactive libraries throughout the stack.</p>
<h3 id="131-what-is-springboottest-annotation-and-how-is-it-used-">131. What is @SpringBootTest annotation and how is it used?</h3>
<p><strong>Answer:</strong> @SpringBootTest is a primary annotation for integration testing in Spring Boot. It creates an ApplicationContext with full auto-configuration, scanning, and web environment if needed. Configure it with properties like webEnvironment (MOCK, RANDOM_PORT, DEFINED_PORT, NONE) to control server startup behavior. Use with TestRestTemplate or WebTestClient for end-to-end testing, and @MockBean to replace beans with mocks. @SpringBootTest loads the complete application context, so it&#39;s slower but more comprehensive than sliced tests.</p>
<h3 id="132-what-are-sliced-tests-in-spring-boot-">132. What are sliced tests in Spring Boot?</h3>
<p><strong>Answer:</strong> Sliced tests in Spring Boot load only a specific &quot;slice&quot; of the application context, making tests faster and more focused. Common slice annotations include @WebMvcTest (web layer only), @DataJpaTest (repository layer only), @JsonTest (JSON serialization), @RestClientTest (REST clients), and @WebFluxTest (reactive controllers). Each slice loads only relevant auto-configuration and beans, reducing startup time. Use MockMvc, TestEntityManager, or other test-specific utilities provided by each slice.</p>
<h3 id="133-how-do-you-test-spring-boot-rest-controllers-">133. How do you test Spring Boot REST controllers?</h3>
<p><strong>Answer:</strong> Test REST controllers with @WebMvcTest for focused controller tests or @SpringBootTest for full integration tests. With @WebMvcTest, use MockMvc to simulate HTTP requests: mockMvc.perform(get(&quot;/api/users&quot;)).andExpect(status().isOk()). @MockBean services and repositories that controllers depend on. For @SpringBootTest with a real server, use TestRestTemplate or WebTestClient to make actual HTTP requests to the application. Verify responses using JSONPath or direct object assertions.</p>
<h3 id="134-what-is-the-testresttemplate-in-spring-boot-">134. What is the TestRestTemplate in Spring Boot?</h3>
<p><strong>Answer:</strong> TestRestTemplate is a convenience alternative to RestTemplate for integration testing. It&#39;s automatically configured with @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) and can make actual HTTP requests to the running application. It supports basic authentication, cookies, and automatic port resolution. Unlike MockMvc, TestRestTemplate performs real HTTP calls, testing the full request-response cycle including serialization, making it suitable for end-to-end testing.</p>
<h3 id="135-how-do-you-test-jpa-repositories-in-spring-boot-">135. How do you test JPA repositories in Spring Boot?</h3>
<p><strong>Answer:</strong> Test JPA repositories with @DataJpaTest, which configures in-memory database, sets up test transaction management, and disables full auto-configuration. Use TestEntityManager for JPA operations outside the repository being tested. For example:</p>
<pre><code class="lang-java"><span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> UserRepository userRepository;
<span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> TestEntityManager entityManager;
<span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findByEmail</span><span class="hljs-params">()</span> </span>{
    User saved = entityManager.persist(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"test@example.com"</span>));
    User found = userRepository.findByEmail(<span class="hljs-string">"test@example.com"</span>);
    assertEquals(saved.getId(), found.getId());
}
</code></pre>
<p>Tests automatically rollback, avoiding test pollution.</p>
<h3 id="136-how-do-you-deploy-spring-boot-applications-">136. How do you deploy Spring Boot applications?</h3>
<p><strong>Answer:</strong> Deploy Spring Boot applications as: 1) Standalone JARs with embedded server using <code>java -jar app.jar</code> (most common), 2) Traditional WARs in external servers by extending SpringBootServletInitializer, 3) Docker containers using Dockerfile or Cloud Native Buildpacks (<code>./mvnw spring-boot:build-image</code>), 4) Cloud platforms like AWS Elastic Beanstalk, Heroku, or Azure App Service using platform-specific deployment processes, or 5) Kubernetes using container images and deployment manifests. Use profiles and externalized configuration to adapt to different environments.</p>
<h3 id="137-what-are-the-options-for-hot-reloading-in-spring-boot-">137. What are the options for hot reloading in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot supports hot reloading via: 1) DevTools (automatic restarts when classpath changes), 2) LiveReload (browser refresh when resources change), 3) JRebel (commercial tool for class reloading without restart), 4) Spring Boot Developer Tools integration with IDEs for IDE-triggered restarts. DevTools is most common, detecting changes and performing &quot;smart&quot; restarts that are faster than full restarts. For more advanced scenarios like changing method signatures, JRebel provides true hot swapping capabilities.</p>
<h3 id="138-what-is-spring-boot-actuator-health-check-and-how-do-you-customize-it-">138. What is Spring Boot Actuator health check and how do you customize it?</h3>
<p><strong>Answer:</strong> Spring Boot Actuator health check (/actuator/health) provides application health status information used for monitoring and kubernetes liveness/readiness probes. Customize it by: 1) Creating custom HealthIndicator beans to check external dependencies, 2) Configuring management.endpoint.health.show-details and show-components properties to control information exposure, 3) Adding health groups with management.endpoint.health.group.* properties for separate liveness/readiness checks, and 4) Setting status mappings to translate specific health states into appropriate HTTP status codes.</p>
<h3 id="139-how-do-you-implement-logging-in-spring-boot-applications-">139. How do you implement logging in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Spring Boot uses Commons Logging API with default implementations: Logback in standalone applications or Log4j2/JUL when using the respective dependencies. Configure logging levels in application.properties (logging.level.org.springframework=DEBUG) or with type-specific configurations in logback-spring.xml, log4j2-spring.xml, or logging.properties. Use SLF4J facades in code: <code>private static final Logger log = LoggerFactory.getLogger(MyClass.class);</code>. Spring Boot Actuator provides the /loggers endpoint to view and change log levels at runtime.</p>
<h3 id="140-how-do-you-secure-endpoints-in-a-spring-boot-application-">140. How do you secure endpoints in a Spring Boot application?</h3>
<p><strong>Answer:</strong> Secure endpoints by adding spring-boot-starter-security and implementing configuration: 1) Create WebSecurityConfig with SecurityFilterChain bean to define security rules, 2) Use HttpSecurity to configure authentication (HTTP Basic, form, OAuth2, etc.), authorization (URL patterns, roles, expressions), CSRF protection, and session management, 3) Configure AuthenticationManager with user details source (in-memory, JDBC, LDAP, custom), and 4) Add method security with @EnableMethodSecurity. For specific endpoints, use antMatchers().permitAll() for public access or specific role requirements for protected resources.</p>
<h3 id="141-what-is-thymeleaf-and-how-does-it-integrate-with-spring-boot-">141. What is Thymeleaf and how does it integrate with Spring Boot?</h3>
<p><strong>Answer:</strong> Thymeleaf is a server-side Java template engine that produces HTML, XML, and text. It integrates with Spring Boot through the spring-boot-starter-thymeleaf dependency, which auto-configures ThymeleafViewResolver and templates location. Thymeleaf templates use natural templating (valid HTML) with th:* attributes for dynamic content: th:text for escaped output, th:each for iteration, th:if/unless for conditionals. Spring&#39;s model attributes are accessible directly in templates, and Spring Security integration provides access to authentication details.</p>
<h3 id="142-what-are-the-key-features-of-thymeleaf-">142. What are the key features of Thymeleaf?</h3>
<p><strong>Answer:</strong> Key Thymeleaf features include: 1) Natural templates that work as static prototypes in browsers, 2) Spring integration with access to beans, request attributes, and form binding, 3) Layout dialects for template inheritance and fragments, 4) Expression syntax with variable expressions ${...}, selection expressions *{...}, message expressions #{...}, and link expressions @{...}, 5) Built-in Spring Security integration, 6) Extensibility through custom dialects, and 7) Fragment inclusion and parameterization for component-based development.</p>
<h3 id="143-how-do-you-handle-forms-with-thymeleaf-in-spring-boot-">143. How do you handle forms with Thymeleaf in Spring Boot?</h3>
<p><strong>Answer:</strong> Handle forms in Thymeleaf with Spring Boot by: 1) Creating a model object in the controller to back the form, 2) Using th:object to bind the form to the model, 3) Using th:field for input elements to bind to specific properties (handles IDs, names, and values), 4) Implementing a controller method with @PostMapping to receive the submitted form, 5) Using @Valid and BindingResult for validation, and 6) Displaying error messages with th:errors or field-specific errors with th:errorclass and th:field.</p>
<h3 id="144-what-is-the-difference-between-th-text-and-th-utext-in-thymeleaf-">144. What is the difference between th:text and th:utext in Thymeleaf?</h3>
<p><strong>Answer:</strong> The difference is in how they handle HTML content: th:text escapes HTML special characters, converting them to their entity equivalents (e.g., &lt; becomes &lt;), which prevents cross-site scripting (XSS) attacks. th:utext (unescaped text) outputs the raw HTML without escaping, allowing HTML tags to render as actual elements. Always use th:text (the safer option) by default, and only use th:utext when you explicitly need to render HTML from a trusted source.</p>
<h3 id="145-how-do-you-implement-internationalization-in-thymeleaf-templates-">145. How do you implement internationalization in Thymeleaf templates?</h3>
<p><strong>Answer:</strong> Implement internationalization in Thymeleaf using: 1) Message properties files (messages.properties, messages_fr.properties) in the resources directory, 2) Configure MessageSource bean (auto-configured by Spring Boot), 3) Use #{message.key} syntax in templates to reference messages, 4) Pass parameters with #{message.key(${parameter})}, 5) Configure LocaleResolver bean (e.g., SessionLocaleResolver) and LocaleChangeInterceptor to handle locale changes, and 6) Create language selector with links that include the locale parameter.</p>
<h3 id="146-how-do-you-include-fragments-in-thymeleaf-templates-">146. How do you include fragments in Thymeleaf templates?</h3>
<p><strong>Answer:</strong> Include fragments in Thymeleaf using: 1) Define fragments with th:fragment in source templates: <div th:fragment="header">Header content</div>, 2) Include fragments with th:insert, th:replace, or th:include: <div th:replace="fragments/header :: header"></div>, 3) Pass parameters to fragments: th:replace=&quot;fragments/header :: header(title=&#39;Home&#39;)&quot;, 4) Create parametrized fragments with th:fragment=&quot;header(title)&quot;. The difference between insert/replace/include is that insert adds the fragment inside the host tag, replace replaces the host tag, and include inserts only the contents.</p>
<h3 id="147-how-do-you-handle-static-resources-in-spring-boot-with-thymeleaf-">147. How do you handle static resources in Spring Boot with Thymeleaf?</h3>
<p><strong>Answer:</strong> Handle static resources by placing them in the /static, /public, /resources, or /META-INF/resources directories in the classpath. These are automatically served at the root path. Reference them in Thymeleaf using @{} link expressions: <link rel="stylesheet" th:href="@{/css/main.css}">. Spring Boot auto-configures resource handlers and adds version hashes for cache busting with ResourceUrlEncodingFilter. For custom configuration, create a WebMvcConfigurer bean and override addResourceHandlers() method.</p>
<h3 id="148-what-is-thymeleaf-layout-dialect-and-how-is-it-used-">148. What is Thymeleaf Layout Dialect and how is it used?</h3>
<p><strong>Answer:</strong> Thymeleaf Layout Dialect is an extension that provides layout/template inheritance similar to Tiles or SiteMesh. Add the dependency thymeleaf-layout-dialect (auto-configured by Spring Boot). Create a layout template with content placeholders: <div layout:fragment="content">Default content</div>, then create content templates that reference the layout: <html layout:decorate="~{layouts/main}"> and define fragments: <div layout:fragment="content">Actual content</div>. This enables consistent page structure with reusable components.</p>
<h3 id="149-how-do-you-access-spring-security-information-in-thymeleaf-templates-">149. How do you access Spring Security information in Thymeleaf templates?</h3>
<p><strong>Answer:</strong> Access Spring Security information in Thymeleaf using the sec: namespace (automatically available with thymeleaf-extras-springsecurity5): 1) Check authentication status: <div sec:authorize="isAuthenticated()">, 2) Display user information: <span sec:authentication="name">, 3) Check roles: <div sec:authorize="hasRole('ADMIN')"> or <div th:if="${#authorization.expression('hasRole(''ADMIN'')')}">, 4) Access principal object: <span th:text="${#authentication.principal.username}">. These features provide conditional rendering based on security context.</p>
    <h3 id="150-how-do-you-validate-form-input-in-thymeleaf-and-spring-boot-">150. How do you validate form input in Thymeleaf and Spring Boot?</h3>
<p><strong>Answer:</strong> Validate form input by: 1) Adding validation annotations (@NotNull, @Size, @Email) to model class fields, 2) Adding spring-boot-starter-validation dependency, 3) Using @Valid annotation on the @ModelAttribute parameter in controller methods, 4) Adding BindingResult parameter immediately after the model parameter to capture errors, 5) Checking hasErrors() before processing valid data, 6) Displaying errors in templates with th:errors=&quot;*{fieldName}&quot; or th:if=&quot;${#fields.hasErrors(&#39;fieldName&#39;)}&quot;, and 7) Adding CSS classes conditionally based on validation state with th:errorclass.</p>
<h3 id="151-what-is-a-microservice-architecture-and-how-does-spring-boot-support-it-">151. What is a microservice architecture and how does Spring Boot support it?</h3>
<p><strong>Answer:</strong> Microservice architecture is an approach where applications are built as small, independent services that communicate over a network. Spring Boot supports microservices by providing a lightweight framework for creating standalone services with embedded servers, auto-configuration, health monitoring, and externalized configuration. Its fast startup and low resource consumption make it ideal for containerized environments. Spring Boot integrates with Spring Cloud to add service discovery, distributed configuration, circuit breaking, and API gateway patterns crucial for microservice ecosystems.</p>
<h3 id="152-what-is-spring-cloud-loadbalancer-and-how-does-it-work-">152. What is Spring Cloud LoadBalancer and how does it work?</h3>
<p><strong>Answer:</strong> Spring Cloud LoadBalancer is a client-side load balancing solution that distributes requests across multiple service instances. It replaces Netflix Ribbon in newer Spring Cloud versions. LoadBalancer integrates with service discovery tools (like Eureka) to obtain available instances. Configure it by adding the spring-cloud-starter-loadbalancer dependency and using @LoadBalanced on RestTemplate or WebClient beans. It supports various algorithms (round-robin by default) and custom filters for advanced routing strategies.</p>
<h3 id="153-how-do-you-implement-feign-clients-in-spring-boot-">153. How do you implement Feign clients in Spring Boot?</h3>
<p><strong>Answer:</strong> Implement Feign clients by adding spring-cloud-starter-openfeign dependency and enabling with @EnableFeignClients annotation. Create interface declarations with @FeignClient annotation specifying service name and optional URL. Define methods corresponding to REST endpoints using Spring MVC annotations (@GetMapping, etc.):</p>
<pre><code class="lang-java"><span class="hljs-variable">@FeignClient</span>(name = <span class="hljs-string">"user-service"</span>)
public interface UserClient {
    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"/users/{id}"</span>)
    User getUser(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">"id"</span>) Long id);
}
</code></pre>
<p>Inject and use clients like any other Spring bean. Feign handles HTTP requests, encoding/decoding, and error handling automatically.</p>
<h3 id="154-how-does-spring-cloud-config-handle-secrets-and-sensitive-information-">154. How does Spring Cloud Config handle secrets and sensitive information?</h3>
<p><strong>Answer:</strong> Spring Cloud Config handles secrets through several mechanisms: 1) Environment-specific encryption/decryption with symmetric or asymmetric keys - encrypted values are prefixed with {cipher}, 2) Integration with vault systems like HashiCorp Vault, 3) Separating sensitive configs into different repositories with restricted access, 4) Property overriding from environment variables or system properties. Best practice is to encrypt sensitive values in the config repository and control the encryption keys separately, or use a dedicated secrets manager with Spring Cloud Vault.</p>
<h3 id="155-what-is-the-circuit-breaker-pattern-and-how-is-it-implemented-in-spring-cloud-">155. What is the Circuit Breaker pattern and how is it implemented in Spring Cloud?</h3>
<p><strong>Answer:</strong> The Circuit Breaker pattern prevents cascading failures by failing fast when a service is unavailable. Spring Cloud implements this with Resilience4j (replacing older Hystrix). Configure by adding spring-cloud-starter-circuitbreaker-resilience4j and applying @CircuitBreaker to methods calling external services:</p>
<pre><code class="lang-java"><span class="hljs-meta">@CircuitBreaker(name = <span class="hljs-meta-string">"userService"</span>, fallbackMethod = <span class="hljs-meta-string">"getUserFallback"</span>)</span>
<span class="hljs-keyword">public</span> User getUser(<span class="hljs-built_in">Long</span> id) {
    <span class="hljs-keyword">return</span> userClient.getUser(id);
}

<span class="hljs-keyword">public</span> User getUserFallback(<span class="hljs-built_in">Long</span> id, Exception ex) {
    <span class="hljs-keyword">return</span> new User(id, <span class="hljs-string">"Default user"</span>);
}
</code></pre>
<p>Circuits open after failures exceed thresholds, sending requests to fallback methods to prevent system overload.</p>
<h3 id="156-how-do-you-implement-distributed-tracing-in-spring-cloud-">156. How do you implement distributed tracing in Spring Cloud?</h3>
<p><strong>Answer:</strong> Implement distributed tracing with Spring Cloud Sleuth and Zipkin. Add spring-cloud-starter-sleuth and spring-cloud-sleuth-zipkin dependencies. Sleuth automatically adds trace and span IDs to requests flowing through RestTemplate, WebClient, and messaging channels. Configure Zipkin server connection with spring.zipkin.baseUrl. Trace IDs appear in logs correlating requests across services. The Zipkin web interface displays trace timelines, showing latency for each service in the call chain. For OpenTelemetry support, use the Micrometer Tracing starter in newer Spring Boot versions.</p>
<h3 id="157-what-is-spring-cloud-stream-and-how-does-it-support-event-driven-architectures-">157. What is Spring Cloud Stream and how does it support event-driven architectures?</h3>
<p><strong>Answer:</strong> Spring Cloud Stream is a framework for building event-driven microservices using message brokers like RabbitMQ and Kafka. It provides an abstraction layer over messaging systems with a publish-subscribe model. Define interfaces with @Input/@Output annotations or functional interfaces (Consumer/Supplier). Configure with spring.cloud.stream properties to define bindings, consumer groups, partitioning, and content types. Spring Cloud Stream handles serialization/deserialization, enabling service decoupling and event processing patterns without broker-specific code.</p>
<h3 id="158-how-does-spring-cloud-gateway-handle-cross-cutting-concerns-in-a-microservice-architecture-">158. How does Spring Cloud Gateway handle cross-cutting concerns in a microservice architecture?</h3>
<p><strong>Answer:</strong> Spring Cloud Gateway handles cross-cutting concerns through its filter architecture. Global filters apply to all routes, while GatewayFilter instances apply to specific routes. Common implementations include: 1) Authentication/authorization filters, 2) Rate limiting to prevent abuse, 3) Request/response modification, 4) CORS configuration, 5) Circuit breaking for downstream services, 6) Request logging and metrics collection, 7) Header modification for token relay or content negotiation. Filters can be configured in application.yml or programmatically, enabling consistent policy enforcement across all services.</p>
<h3 id="159-what-is-the-difference-between-spring-cloud-config-and-configuration-in-kubernetes-">159. What is the difference between Spring Cloud Config and configuration in Kubernetes?</h3>
<p><strong>Answer:</strong> Spring Cloud Config provides a centralized, versioned configuration server with environment segregation, dynamic updates, and encryption. Kubernetes ConfigMaps/Secrets offer platform-native configuration tied to the deployment environment with automatic updates when mounted as volumes. Spring Cloud Config excels with complex configurations, multiple environments, and audit trails, while Kubernetes config is simpler with tight container integration. Many teams use both: Kubernetes for operational parameters and Spring Cloud Config for application-specific configuration with Spring Cloud Kubernetes bridging the gap.</p>
<h3 id="160-how-do-you-implement-resilience-patterns-beyond-circuit-breaking-in-spring-cloud-">160. How do you implement resilience patterns beyond circuit breaking in Spring Cloud?</h3>
<p><strong>Answer:</strong> Implement additional resilience patterns with Spring Cloud Resilience4j: 1) Retry: @Retry annotation for automatic retries with backoff, 2) Bulkhead: @Bulkhead to limit concurrent calls preventing resource exhaustion, 3) RateLimiter: @RateLimiter to control requests per period, 4) TimeLimiter: @TimeLimiter for timeouts on slow responses, 5) Cache: @CachingBulkhead to serve cached responses during failures. Combine patterns for comprehensive resilience strategy. Configure parameters via application.yml under resilience4j namespace. These patterns work together to build systems that degrade gracefully under stress.</p>
<h3 id="161-what-are-the-different-types-of-database-relationships-in-jpa-and-how-do-you-implement-them-">161. What are the different types of database relationships in JPA and how do you implement them?</h3>
<p><strong>Answer:</strong> JPA supports four relationship types: 1) @OneToOne (user-profile), 2) @OneToMany/@ManyToOne (department-employees), 3) @ManyToMany (students-courses), and 4) Unidirectional/bidirectional variants of each. Implement one-to-one with @OneToOne on both sides and mappedBy on non-owning side. One-to-many uses @OneToMany(mappedBy=&quot;parent&quot;) on parent and @ManyToOne on child with @JoinColumn. Many-to-many requires @JoinTable with joinColumns and inverseJoinColumns attributes. Use cascade attributes to control related entity persistence operations and fetch=FetchType.LAZY for performance.</p>
<h3 id="162-how-do-you-optimize-jpa-hibernate-performance-in-a-spring-boot-application-">162. How do you optimize JPA/Hibernate performance in a Spring Boot application?</h3>
<p><strong>Answer:</strong> Optimize JPA/Hibernate performance by: 1) Using appropriate fetch types (LAZY for collections), 2) Implementing batch processing with hibernate.jdbc.batch_size, 3) Configuring second-level caching for read-heavy entities, 4) Creating database indexes for frequently queried columns, 5) Using pagination for large result sets, 6) Writing native queries for complex operations, 7) Avoiding N+1 problems with JOIN FETCH or EntityGraph, 8) Enabling query statistics with spring.jpa.properties.hibernate.generate_statistics=true to identify bottlenecks, and 9) Using DTO projections for read operations that don&#39;t need full entities.</p>
<h3 id="163-what-is-the-difference-between-identity-sequence-table-and-auto-generation-strategies-in-jpa-">163. What is the difference between IDENTITY, SEQUENCE, TABLE, and AUTO generation strategies in JPA?</h3>
<p><strong>Answer:</strong> ID generation strategies in JPA: IDENTITY delegates to database auto-increment columns (simple but prevents JDBC batching); SEQUENCE uses database sequences offering better performance with batching; TABLE simulates sequences using a separate table (database-agnostic but slower); AUTO lets JPA provider choose the appropriate strategy based on database (default). Choose IDENTITY for simplicity, SEQUENCE for performance with batch operations on supported databases (Oracle, PostgreSQL), TABLE for database portability, or specify explicitly rather than using AUTO for predictable behavior.</p>
<h3 id="164-how-do-you-implement-database-migrations-in-spring-boot-applications-">164. How do you implement database migrations in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Implement database migrations using Flyway or Liquibase. For Flyway, add spring-boot-starter-flyway dependency and place SQL scripts in resources/db/migration with naming pattern V1__Description.sql. For Liquibase, add spring-boot-starter-liquibase and define changesets in resources/db/changelog/db.changelog-master.yaml or XML format. Both tools track which migrations have been applied using metadata tables, automatically apply pending migrations during startup, and support callbacks, versioning, and rollback capabilities for safe, repeatable database evolution.</p>
<h3 id="165-what-is-the-difference-between-spring-jpa-hibernate-ddl-auto-and-database-migration-tools-">165. What is the difference between spring.jpa.hibernate.ddl-auto and database migration tools?</h3>
<p><strong>Answer:</strong> spring.jpa.hibernate.ddl-auto automatically generates DDL from entity annotations at runtime with options like create, create-drop, update, validate, or none. It&#39;s convenient for development but unsafe for production as it can cause data loss. Database migration tools (Flyway/Liquibase) use explicit, version-controlled scripts defining exact schema changes. They maintain migration history, support rollbacks, and work across environments predictably. Best practice: use ddl-auto=validate in production to verify schema matches entities, but rely on migration tools for actual schema changes.</p>
<h3 id="166-how-do-you-implement-database-transactions-across-multiple-services-in-a-microservice-architecture-">166. How do you implement database transactions across multiple services in a microservice architecture?</h3>
<p><strong>Answer:</strong> Implement distributed transactions using: 1) Saga pattern with compensating transactions coordinated via events, 2) Two-phase commit with a transaction manager (rarely used due to performance/availability issues), 3) Eventually consistent approach with event-driven compensation, or 4) Domain events with idempotent operations. Spring provides @TransactionalEventListener for coordinating with messaging systems. In practice, most microservice architectures favor eventual consistency with careful domain design over strict ACID transactions, using techniques like event sourcing or the outbox pattern.</p>
<h3 id="167-what-is-the-difference-between-crudrepository-pagingandsortingrepository-and-jparepository-in-spring-data-">167. What is the difference between CrudRepository, PagingAndSortingRepository, and JpaRepository in Spring Data?</h3>
<p><strong>Answer:</strong> CrudRepository provides basic CRUD operations (save, findById, delete); PagingAndSortingRepository extends it adding pagination and sorting capabilities with findAll(Pageable) methods; JpaRepository extends both adding JPA-specific features like flushing, batch operations, and returning List instead of Iterable. Each interface adds functionality over its parent: choose CrudRepository for minimal dependencies, PagingAndSortingRepository when pagination is needed, or JpaRepository (most common) for full JPA functionality. Spring Data allows selecting the appropriate abstraction level for your requirements.</p>
<h3 id="168-how-do-you-handle-database-connection-pooling-in-spring-boot-">168. How do you handle database connection pooling in Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Boot automatically configures connection pooling using HikariCP (default), Tomcat JDBC, or Commons DBCP2 based on classpath dependencies. Configure pool properties in application.properties/yml with spring.datasource.hikari.* prefixes (e.g., maximum-pool-size, connection-timeout, idle-timeout). Monitor pool metrics through JMX or Actuator&#39;s metrics endpoint. For custom configuration, define your own DataSource bean. HikariCP is recommended for its performance and minimal overhead; typical configurations include 5-10 connections for small applications and proper timeout settings.</p>
<h3 id="169-what-is-the-n-1-query-problem-and-how-do-you-solve-it-in-jpa-hibernate-">169. What is the N+1 query problem and how do you solve it in JPA/Hibernate?</h3>
<p><strong>Answer:</strong> The N+1 query problem occurs when accessing a collection of N entities requires N+1 database queries (1 for parent list, N for each child collection). Solve it using: 1) JOIN FETCH in JPQL queries (@Query(&quot;SELECT u FROM User u JOIN FETCH u.roles&quot;)), 2) EntityGraph API (@EntityGraph(attributePaths = {&quot;roles&quot;})), 3) Batch fetching with @BatchSize(size=25) on collection fields, or 4) Using DTO projections that fetch only required data in a single query. Monitoring SQL logs during development helps identify and fix N+1 issues before they impact production performance.</p>
<h3 id="170-how-do-you-optimize-mysql-queries-and-database-schema-for-spring-boot-applications-">170. How do you optimize MySQL queries and database schema for Spring Boot applications?</h3>
<p><strong>Answer:</strong> Optimize MySQL for Spring Boot by: 1) Creating appropriate indexes on frequently queried columns and foreign keys, 2) Using EXPLAIN to analyze query execution plans, 3) Normalizing schema appropriately while avoiding excessive joins, 4) Choosing correct data types (e.g., VARCHAR instead of TEXT for short strings), 5) Setting proper character sets and collations (utf8mb4_unicode_ci), 6) Configuring InnoDB settings for your workload, 7) Using native queries for complex operations, and 8) Implementing database-specific optimizations via spring.jpa.properties.hibernate.dialect_storage_engine=innodb. Regular monitoring of slow queries helps identify opportunities for optimization.</p>
<h3 id="171-what-are-the-solid-principles-and-how-do-they-apply-to-spring-boot-applications-">171. What are the SOLID principles and how do they apply to Spring Boot applications?</h3>
<p><strong>Answer:</strong> SOLID principles in Spring Boot applications: 1) Single Responsibility: Create focused @Service and @Repository classes handling one business concern, 2) Open/Closed: Use interfaces and dependency injection to extend behavior without modification, 3) Liskov Substitution: Use polymorphic service implementations with common interfaces, 4) Interface Segregation: Define client-specific repository interfaces extending base repositories, 5) Dependency Inversion: Rely on Spring&#39;s IoC container to inject dependencies defined by interfaces not implementations. Spring Boot&#39;s architecture naturally encourages SOLID through its component model and dependency injection system.</p>
<h3 id="172-what-design-patterns-are-commonly-used-in-spring-boot-applications-">172. What design patterns are commonly used in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Common design patterns in Spring Boot applications include: 1) Dependency Injection (core Spring feature), 2) Singleton (default scope for Spring beans), 3) Factory (BeanFactory), 4) Proxy (for AOP and transaction management), 5) Template Method (JdbcTemplate, RestTemplate), 6) Observer (with ApplicationEvent), 7) Strategy (configurable beans with different implementations), 8) Decorator (@ControllerAdvice, filters), 9) Adapter (between different APIs), 10) Builder (fluent configuration APIs), and 11) Repository (Spring Data repositories). Spring Boot implements many patterns internally, making them accessible through annotations and interfaces.</p>
<h3 id="173-what-is-the-saga-pattern-and-how-would-you-implement-it-in-spring-boot-">173. What is the saga pattern and how would you implement it in Spring Boot?</h3>
<p><strong>Answer:</strong> The saga pattern manages distributed transactions across microservices through a sequence of local transactions, each publishing events and implementing compensating transactions for rollback. Implement it in Spring Boot using: 1) Choreography approach with Spring Cloud Stream for event publishing and consuming between services, 2) Orchestration approach with a dedicated service using Spring State Machine, 3) Transaction outbox pattern with JdbcTemplate for reliable event publishing, or 4) Frameworks like Eventuate Tram or Axon Framework with Spring Boot integration. Each service implements compensating actions triggered by failure events to maintain consistency.</p>
<h3 id="174-how-do-you-implement-cqrs-command-query-responsibility-segregation-in-spring-boot-">174. How do you implement CQRS (Command Query Responsibility Segregation) in Spring Boot?</h3>
<p><strong>Answer:</strong> Implement CQRS in Spring Boot by separating read and write models: 1) Create command controllers/services for write operations that modify state and return minimal responses, 2) Create query controllers/services optimized for reads with specialized DTOs and projections, 3) Use separate data repositories or entirely different databases for reads and writes, 4) Implement event sourcing with Spring Cloud Stream to propagate changes from write to read models, 5) Use @Async methods or message queues to asynchronously update read models. This pattern improves performance and scalability for read-heavy applications with complex domains.</p>
<h3 id="175-how-do-you-implement-the-event-sourcing-pattern-in-spring-boot-">175. How do you implement the event sourcing pattern in Spring Boot?</h3>
<p><strong>Answer:</strong> Implement event sourcing in Spring Boot using: 1) Define domain events as immutable classes, 2) Create an event store using JPA/JDBC or specialized databases like EventStoreDB, 3) Use Spring&#39;s ApplicationEventPublisher to publish domain events, 4) Implement event handlers with @EventListener to update read models, 5) Use Spring Cloud Stream for distributing events across services, 6) Consider frameworks like Axon or Eventuate for full event sourcing support. Event sourcing stores all changes as events rather than current state, enabling complete auditability, temporal querying, and rebuilding state from event history.</p>
<h3 id="176-what-is-the-outbox-pattern-and-how-do-you-implement-it-in-spring-boot-">176. What is the outbox pattern and how do you implement it in Spring Boot?</h3>
<p><strong>Answer:</strong> The outbox pattern ensures reliable message publishing alongside database transactions by storing messages in an &quot;outbox&quot; table within the same transaction as business data. Implement in Spring Boot: 1) Create an outbox table and entity, 2) Use @Transactional to insert both domain changes and outbox records atomically, 3) Create a separate process/thread using @Scheduled or Spring Integration to poll the outbox and publish messages to the actual message broker, 4) Mark messages as processed after successful publishing. This pattern solves the dual-write problem, guaranteeing message publishing even after system failures.</p>
<h3 id="177-how-do-you-handle-idempotency-in-rest-apis-using-spring-boot-">177. How do you handle idempotency in REST APIs using Spring Boot?</h3>
<p><strong>Answer:</strong> Handle idempotency in REST APIs by: 1) Use idempotent HTTP methods appropriately (GET, PUT, DELETE), 2) Implement idempotency keys: accept client-generated request IDs in headers and store them with responses, 3) Create an @IdempotentRequest annotation and AOP aspect checking if requests with the same key were processed, 4) Use conditional operations with ETag and If-Match headers via Spring&#39;s ShallowEtagHeaderFilter, 5) Implement optimistic locking with JPA @Version, and 6) Use database constraints for uniqueness. These techniques prevent duplicate processing, making APIs safer during retries and network issues.</p>
<h3 id="178-how-do-you-implement-the-anti-corruption-layer-acl-pattern-in-spring-boot-">178. How do you implement the Anti-Corruption Layer (ACL) pattern in Spring Boot?</h3>
<p><strong>Answer:</strong> Implement the Anti-Corruption Layer pattern in Spring Boot to isolate your domain model from external systems by: 1) Create dedicated @Service classes that translate between domain models and external systems, 2) Use adapters with interfaces defining how your domain interacts with external contexts, 3) Implement DTO classes for translating between your domain objects and external APIs, 4) Use ModelMapper or MapStruct for object translation, 5) Apply @Qualifier for different implementations of the same interface. ACL preserves domain model integrity while integrating with legacy systems or third-party services that follow different design concepts.</p>
<h3 id="179-what-is-the-difference-between-transactional-at-class-level-versus-method-level-">179. What is the difference between @Transactional at class level versus method level?</h3>
<p><strong>Answer:</strong> @Transactional at class level applies transaction behavior to all public methods in the class, creating a consistent transactional boundary around service operations. Method-level annotations override class-level settings, allowing for different propagation, isolation, or read-only settings for specific operations. Method-level annotations provide more granular control and clarity about transaction boundaries, while class-level annotations ensure consistent behavior and reduce repetition. Best practice is to use class-level annotation for general behavior and method-level for exceptions.</p>
<h3 id="180-how-do-you-implement-the-bulkhead-pattern-in-spring-boot-applications-">180. How do you implement the bulkhead pattern in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Implement the bulkhead pattern (isolating failures to prevent system-wide cascading) in Spring Boot using: 1) Thread pools with @Async methods and custom Executor beans with defined thread limits for different operations, 2) Resilience4j&#39;s @Bulkhead annotation to limit concurrent calls to specific methods, 3) Separate connection pools for different databases or services by defining multiple DataSource beans, 4) Using WebClient with specialized ConnectionProvider for HTTP clients. Configure timeouts and circuit breakers alongside bulkheads to prevent resource exhaustion and enable graceful degradation when subsystems fail.</p>
<h3 id="181-what-is-spring-integration-and-how-does-it-relate-to-spring-boot-">181. What is Spring Integration and how does it relate to Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Integration is a framework implementing Enterprise Integration Patterns for message-based applications. It relates to Spring Boot through the spring-boot-starter-integration, which auto-configures integration components. Spring Integration provides channel adapters, gateways, transformers, routers, and splitters to connect disparate systems. In Spring Boot applications, it enables event-driven architectures, message processing pipelines, and system integration with declarative configuration. Use it for integrating with external systems, implementing asynchronous workflows, or decoupling application components.</p>
<h3 id="182-how-do-you-implement-reactive-programming-with-spring-webflux-">182. How do you implement reactive programming with Spring WebFlux?</h3>
<p><strong>Answer:</strong> Implement reactive programming with Spring WebFlux by: 1) Adding spring-boot-starter-webflux dependency (avoiding spring-boot-starter-web), 2) Creating controllers that return Mono/Flux types from Reactor, 3) Using annotated controllers (@RestController) or functional routing (RouterFunction), 4) Implementing reactive repositories with ReactiveCrudRepository interfaces when using Spring Data Reactive, 5) Using WebClient instead of RestTemplate for HTTP clients. WebFlux runs on Netty by default, offering non-blocking I/O with fewer threads, making it suitable for high-throughput, I/O-intensive applications.</p>
<h3 id="183-what-is-the-webclient-in-spring-and-how-does-it-differ-from-resttemplate-">183. What is the WebClient in Spring and how does it differ from RestTemplate?</h3>
<p><strong>Answer:</strong> WebClient is Spring&#39;s reactive HTTP client, while RestTemplate is the traditional synchronous client. WebClient offers non-blocking, asynchronous operations returning Mono/Flux types, fluent builder API, and reactive patterns support. RestTemplate uses thread-per-request model with blocking I/O. WebClient supports streaming scenarios, better backpressure handling, and functional-style chaining. Example WebClient usage:</p>
<pre><code class="lang-java"><span class="hljs-selector-tag">webClient</span><span class="hljs-selector-class">.get</span>()
    <span class="hljs-selector-class">.uri</span>(<span class="hljs-string">"/users/{id}"</span>, id)
    <span class="hljs-selector-class">.retrieve</span>()
    <span class="hljs-selector-class">.bodyToMono</span>(User.class)
    <span class="hljs-selector-class">.map</span>(<span class="hljs-attribute">this</span>::processUser);
</code></pre>
<p>Spring recommends WebClient for new applications, with RestTemplate being in maintenance mode.</p>
<h3 id="184-how-do-you-implement-jwt-authentication-with-refresh-tokens-in-spring-security-">184. How do you implement JWT authentication with refresh tokens in Spring Security?</h3>
<p><strong>Answer:</strong> Implement JWT with refresh tokens by: 1) Configure JwtAuthenticationFilter for token validation, 2) Create authentication endpoints for login that return both access and refresh tokens, 3) Implement a /refresh endpoint accepting refresh tokens and returning new access tokens, 4) Store refresh tokens in a database with user association and expiration time, 5) Configure different expiration times for access tokens (short-lived) and refresh tokens (longer-lived), 6) Invalidate refresh tokens on logout or password change. This approach balances security (short-lived access tokens) with user experience (avoiding frequent logins).</p>
<h3 id="185-what-metrics-and-monitoring-capabilities-does-spring-boot-actuator-provide-">185. What metrics and monitoring capabilities does Spring Boot Actuator provide?</h3>
<p><strong>Answer:</strong> Spring Boot Actuator provides: 1) Health checks with customizable indicators (/actuator/health), 2) Application metrics via Micrometer (/actuator/metrics) including JVM stats, HTTP requests, cache operations, and custom metrics, 3) HTTP request tracing (/actuator/httptrace), 4) Thread dumps (/actuator/threaddump), 5) Environment info (/actuator/env), 6) Configuration properties (/actuator/configprops), 7) Audit events (/actuator/auditevents), and 8) Log level management (/actuator/loggers). It integrates with monitoring systems like Prometheus, Graphite, and New Relic through Micrometer, enabling comprehensive application observability.</p>
<h3 id="186-what-is-spring-batch-and-how-does-it-integrate-with-spring-boot-">186. What is Spring Batch and how does it integrate with Spring Boot?</h3>
<p><strong>Answer:</strong> Spring Batch is a framework for batch processing with features for reading, processing, and writing large volumes of data. Spring Boot integrates it through spring-boot-starter-batch, which auto-configures JobRepository, JobLauncher, and transaction management. Create batch jobs by defining Step beans with readers, processors, and writers, then assembling them into Job beans. Spring Boot automatically executes jobs on startup (configurable with spring.batch.job.enabled=false). Use @EnableBatchProcessing annotation and JobBuilderFactory/StepBuilderFactory for job configuration, with built-in support for checkpointing, restart, and parallel processing.</p>
<h3 id="187-how-do-you-implement-method-level-caching-in-spring-boot-">187. How do you implement method-level caching in Spring Boot?</h3>
<p><strong>Answer:</strong> Implement method-level caching by: 1) Add spring-boot-starter-cache dependency, 2) Enable caching with @EnableCaching annotation, 3) Apply @Cacheable annotation to methods you want to cache, specifying cache names: @Cacheable(&quot;users&quot;), 4) Use @CacheEvict to remove entries and @CachePut to update cache without affecting method execution, 5) Configure cache providers like Caffeine, Redis, or EhCache in application.properties. Additional features include conditional caching with SpEL expressions, key generation strategies, and error handling: @Cacheable(value=&quot;users&quot;, key=&quot;#id&quot;, condition=&quot;#id!=null&quot;).</p>
<h3 id="188-what-is-the-difference-between-mockbean-and-mock-annotations-in-testing-">188. What is the difference between @MockBean and @Mock annotations in testing?</h3>
<p><strong>Answer:</strong> @MockBean is a Spring Boot annotation that replaces a bean in the application context with a Mockito mock, useful for integration tests where you need to mock a specific bean. @Mock is a Mockito annotation that creates a mock object not connected to the Spring context, used in unit tests with @InjectMocks. @MockBean integrates with Spring&#39;s dependency injection, affecting all autowired instances of the bean, while @Mock operates outside Spring&#39;s context. Use @MockBean when testing a Spring component that autowires dependencies, and @Mock for isolated unit tests.</p>
<h3 id="189-how-do-you-implement-a-rate-limiter-in-spring-boot-">189. How do you implement a rate limiter in Spring Boot?</h3>
<p><strong>Answer:</strong> Implement rate limiting in Spring Boot through several approaches: 1) Using Resilience4j&#39;s @RateLimiter annotation to limit method invocations, 2) Creating a custom servlet filter that tracks request counts in a cache (like Caffeine) with time windows, 3) Implementing Spring Cloud Gateway RateLimiter filter for API gateway level limiting, 4) Using bucket4j library with custom interceptors, 5) Utilizing Redis for distributed rate limiting across application instances. Configure limits based on client identifiers (API keys, user IDs, or IP addresses) and implement appropriate response handling (429 Too Many Requests) when limits are exceeded.</p>
<h3 id="190-what-are-the-best-practices-for-making-spring-boot-applications-production-ready-">190. What are the best practices for making Spring Boot applications production-ready?</h3>
<p><strong>Answer:</strong> Production-ready Spring Boot best practices include: 1) Implement comprehensive health checks with custom HealthIndicator beans, 2) Configure appropriate logging levels and centralized log aggregation, 3) Enable metrics collection through Actuator and integrating with monitoring systems, 4) Implement circuit breakers for external service calls, 5) Use externalized configuration with environment-specific properties, 6) Configure connection pool sizes and timeouts appropriately, 7) Set up proper exception handling and fallback mechanisms, 8) Enable HTTPS with security headers, 9) Implement audit logging for security events, and 10) Configure appropriate JVM settings and container resource limits.</p>
<h3 id="191-how-do-you-optimize-the-startup-time-of-a-spring-boot-application-">191. How do you optimize the startup time of a Spring Boot application?</h3>
<p><strong>Answer:</strong> Optimize Spring Boot startup time by: 1) Using Spring Boot 2.2+ lazy initialization (spring.main.lazy-initialization=true) to initialize beans on first use rather than startup, 2) Implementing conditionals to skip unnecessary auto-configuration, 3) Using functional bean registration rather than component scanning, 4) Avoiding classpath scanning with explicit imports, 5) Reducing third-party libraries and dependencies, 6) Using Spring Native or GraalVM native images for compiled applications, 7) Tuning JVM parameters, particularly class loading and garbage collection settings, and 8) Moving time-consuming initialization tasks to background threads with @Async and ApplicationListener events.</p>
<h3 id="192-what-are-the-different-bean-scopes-in-spring-and-when-should-you-use-each-">192. What are the different bean scopes in Spring and when should you use each?</h3>
<p><strong>Answer:</strong> Spring bean scopes include: 1) Singleton (default): one instance shared across the application, ideal for stateless services, 2) Prototype: new instance created each time requested, for stateful beans with no shared state, 3) Request: one instance per HTTP request, for web-specific beans storing request data, 4) Session: one instance per HTTP session, for user-specific data across requests, 5) Application: one instance per ServletContext, and 6) Websocket: one instance per websocket session. Choose singleton for shared functionality, prototype for beans with mutable state, and web-specific scopes when the lifecycle should match HTTP concepts.</p>
<h3 id="193-how-do-you-implement-graceful-shutdown-in-spring-boot-applications-">193. How do you implement graceful shutdown in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Implement graceful shutdown by: 1) Configure server.shutdown=graceful in application.properties, 2) Set spring.lifecycle.timeout-per-shutdown-phase for maximum wait time, 3) Implement SmartLifecycle beans to handle custom shutdown logic, 4) Use @PreDestroy methods for cleanup in beans, 5) For Kubernetes, configure preStop hooks and termination grace periods matching your application&#39;s needs, 6) Set appropriate connection draining in load balancers. Graceful shutdown allows in-flight requests to complete before terminating, prevents connection errors during rolling updates, and ensures proper resource cleanup.</p>
<h3 id="194-what-is-spring-modulith-and-how-does-it-help-with-modular-monoliths-">194. What is Spring Modulith and how does it help with modular monoliths?</h3>
<p><strong>Answer:</strong> Spring Modulith is a framework for building well-structured, modular monolithic applications. It provides: 1) Module definitions based on Java packages with explicit boundaries, 2) Dependency verification ensuring architectural constraints, 3) Integration testing support for individual modules, 4) Documentation generation showing module relationships, and 5) Event publishing between modules. Use it when you want the simplicity of deployment and transactions from a monolith while enforcing clean separation between functional domains, giving you the architecture benefits of microservices without distributed systems complexity.</p>
<h3 id="195-how-do-you-implement-database-sharding-with-spring-boot-">195. How do you implement database sharding with Spring Boot?</h3>
<p><strong>Answer:</strong> Implement database sharding with Spring Boot using: 1) Multiple DataSource beans configured with a routing data source (AbstractRoutingDataSource) that selects the appropriate shard based on tenant ID or other sharding key, 2) Use transaction management with ChainedTransactionManager for distributed transactions across shards, 3) Implement ShardingJdbcTemplate extending JdbcTemplate for custom routing logic, 4) Consider specialized libraries like ShardingSphere or Apache Shardingsphere, which integrate with Spring Boot via custom auto-configurations. Appropriate for horizontal scaling of very large datasets with tables partitioned across multiple database instances.</p>
<h3 id="196-what-are-the-best-practices-for-securing-rest-apis-in-spring-boot-">196. What are the best practices for securing REST APIs in Spring Boot?</h3>
<p><strong>Answer:</strong> Secure REST APIs in Spring Boot by: 1) Implementing JWT or OAuth2 authentication with proper token validation, 2) Using HTTPS exclusively with modern TLS versions, 3) Implementing proper CORS configuration for browser clients, 4) Adding security headers (Content-Security-Policy, X-XSS-Protection) via Spring Security, 5) Validating all input with Bean Validation, 6) Implementing rate limiting to prevent abuse, 7) Using method security with fine-grained permissions (@PreAuthorize/@PostAuthorize), 8) Logging security events with Spring Security&#39;s audit capabilities, 9) Implementing proper error handling that doesn&#39;t leak sensitive information, and 10) Regular dependency updates to address vulnerabilities.</p>
<h3 id="197-how-do-you-implement-schema-versioning-and-backward-compatibility-in-rest-apis-">197. How do you implement schema versioning and backward compatibility in REST APIs?</h3>
<p><strong>Answer:</strong> Implement API versioning in Spring Boot using: 1) URI versioning with @RequestMapping(&quot;/api/v1/users&quot;), 2) Request parameter versioning with @RequestParam, 3) Header versioning using custom headers, 4) Media type versioning with Content-Type headers (application/vnd.company.app-v1+json), or 5) Accept header versioning. Support backward compatibility by never removing fields in responses, making new fields optional, using @JsonIgnoreProperties(ignoreUnknown=true) for clients, implementing API gateways with request/response transformation, and documenting changes with tools like SpringDoc OpenAPI. Consider using API management platforms for complex versioning needs.</p>
<h3 id="198-what-are-the-different-types-of-tests-in-spring-boot-and-when-should-you-use-each-">198. What are the different types of tests in Spring Boot and when should you use each?</h3>
<p><strong>Answer:</strong> Spring Boot test types include: 1) Unit tests (fastest) for individual classes with mocks for dependencies, 2) Integration tests with @DataJpaTest, @WebMvcTest for testing slices of the application, 3) Full application context tests with @SpringBootTest for end-to-end testing, 4) @WebFluxTest for reactive controller testing, 5) @JdbcTest for SQL operations testing. Use unit tests for logic-heavy components, slice tests for specific layers, and full integration tests for critical paths. Maintain a test pyramid with many unit tests, fewer slice tests, and minimal full context tests to balance coverage with execution speed.</p>
<h3 id="199-how-do-you-implement-multi-tenancy-in-spring-boot-applications-">199. How do you implement multi-tenancy in Spring Boot applications?</h3>
<p><strong>Answer:</strong> Implement multi-tenancy using: 1) Database-per-tenant: Configure multiple DataSource beans with TenantAwareRoutingDataSource extending AbstractRoutingDataSource, 2) Schema-per-tenant: Use a single database with dynamically set search paths or schema names, 3) Discriminator column: Add tenant ID column to all tables and filter queries with TenantFilter or @TenantFilter annotations, 4) Store tenant context in ThreadLocal via servlet filter or AOP, 5) Use Spring Security to extract tenant information from authentication. Each approach offers different isolation levels; balance security requirements against operational complexity when selecting a strategy.</p>
<h3 id="200-what-s-the-difference-between-blocking-and-reactive-programming-models-in-spring-">200. What&#39;s the difference between blocking and reactive programming models in Spring?</h3>
<p><strong>Answer:</strong> Blocking (Spring MVC) uses one thread per request, waiting for I/O operations to complete before continuing execution. Reactive (Spring WebFlux) uses event loops and callbacks/Publishers, allowing threads to process other requests during I/O waits. Blocking is simpler to understand and debug, with familiar imperative programming, while reactive handles more concurrent connections with fewer threads and provides better backpressure handling. Choose blocking for CPU-bound applications with simple flows, and reactive for I/O-bound applications requiring high throughput. Don&#39;t mix models within a single call chain as it nullifies the benefits of reactive programming.</p>
</body></html>