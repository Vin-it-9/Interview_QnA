<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>

    <link href="../style.css" rel="stylesheet" type="text/css" >
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11/build/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

</head>
<body>

<h1 id="jpa--hibernate">JPA &amp; Hibernate</h1>
<h3 id="1-what-is-jpa-and-how-is-it-related-to-hibernate">1. What is JPA and how is it related to Hibernate?</h3>
<p><strong>Answer:</strong> JPA (Java Persistence API) is a Java specification that provides a standard way to manage relational data in Java applications. It&#39;s part of the Jakarta EE (formerly Java EE) platform and defines an object-relational mapping (ORM) approach for persisting Java objects to relational databases.</p>
<p>Hibernate is one of the most popular implementations of JPA. While JPA is just a specification (a set of interfaces), Hibernate provides the actual concrete implementation of these interfaces. This relationship allows developers to write code against the JPA interfaces while using Hibernate as the underlying implementation, making it easier to switch to another JPA provider if needed.</p>
<h3 id="2-what-is-orm-and-what-problem-does-it-solve">2. What is ORM and what problem does it solve?</h3>
<p><strong>Answer:</strong> ORM (Object-Relational Mapping) is a programming technique that converts data between incompatible type systems in object-oriented programming languages and relational databases.</p>
<p>Problems ORM solves:</p>
<ul>
    <li><strong>Impedance mismatch</strong>: Bridges the gap between object-oriented code and relational data models</li>
    <li><strong>Boilerplate reduction</strong>: Eliminates repetitive JDBC code for database operations</li>
    <li><strong>Database independence</strong>: Allows switching between database vendors with minimal code changes</li>
    <li><strong>Object-oriented approach</strong>: Enables working with database data using familiar object-oriented concepts</li>
    <li><strong>Productivity</strong>: Accelerates development by handling low-level database interactions</li>
</ul>
<p>Hibernate, as an ORM framework, handles the complex mapping between Java objects and database tables, allowing developers to focus on business logic rather than database access code.</p>
<h3 id="3-what-are-the-main-differences-between-jpa-and-hibernate">3. What are the main differences between JPA and Hibernate?</h3>
<p><strong>Answer:</strong> </p>
<ul>
    <li><strong>Specification vs Implementation</strong>: JPA is a specification (set of interfaces) while Hibernate is a concrete implementation of JPA</li>
    <li><strong>Scope</strong>: JPA covers only ORM concepts, while Hibernate offers additional features beyond JPA</li>
    <li><strong>Annotations</strong>: JPA uses <code>javax.persistence.*</code> or <code>jakarta.persistence.*</code> annotations, while Hibernate has its own annotations in <code>org.hibernate.*</code> packages</li>
    <li><strong>Configuration</strong>: JPA uses <code>persistence.xml</code> for configuration, while Hibernate can use either <code>persistence.xml</code> or <code>hibernate.cfg.xml</code></li>
    <li><strong>Query Language</strong>: JPA defines JPQL (Java Persistence Query Language), while Hibernate has HQL (Hibernate Query Language) with additional features</li>
    <li><strong>Vendor lock-in</strong>: Using pure JPA reduces vendor lock-in, while using Hibernate-specific features creates dependency on Hibernate</li>
    <li><strong>Caching</strong>: Hibernate provides more advanced caching options beyond what JPA specifies</li>
</ul>
<h3 id="4-what-is-an-entity-in-jpahibernate">4. What is an Entity in JPA/Hibernate?</h3>
<p><strong>Answer:</strong> An Entity in JPA/Hibernate is a lightweight, persistent domain object that represents a table in a relational database. Key characteristics include:</p>
<ol>
    <li><strong>Persistence</strong>: Entities can be stored in and retrieved from the database</li>
    <li><strong>POJO-based</strong>: They are Plain Old Java Objects (no need to extend specific classes)</li>
    <li><strong>Annotation-based</strong>: Marked with <code>@Entity</code> annotation</li>
    <li><strong>Identity</strong>: Must have a unique identifier (primary key) annotated with <code>@Id</code></li>
    <li><strong>State representation</strong>: Each entity instance represents a row in a database table</li>
    <li><strong>Mapping</strong>: Fields/properties in the entity map to columns in the corresponding table</li>
</ol>
<p>Example of a basic entity:</p>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    private Long id;
    private String firstName;
    private String lastName;
    // Constructors, getters, setters
}
</code></pre>
<h3 id="5-what-are-the-key-jpa-annotations-and-their-purpose">5. What are the key JPA annotations and their purpose?</h3>
<p><strong>Answer:</strong> Key JPA annotations include:</p>
<ol>
    <li><strong>@Entity</strong>: Marks a class as an entity (i.e., a persistent domain object)</li>
    <li><strong>@Table</strong>: Specifies the primary table for the entity (optional, defaults to the entity name)</li>
    <li><strong>@Id</strong>: Marks a field as the primary key</li>
    <li><strong>@GeneratedValue</strong>: Defines primary key generation strategy (e.g., IDENTITY, SEQUENCE, AUTO)</li>
    <li><strong>@Column</strong>: Specifies column mapping details (name, nullable, length, etc.)</li>
    <li><strong>@Temporal</strong>: Specifies mapping for java.util.Date and java.util.Calendar fields</li>
    <li><strong>@Transient</strong>: Marks a field that should not be persisted</li>
    <li><strong>@OneToOne</strong>: Defines a one-to-one relationship between entities</li>
    <li><strong>@OneToMany</strong>: Defines a one-to-many relationship between entities</li>
    <li><strong>@ManyToOne</strong>: Defines a many-to-one relationship between entities</li>
    <li><strong>@ManyToMany</strong>: Defines a many-to-many relationship between entities</li>
    <li><strong>@JoinColumn</strong>: Specifies a foreign key column in relationships</li>
    <li><strong>@Embeddable/@Embedded</strong>: Defines embeddable classes for component values</li>
</ol>
<p>These annotations allow mapping Java objects to database structures with minimal code.</p>
<h3 id="6-what-is-the-entity-lifecycle-in-jpahibernate">6. What is the entity lifecycle in JPA/Hibernate?</h3>
<p><strong>Answer:</strong> The JPA entity lifecycle consists of four states:</p>
<ol>
    <li><p><strong>New/Transient</strong>:</p>
        <ul>
            <li>Object has been instantiated using the <code>new</code> operator</li>
            <li>Not associated with any persistence context</li>
            <li>Has no persistent representation in the database</li>
            <li>Changes to the object are not tracked</li>
        </ul>
    </li>
    <li><p><strong>Managed/Persistent</strong>:</p>
        <ul>
            <li>Entity is associated with a persistence context</li>
            <li>Has a representation in the database</li>
            <li>Changes to the entity are tracked and synchronized with the database on transaction commit</li>
            <li>Achieved via <code>persist()</code>, <code>merge()</code>, or when an entity is loaded from the database</li>
        </ul>
    </li>
    <li><p><strong>Detached</strong>:</p>
        <ul>
            <li>Entity was previously managed but is no longer associated with a persistence context</li>
            <li>Has a representation in the database but changes are not tracked</li>
            <li>Can be reattached to a persistence context using <code>merge()</code></li>
            <li>Occurs when the persistence context is closed or the entity is explicitly detached</li>
        </ul>
    </li>
    <li><p><strong>Removed</strong>:</p>
        <ul>
            <li>Entity is scheduled for removal from the database</li>
            <li>Still managed until the transaction completes</li>
            <li>Achieved via <code>remove()</code> method</li>
            <li>Changes to the entity might still be cascaded to related entities</li>
        </ul>
    </li>
</ol>
<p>Understanding the entity lifecycle is crucial for managing persistence operations correctly and avoiding common pitfalls.</p>
<h3 id="7-what-is-entitymanager-in-jpa-and-what-are-its-key-functions">7. What is EntityManager in JPA and what are its key functions?</h3>
<p><strong>Answer:</strong> EntityManager is the primary interface in JPA for managing persistence operations. It provides an API for interacting with the persistence context and handling entity lifecycle.</p>
<p>Key functions of EntityManager:</p>
<ol>
    <li><strong>persist(entity)</strong>: Makes a new entity instance managed and persistent</li>
    <li><strong>find(entityClass, primaryKey)</strong>: Retrieves an entity by its primary key</li>
    <li><strong>merge(entity)</strong>: Merges the state of a detached entity into the persistence context</li>
    <li><strong>remove(entity)</strong>: Removes an entity instance from the database</li>
    <li><strong>flush()</strong>: Synchronizes the persistence context to the underlying database</li>
    <li><strong>clear()</strong>: Clears the persistence context, detaching all managed entities</li>
    <li><strong>detach(entity)</strong>: Detaches an entity from the persistence context</li>
    <li><strong>refresh(entity)</strong>: Refreshes the state of an entity from the database</li>
    <li><strong>createQuery(jpql)</strong>: Creates a JPQL query</li>
    <li><strong>createNativeQuery(sql)</strong>: Creates a native SQL query</li>
    <li><strong>contains(entity)</strong>: Checks if an entity is managed in the persistence context</li>
    <li><strong>getTransaction()</strong>: Returns the resource-level EntityTransaction object</li>
</ol>
<p>EntityManager is the main access point for JPA operations and manages the connection between Java objects and database records.</p>
<h3 id="8-what-is-the-difference-between-entitymanager-and-session-in-hibernate">8. What is the difference between EntityManager and Session in Hibernate?</h3>
<p><strong>Answer:</strong> </p>
<ul>
    <li><strong>EntityManager</strong> is the JPA standard interface for persistence operations</li>
    <li><strong>Session</strong> is Hibernate&#39;s proprietary equivalent of EntityManager with additional features</li>
</ul>
<p>Key differences:</p>
<ol>
    <li><p><strong>Specification</strong>:</p>
        <ul>
            <li>EntityManager is defined by JPA specification</li>
            <li>Session is Hibernate-specific and extends beyond JPA capabilities</li>
        </ul>
    </li>
    <li><p><strong>Namespace</strong>:</p>
        <ul>
            <li>EntityManager belongs to <code>javax.persistence</code> or <code>jakarta.persistence</code> package</li>
            <li>Session belongs to <code>org.hibernate</code> package</li>
        </ul>
    </li>
    <li><p><strong>Features</strong>:</p>
        <ul>
            <li>Session provides Hibernate-specific features not in EntityManager (e.g., advanced filtering, multi-criteria)</li>
            <li>Session has more explicit control over caching and flushing</li>
        </ul>
    </li>
    <li><p><strong>Access</strong>:</p>
        <ul>
            <li>In Hibernate applications using JPA, you can get a Session from EntityManager:<pre><code class="language-java">Session session = entityManager.unwrap(Session.class);
</code></pre>
            </li>
        </ul>
    </li>
    <li><p><strong>API Style</strong>:</p>
        <ul>
            <li>EntityManager uses JPA&#39;s standardized API</li>
            <li>Session has some different method names and additional capabilities</li>
        </ul>
    </li>
</ol>
<p>Most applications should use EntityManager for better portability, only falling back to Session when specific Hibernate features are needed.</p>
<h3 id="9-what-is-the-role-of-the-persistencexml-file">9. What is the role of the persistence.xml file?</h3>
<p><strong>Answer:</strong> <code>persistence.xml</code> is the standard configuration file for JPA applications. It defines one or more persistence units, which contain the configuration for entity managers. Key elements include:</p>
<ol>
    <li><strong>Persistence unit definition</strong>: Names and configures a persistence unit</li>
    <li><strong>JPA provider specification</strong>: Defines which JPA implementation to use (e.g., Hibernate)</li>
    <li><strong>Data source configuration</strong>: Specifies database connection details</li>
    <li><strong>Entity classes</strong>: Declares or discovers entity classes to be managed</li>
    <li><strong>Properties</strong>: Sets JPA and provider-specific properties (schema generation, SQL logging, etc.)</li>
</ol>
<p>Example of a basic <code>persistence.xml</code> file:</p>
<pre><code class="language-xml">&lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot;
             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
             xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence
                                 http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot;
             version=&quot;2.2&quot;&gt;
    &lt;persistence-unit name=&quot;myPersistenceUnit&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;
        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;
        &lt;class&gt;com.example.entity.Employee&lt;/class&gt;
        &lt;properties&gt;
            &lt;property name=&quot;javax.persistence.jdbc.driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;
            &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot; /&gt;
            &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;username&quot; /&gt;
            &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;password&quot; /&gt;
            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot; /&gt;
            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot; /&gt;
            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot; /&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</code></pre>
<h3 id="10-how-do-you-define-a-primary-key-in-jpahibernate">10. How do you define a primary key in JPA/Hibernate?</h3>
<p><strong>Answer:</strong> In JPA/Hibernate, primary keys are defined using the <code>@Id</code> annotation. There are several strategies for generating primary key values:</p>
<ol>
    <li><p><strong>Basic Primary Key</strong>:</p>
        <pre><code class="language-java">@Entity
public class Employee {
    @Id
    private Long id;
    // Other fields, getters, setters
}
</code></pre>
    </li>
    <li><p><strong>Auto-generated Primary Key</strong>:</p>
        <pre><code class="language-java">@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    // Other fields, getters, setters
}
</code></pre>
    </li>
    <li><p><strong>Common Generation Strategies</strong>:</p>
        <ul>
            <li><code>GenerationType.AUTO</code>: Provider selects appropriate strategy</li>
            <li><code>GenerationType.IDENTITY</code>: Uses auto-increment column (e.g., MySQL AUTO_INCREMENT)</li>
            <li><code>GenerationType.SEQUENCE</code>: Uses database sequence object</li>
            <li><code>GenerationType.TABLE</code>: Uses a separate table to generate IDs</li>
        </ul>
    </li>
    <li><p><strong>Sequence Generator Example</strong>:</p>
        <pre><code class="language-java">@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;emp_seq&quot;)
    @SequenceGenerator(name = &quot;emp_seq&quot;, sequenceName = &quot;EMPLOYEE_SEQ&quot;, allocationSize = 1)
    private Long id;
    // Other fields, getters, setters
}
</code></pre>
    </li>
    <li><p><strong>Composite Primary Key</strong> (using <code>@IdClass</code>):</p>
        <pre><code class="language-java">@Entity
@IdClass(EmployeePK.class)
public class Employee {
    @Id
    private String departmentId;
    @Id
    private Long employeeNumber;
    // Other fields, getters, setters
}
</code></pre>
    </li>
    <li><p><strong>Composite Key</strong> (using <code>@EmbeddedId</code>):</p>
        <pre><code class="language-java">@Entity
public class Employee {
    @EmbeddedId
    private EmployeePK id;
    // Other fields, getters, setters
}
</code></pre>
    </li>
</ol>
<p>The choice of primary key strategy should consider database performance, scalability, and specific application requirements.</p>

<h3 id="11-how-do-you-map-a-one-to-one-relationship-in-hibernatejpa">11. How do you map a one-to-one relationship in Hibernate/JPA?</h3>
<p><strong>Answer:</strong> A one-to-one relationship in JPA/Hibernate can be mapped using the <code>@OneToOne</code> annotation. This relationship means one entity instance relates to exactly one instance of another entity.</p>
<p><strong>Unidirectional one-to-one mapping example:</strong></p>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @OneToOne
    @JoinColumn(name = &quot;parking_space_id&quot;)
    private ParkingSpace parkingSpace;

    // Getters and setters
}

@Entity
public class ParkingSpace {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String location;
    private String spaceNumber;

    // Getters and setters
}
</code></pre>
<p><strong>Bidirectional one-to-one mapping example:</strong></p>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @OneToOne
    @JoinColumn(name = &quot;parking_space_id&quot;)
    private ParkingSpace parkingSpace;

    // Getters and setters
}

@Entity
public class ParkingSpace {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String location;
    private String spaceNumber;

    @OneToOne(mappedBy = &quot;parkingSpace&quot;)
    private Employee employee;

    // Getters and setters
}
</code></pre>
<p>The <code>mappedBy</code> attribute indicates that the relationship is owned by the Employee entity.</p>
<h3 id="12-how-do-you-map-a-one-to-many-relationship-in-hibernatejpa">12. How do you map a one-to-many relationship in Hibernate/JPA?</h3>
<p><strong>Answer:</strong> A one-to-many relationship in JPA/Hibernate indicates that one entity can be associated with multiple instances of another entity. It&#39;s typically mapped using the <code>@OneToMany</code> and <code>@ManyToOne</code> annotations.</p>
<p><strong>Bidirectional one-to-many example:</strong></p>
<pre><code class="language-java">@Entity
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @OneToMany(mappedBy = &quot;department&quot;, cascade = CascadeType.ALL, orphanRemoval = true)
    private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();

    // Getters and setters

    // Helper methods to maintain both sides of the relationship
    public void addEmployee(Employee employee) {
        employees.add(employee);
        employee.setDepartment(this);
    }

    public void removeEmployee(Employee employee) {
        employees.remove(employee);
        employee.setDepartment(null);
    }
}

@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @ManyToOne
    @JoinColumn(name = &quot;department_id&quot;)
    private Department department;

    // Getters and setters
}
</code></pre>
<p><strong>Unidirectional one-to-many example (using join table):</strong></p>
<pre><code class="language-java">@Entity
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @OneToMany
    @JoinTable(name = &quot;department_employee&quot;,
        joinColumns = @JoinColumn(name = &quot;department_id&quot;),
        inverseJoinColumns = @JoinColumn(name = &quot;employee_id&quot;))
    private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();

    // Getters and setters
}
</code></pre>
<p>The bidirectional approach is generally preferred for better performance and easier navigation between entities.</p>
<h3 id="13-how-do-you-map-a-many-to-many-relationship-in-hibernatejpa">13. How do you map a many-to-many relationship in Hibernate/JPA?</h3>
<p><strong>Answer:</strong> A many-to-many relationship in JPA/Hibernate means many instances of one entity can associate with many instances of another entity. It&#39;s typically implemented using a join table and mapped with the <code>@ManyToMany</code> annotation.</p>
<p><strong>Basic many-to-many example:</strong></p>
<pre><code class="language-java">@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @ManyToMany
    @JoinTable(name = &quot;student_course&quot;,
        joinColumns = @JoinColumn(name = &quot;student_id&quot;),
        inverseJoinColumns = @JoinColumn(name = &quot;course_id&quot;))
    private Set&lt;Course&gt; courses = new HashSet&lt;&gt;();

    // Getters and setters
}

@Entity
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @ManyToMany(mappedBy = &quot;courses&quot;)
    private Set&lt;Student&gt; students = new HashSet&lt;&gt;();

    // Getters and setters
}
</code></pre>
<p><strong>Many-to-many with extra attributes in join table:</strong>
    For relationships that need additional attributes, it&#39;s better to create an explicit entity for the join table:</p>
<pre><code class="language-java">@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @OneToMany(mappedBy = &quot;student&quot;)
    private Set&lt;Enrollment&gt; enrollments = new HashSet&lt;&gt;();

    // Getters and setters
}

@Entity
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @OneToMany(mappedBy = &quot;course&quot;)
    private Set&lt;Enrollment&gt; enrollments = new HashSet&lt;&gt;();

    // Getters and setters
}

@Entity
public class Enrollment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = &quot;student_id&quot;)
    private Student student;

    @ManyToOne
    @JoinColumn(name = &quot;course_id&quot;)
    private Course course;

    private LocalDate enrollmentDate;
    private String grade;

    // Getters and setters
}
</code></pre>
<h3 id="14-what-is-the-purpose-of-cascade-operations-in-jpahibernate">14. What is the purpose of cascade operations in JPA/Hibernate?</h3>
<p><strong>Answer:</strong> Cascade operations in JPA/Hibernate automatically propagate persistence operations from a parent entity to its associated child entities. They can simplify managing relationships by reducing boilerplate code.</p>
<p><strong>Types of cascade operations:</strong></p>
<ol>
    <li><code>CascadeType.PERSIST</code>: Persisting a parent entity also persists related entities</li>
    <li><code>CascadeType.MERGE</code>: Merging a parent entity also merges related entities</li>
    <li><code>CascadeType.REMOVE</code>: Removing a parent entity also removes related entities</li>
    <li><code>CascadeType.REFRESH</code>: Refreshing a parent entity also refreshes related entities</li>
    <li><code>CascadeType.DETACH</code>: Detaching a parent entity also detaches related entities</li>
    <li><code>CascadeType.ALL</code>: Includes all cascade types above</li>
</ol>
<p><strong>Example with cascade:</strong></p>
<pre><code class="language-java">@Entity
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @OneToMany(mappedBy = &quot;department&quot;, cascade = CascadeType.ALL, orphanRemoval = true)
    private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();

    // Getters and setters
}
</code></pre>
<p>With this configuration:</p>
<ul>
    <li>When you persist a Department, all its Employees are also persisted</li>
    <li>When you remove a Department, all its Employees are also removed</li>
    <li>When an Employee is removed from the collection, it&#39;s deleted from the database (orphanRemoval=true)</li>
</ul>
<p>Cascade operations should be used carefully, especially <code>CascadeType.REMOVE</code>, to avoid unintended deletions of related entities.</p>
<h3 id="15-what-is-the-orphanremoval-attribute-and-when-would-you-use-it">15. What is the orphanRemoval attribute and when would you use it?</h3>
<p><strong>Answer:</strong> The <code>orphanRemoval</code> attribute is a feature in JPA/Hibernate that automatically removes child entities when they&#39;re no longer referenced by their parent. It applies to <code>@OneToMany</code> and <code>@OneToOne</code> relationships.</p>
<p><strong>Key points about orphanRemoval:</strong></p>
<ol>
    <li>When set to <code>true</code>, child entities removed from the collection will be deleted from the database</li>
    <li>Only applies to entities that become &quot;orphaned&quot; (no longer referenced by their parent)</li>
    <li>Different from <code>CascadeType.REMOVE</code>, which removes children when the parent is removed</li>
    <li>Useful for parent-child relationships where children cannot exist without their parent</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@Entity
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String title;

    @OneToMany(mappedBy = &quot;post&quot;, cascade = CascadeType.ALL, orphanRemoval = true)
    private List&lt;Comment&gt; comments = new ArrayList&lt;&gt;();

    // Method that removes a comment
    public void removeComment(Comment comment) {
        comments.remove(comment);
        // comment will be deleted from the database because of orphanRemoval=true
    }

    // Getters and setters
}
</code></pre>
<p>When to use it:</p>
<ul>
    <li>For true parent-child relationships where the child&#39;s lifecycle depends on the parent</li>
    <li>When child entities should only exist within the context of their parent</li>
    <li>When removing a child from the parent collection should result in the child&#39;s deletion</li>
</ul>
<p>Not appropriate when:</p>
<ul>
    <li>The child entity might be referenced by other entities</li>
    <li>The child entity should continue to exist after being removed from the parent</li>
</ul>
<h3 id="16-what-is-the-difference-between-eager-and-lazy-loading-in-hibernate">16. What is the difference between eager and lazy loading in Hibernate?</h3>
<p><strong>Answer:</strong> Eager and lazy loading are strategies that determine when Hibernate loads related entities from the database.</p>
<p><strong>Eager Loading:</strong></p>
<ul>
    <li>Related entities are loaded immediately when the parent entity is loaded</li>
    <li>All data is retrieved in a single database query (or a few queries)</li>
    <li>Can lead to performance issues if too many associations are eagerly loaded</li>
    <li>Useful when you almost always need the related entities</li>
    <li>Default fetch type for <code>@ManyToOne</code> and <code>@OneToOne</code> relationships</li>
</ul>
<p><strong>Lazy Loading:</strong></p>
<ul>
    <li>Related entities are loaded only when they&#39;re explicitly accessed (when getter is called)</li>
    <li>More database queries, but potentially less data transferred initially</li>
    <li>Can cause N+1 query problem if not managed carefully</li>
    <li>Requires an open session when accessing lazy associations to avoid LazyInitializationException</li>
    <li>Default fetch type for <code>@OneToMany</code> and <code>@ManyToMany</code> relationships</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Eager loading
@Entity
public class Employee {
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.EAGER)
    private Department department; // Loaded immediately when Employee is loaded

    // Other fields, getters, setters
}

// Lazy loading
@Entity
public class Department {
    @Id
    private Long id;

    @OneToMany(mappedBy = &quot;department&quot;, fetch = FetchType.LAZY)
    private List&lt;Employee&gt; employees; // Loaded only when getEmployees() is called

    // Other fields, getters, setters
}
</code></pre>
<p>The choice between eager and lazy loading should be based on usage patterns and performance considerations:</p>
<ul>
    <li>Use eager loading for associations that are almost always needed</li>
    <li>Use lazy loading for large collections or rarely accessed associations</li>
    <li>Consider using batch fetching, entity graphs, or join fetches to optimize lazy loading</li>
</ul>
<h3 id="17-what-is-a-detached-entity-in-hibernate-and-how-do-you-reattach-it">17. What is a detached entity in Hibernate and how do you reattach it?</h3>
<p><strong>Answer:</strong> A detached entity in Hibernate is an entity that was previously managed by a persistence context (EntityManager/Session) but is no longer associated with it. This typically happens when:</p>
<ul>
    <li>The persistence context is closed</li>
    <li>The entity is explicitly detached using <code>detach()</code>/<code>evict()</code></li>
    <li>The transaction or session is committed and closed</li>
</ul>
<p><strong>Characteristics of detached entities:</strong></p>
<ul>
    <li>They still have database identity (ID values)</li>
    <li>Changes to detached entities are not automatically synchronized to the database</li>
    <li>Lazy associations cannot be loaded (LazyInitializationException)</li>
</ul>
<p><strong>Reattaching detached entities:</strong></p>
<ol>
    <li><strong>Using merge():</strong> The preferred method for reattaching detached entities</li>
</ol>
<pre><code class="language-java">// entity is detached here
Employee updatedEmployee = entityManager.merge(entity);
// Now updatedEmployee is managed (not the original entity)
</code></pre>
<ol start="2">
    <li><strong>Using update() (Hibernate-specific):</strong></li>
</ol>
<pre><code class="language-java">// Hibernate Session API (not JPA)
Session session = entityManager.unwrap(Session.class);
session.update(entity);
// Now entity is managed
</code></pre>
<ol start="3">
    <li><strong>Using saveOrUpdate() (Hibernate-specific):</strong></li>
</ol>
<pre><code class="language-java">Session session = entityManager.unwrap(Session.class);
session.saveOrUpdate(entity);
// Now entity is managed
</code></pre>
<p><strong>Key differences between merge() and update():</strong></p>
<ul>
    <li><code>merge()</code> returns a new managed instance, leaving the original detached</li>
    <li><code>update()</code> makes the provided instance managed</li>
    <li><code>merge()</code> is part of JPA, while <code>update()</code> is Hibernate-specific</li>
    <li><code>merge()</code> can handle both transient and detached entities</li>
</ul>
<p>When working with detached entities, be aware of possible optimistic locking issues when multiple users modify the same data.</p>
<h3 id="18-what-is-the-difference-between-save-and-persist-methods-in-hibernate">18. What is the difference between save() and persist() methods in Hibernate?</h3>
<p><strong>Answer:</strong> Both <code>save()</code> and <code>persist()</code> methods are used to store entities in the database, but they have important differences:</p>
<p><strong>persist() method:</strong></p>
<ul>
    <li>Part of JPA specification, available in both EntityManager and Session</li>
    <li>Void return type (doesn&#39;t return anything)</li>
    <li>Makes a transient instance persistent and associates it with the session</li>
    <li>Doesn&#39;t guarantee that the identifier value is assigned immediately</li>
    <li>Throws exception if entity already has an identifier</li>
    <li>Entity will be saved when transaction is committed or session is flushed</li>
    <li>Object state transitions: transient → persistent</li>
</ul>
<p><strong>save() method:</strong></p>
<ul>
    <li>Hibernate-specific, only available in Session API (not in JPA&#39;s EntityManager)</li>
    <li>Returns the generated identifier (primary key)</li>
    <li>Immediately assigns an identifier (if using identity generation)</li>
    <li>Can be used outside of a transaction</li>
    <li>Object state transitions: transient → persistent</li>
</ul>
<p><strong>Example using persist():</strong></p>
<pre><code class="language-java">Employee employee = new Employee(&quot;John Doe&quot;);
entityManager.persist(employee); // No return value
// ID might not be assigned until flush/commit
System.out.println(employee.getId()); // Might be null if not using IDENTITY generator
</code></pre>
<p><strong>Example using save():</strong></p>
<pre><code class="language-java">Employee employee = new Employee(&quot;John Doe&quot;);
Long id = (Long) session.save(employee); // Returns the ID
// ID is assigned immediately
System.out.println(employee.getId()); // Will have a value
System.out.println(id); // Same as employee.getId()
</code></pre>
<p><strong>When to use which:</strong></p>
<ul>
    <li>Prefer <code>persist()</code> for JPA-compliant applications and better portability</li>
    <li>Use <code>save()</code> when you specifically need the generated ID immediately</li>
    <li>In most scenarios, especially within transactions, they behave similarly</li>
</ul>
<h3 id="19-what-are-value-types-and-embeddable-objects-in-jpahibernate">19. What are value types and embeddable objects in JPA/Hibernate?</h3>
<p><strong>Answer:</strong> In JPA/Hibernate, value types (or embeddable objects) are non-entity classes that don&#39;t have their own identity and are completely owned by an entity. They&#39;re used to group related fields and provide better code organization.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
    <li>Don&#39;t have their own database identity (no @Id)</li>
    <li>Cannot exist independently of their owning entity</li>
    <li>Are persisted as part of the owning entity&#39;s table</li>
    <li>Can be reused across multiple entities</li>
</ul>
<p><strong>Embeddable objects are defined with <code>@Embeddable</code> and used with <code>@Embedded</code>:</strong></p>
<pre><code class="language-java">@Embeddable
public class Address {
    private String street;
    private String city;
    private String zipCode;
    private String country;

    // Constructors, getters, setters, equals, hashCode
}

@Entity
public class Employee {
    @Id
    @GeneratedValue
    private Long id;
    private String name;

    @Embedded
    private Address address;

    // Constructors, getters, setters
}

@Entity
public class Company {
    @Id
    @GeneratedValue
    private Long id;
    private String name;

    @Embedded
    private Address address;

    // Constructors, getters, setters
}
</code></pre>
<p><strong>Column name customization:</strong>
    You can override column names using <code>@AttributeOverrides</code>:</p>
<pre><code class="language-java">@Entity
public class Company {
    @Id
    @GeneratedValue
    private Long id;
    private String name;

    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name = &quot;street&quot;, column = @Column(name = &quot;company_street&quot;)),
        @AttributeOverride(name = &quot;city&quot;, column = @Column(name = &quot;company_city&quot;)),
        @AttributeOverride(name = &quot;zipCode&quot;, column = @Column(name = &quot;company_zip_code&quot;)),
        @AttributeOverride(name = &quot;country&quot;, column = @Column(name = &quot;company_country&quot;))
    })
    private Address address;

    // Constructors, getters, setters
}
</code></pre>
<p>Value types help implement Domain-Driven Design value objects and improve code organization by grouping related attributes.</p>
<h3 id="20-how-do-you-map-inheritance-hierarchies-in-jpahibernate">20. How do you map inheritance hierarchies in JPA/Hibernate?</h3>
<p><strong>Answer:</strong> JPA provides three main strategies for mapping entity inheritance hierarchies:</p>
<p><strong>1. Single Table Strategy</strong> (default):</p>
<ul>
    <li>All classes in the hierarchy map to one table</li>
    <li>Discriminator column identifies which class a row belongs to</li>
    <li>Simple and typically best performance</li>
    <li>Drawback: Nullable columns for subclass fields</li>
</ul>
<pre><code class="language-java">@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = &quot;employee_type&quot;)
public abstract class Employee {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    // Getters and setters
}

@Entity
@DiscriminatorValue(&quot;FTE&quot;)
public class FullTimeEmployee extends Employee {
    private BigDecimal salary;
    private int vacationDays;
    // Getters and setters
}

@Entity
@DiscriminatorValue(&quot;CONTRACT&quot;)
public class ContractEmployee extends Employee {
    private BigDecimal hourlyRate;
    private String contractPeriod;
    // Getters and setters
}
</code></pre>
<p><strong>2. Joined Table Strategy</strong>:</p>
<ul>
    <li>Base class and each subclass get their own table</li>
    <li>Foreign key relationships link subclass tables to the parent</li>
    <li>Normalized approach, no null columns</li>
    <li>Requires joins for retrieving subclass entities (slower retrieval)</li>
</ul>
<pre><code class="language-java">@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class Employee {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    // Getters and setters
}

@Entity
public class FullTimeEmployee extends Employee {
    private BigDecimal salary;
    private int vacationDays;
    // Getters and setters
}

@Entity
public class ContractEmployee extends Employee {
    private BigDecimal hourlyRate;
    private String contractPeriod;
    // Getters and setters
}
</code></pre>
<p><strong>3. Table Per Class Strategy</strong>:</p>
<ul>
    <li>Each concrete class gets its own table with all properties</li>
    <li>No discriminator needed</li>
    <li>Duplicate columns in subclass tables</li>
    <li>Polymorphic queries may use UNION operations (potentially slow)</li>
</ul>
<pre><code class="language-java">@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Employee {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    // Getters and setters
}

@Entity
public class FullTimeEmployee extends Employee {
    private BigDecimal salary;
    private int vacationDays;
    // Getters and setters
}

@Entity
public class ContractEmployee extends Employee {
    private BigDecimal hourlyRate;
    private String contractPeriod;
    // Getters and setters
}
</code></pre>
<p><strong>Strategy selection considerations:</strong></p>
<ul>
    <li>Single Table: Best performance, less complexity, but less data integrity</li>
    <li>Joined Table: Better data integrity, normalized structure, but slower queries</li>
    <li>Table Per Class: Independent tables, intuitive structure, but potentially poor performance for polymorphic queries</li>
</ul>
<p>The choice depends on your specific requirements regarding performance, data integrity, and query patterns.</p>

<h3 id="21-what-is-jpql-and-how-does-it-differ-from-sql">21. What is JPQL and how does it differ from SQL?</h3>
<p><strong>Answer:</strong> JPQL (Java Persistence Query Language) is an object-oriented query language used to query entities and their relationships in JPA. It&#39;s similar to SQL in syntax but operates on entity objects rather than database tables.</p>
<p>Key differences between JPQL and SQL:</p>
<ol>
    <li><strong>Object-Oriented</strong>: JPQL queries work with entity objects and their properties, not tables and columns</li>
    <li><strong>Database Independence</strong>: JPQL is translated to the native SQL dialect of the underlying database</li>
    <li><strong>Entity References</strong>: JPQL uses entity names instead of table names</li>
    <li><strong>Property References</strong>: JPQL uses object property names instead of column names</li>
    <li><strong>Implicit Joins</strong>: JPQL can navigate entity relationships using dot notation</li>
    <li><strong>Polymorphism Support</strong>: JPQL queries can return entities of a specific type and its subtypes</li>
</ol>
<p>Example JPQL query:</p>
<pre><code class="language-java">// JPQL
String jpql = &quot;SELECT e FROM Employee e WHERE e.department.name = :deptName&quot;;
TypedQuery&lt;Employee&gt; query = entityManager.createQuery(jpql, Employee.class);
query.setParameter(&quot;deptName&quot;, &quot;Engineering&quot;);
List&lt;Employee&gt; employees = query.getResultList();

// Equivalent SQL would be
// SELECT e.* FROM employee e JOIN department d ON e.department_id = d.id WHERE d.name = &#39;Engineering&#39;
</code></pre>
<p>JPQL provides a database-independent way to query JPA entities while leveraging the object-oriented nature of Java applications.</p>
<h3 id="22-what-are-the-different-types-of-queries-in-jpahibernate">22. What are the different types of queries in JPA/Hibernate?</h3>
<p><strong>Answer:</strong> JPA/Hibernate supports several types of queries for retrieving data:</p>
<ol>
    <li><p><strong>JPQL Queries</strong>:</p>
        <ul>
            <li>Object-oriented queries based on entity model</li>
            <li><pre><code class="language-java">TypedQuery&lt;Employee&gt; query = entityManager.createQuery(
    &quot;SELECT e FROM Employee e WHERE e.salary &gt; :minSalary&quot;, Employee.class);
query.setParameter(&quot;minSalary&quot;, new BigDecimal(&quot;50000&quot;));
List&lt;Employee&gt; employees = query.getResultList();
</code></pre>
            </li>
        </ul>
    </li>
    <li><p><strong>Criteria API Queries</strong>:</p>
        <ul>
            <li>Type-safe, programmatic way to build queries</li>
            <li><pre><code class="language-java">CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery&lt;Employee&gt; cq = cb.createQuery(Employee.class);
Root&lt;Employee&gt; employee = cq.from(Employee.class);
cq.select(employee).where(cb.greaterThan(employee.get(&quot;salary&quot;), new BigDecimal(&quot;50000&quot;)));
List&lt;Employee&gt; employees = entityManager.createQuery(cq).getResultList();
</code></pre>
            </li>
        </ul>
    </li>
    <li><p><strong>Native SQL Queries</strong>:</p>
        <ul>
            <li>Database-specific SQL queries</li>
            <li><pre><code class="language-java">Query query = entityManager.createNativeQuery(
    &quot;SELECT * FROM employee WHERE salary &gt; ?&quot;, Employee.class);
query.setParameter(1, new BigDecimal(&quot;50000&quot;));
List&lt;Employee&gt; employees = query.getResultList();
</code></pre>
            </li>
        </ul>
    </li>
    <li><p><strong>Named Queries</strong>:</p>
        <ul>
            <li>Pre-defined queries in entity classes or mapping files</li>
            <li><pre><code class="language-java">@Entity
@NamedQuery(name = &quot;Employee.findBySalaryGreaterThan&quot;,
           query = &quot;SELECT e FROM Employee e WHERE e.salary &gt; :minSalary&quot;)
public class Employee {
    // Fields, getters, setters
}

// Usage
TypedQuery&lt;Employee&gt; query = entityManager.createNamedQuery(
    &quot;Employee.findBySalaryGreaterThan&quot;, Employee.class);
query.setParameter(&quot;minSalary&quot;, new BigDecimal(&quot;50000&quot;));
List&lt;Employee&gt; employees = query.getResultList();
</code></pre>
            </li>
        </ul>
    </li>
    <li><p><strong>Hibernate Query Language (HQL)</strong>:</p>
        <ul>
            <li>Hibernate-specific extension of JPQL</li>
            <li><pre><code class="language-java">// Using Hibernate Session
Session session = entityManager.unwrap(Session.class);
org.hibernate.query.Query&lt;Employee&gt; query = session.createQuery(
    &quot;from Employee e where e.salary &gt; :minSalary&quot;, Employee.class);
query.setParameter(&quot;minSalary&quot;, new BigDecimal(&quot;50000&quot;));
List&lt;Employee&gt; employees = query.list();
</code></pre>
            </li>
        </ul>
    </li>
    <li><p><strong>Method Query</strong> (Spring Data JPA):</p>
        <ul>
            <li>Queries derived from method names</li>
            <li><pre><code class="language-java">// In a Spring Data JPA repository interface
public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {
    List&lt;Employee&gt; findBySalaryGreaterThan(BigDecimal minSalary);
}

// Usage
List&lt;Employee&gt; employees = employeeRepository.findBySalaryGreaterThan(new BigDecimal(&quot;50000&quot;));
</code></pre>
            </li>
        </ul>
    </li>
</ol>
<p>Each query type has its strengths: JPQL for readability, Criteria API for type safety, native SQL for database-specific features, and named queries for reusability.</p>
<h3 id="23-how-do-you-implement-pagination-in-jpa-queries">23. How do you implement pagination in JPA queries?</h3>
<p><strong>Answer:</strong> Pagination in JPA queries allows retrieving a subset of results, which is essential for handling large result sets efficiently. JPA provides built-in pagination support through the <code>setFirstResult()</code> and <code>setMaxResults()</code> methods.</p>
<p><strong>Basic pagination implementation:</strong></p>
<pre><code class="language-java">// For a page size of 20 items per page
int pageSize = 20;
int pageNumber = 0; // Zero-based page index

TypedQuery&lt;Employee&gt; query = entityManager.createQuery(
    &quot;SELECT e FROM Employee e ORDER BY e.lastName&quot;, Employee.class);

// Set pagination parameters
query.setFirstResult(pageNumber * pageSize); // Skip previous pages
query.setMaxResults(pageSize);               // Limit results count

// Execute query with pagination
List&lt;Employee&gt; employeesPage = query.getResultList();
</code></pre>
<p><strong>Pagination with Criteria API:</strong></p>
<pre><code class="language-java">CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery&lt;Employee&gt; cq = cb.createQuery(Employee.class);
Root&lt;Employee&gt; root = cq.from(Employee.class);
cq.select(root);
cq.orderBy(cb.asc(root.get(&quot;lastName&quot;)));

TypedQuery&lt;Employee&gt; query = entityManager.createQuery(cq);
query.setFirstResult(pageNumber * pageSize);
query.setMaxResults(pageSize);

List&lt;Employee&gt; employeesPage = query.getResultList();
</code></pre>
<p><strong>Getting total count for pagination UI:</strong></p>
<pre><code class="language-java">// Count query for total elements
TypedQuery&lt;Long&gt; countQuery = entityManager.createQuery(
    &quot;SELECT COUNT(e) FROM Employee e&quot;, Long.class);
Long totalElements = countQuery.getSingleResult();

// Calculate total pages
int totalPages = (int) Math.ceil((double) totalElements / pageSize);
</code></pre>
<p><strong>Spring Data JPA pagination:</strong></p>
<pre><code class="language-java">// In repository
public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {
    Page&lt;Employee&gt; findAll(Pageable pageable);
}

// Usage
Pageable pageable = PageRequest.of(pageNumber, pageSize, Sort.by(&quot;lastName&quot;));
Page&lt;Employee&gt; employeePage = employeeRepository.findAll(pageable);

// The Page object contains both data and metadata
List&lt;Employee&gt; employees = employeePage.getContent();
int totalPages = employeePage.getTotalPages();
long totalElements = employeePage.getTotalElements();
</code></pre>
<p>Effective pagination improves application performance and user experience when working with large datasets.</p>
<h3 id="24-what-is-the-criteria-api-in-jpa-and-when-would-you-use-it">24. What is the Criteria API in JPA and when would you use it?</h3>
<p><strong>Answer:</strong> The Criteria API is a type-safe, programmatic way of constructing JPA queries. It provides an alternative to string-based JPQL queries and is part of the JPA specification.</p>
<p><strong>Key features of Criteria API:</strong></p>
<ol>
    <li><strong>Type Safety</strong>: Catches many errors at compile time rather than runtime</li>
    <li><strong>Programmatic Query Building</strong>: Allows dynamic query construction</li>
    <li><strong>IDE Support</strong>: Better code completion and refactoring support</li>
    <li><strong>No String Concatenation</strong>: Avoids error-prone string manipulation</li>
    <li><strong>Metamodel Support</strong>: Can use generated metamodel classes for even stronger type safety</li>
</ol>
<p><strong>Basic Criteria API example:</strong></p>
<pre><code class="language-java">CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery&lt;Employee&gt; cq = cb.createQuery(Employee.class);
Root&lt;Employee&gt; employee = cq.from(Employee.class);
cq.select(employee);

// Adding where clause
cq.where(
    cb.and(
        cb.equal(employee.get(&quot;department&quot;).get(&quot;name&quot;), &quot;IT&quot;),
        cb.greaterThan(employee.get(&quot;salary&quot;), new BigDecimal(50000))
    )
);

// Adding order by
cq.orderBy(cb.desc(employee.get(&quot;lastName&quot;)));

TypedQuery&lt;Employee&gt; query = entityManager.createQuery(cq);
List&lt;Employee&gt; results = query.getResultList();
</code></pre>
<p><strong>Use cases for Criteria API:</strong></p>
<ol>
    <li><p><strong>Dynamic Queries</strong>: When query conditions need to be built at runtime</p>
        <pre><code class="language-java">CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery&lt;Employee&gt; cq = cb.createQuery(Employee.class);
Root&lt;Employee&gt; employee = cq.from(Employee.class);
cq.select(employee);

List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();

if (firstName != null) {
    predicates.add(cb.equal(employee.get(&quot;firstName&quot;), firstName));
}

if (lastName != null) {
    predicates.add(cb.equal(employee.get(&quot;lastName&quot;), lastName));
}

if (minSalary != null) {
    predicates.add(cb.greaterThanOrEqualTo(employee.get(&quot;salary&quot;), minSalary));
}

cq.where(predicates.toArray(new Predicate[0]));
TypedQuery&lt;Employee&gt; query = entityManager.createQuery(cq);
List&lt;Employee&gt; results = query.getResultList();
</code></pre>
    </li>
    <li><p><strong>Complex Joins</strong>: For queries with multiple joins and conditions</p>
    </li>
    <li><p><strong>Projections</strong>: When selecting specific properties rather than whole entities</p>
    </li>
    <li><p><strong>Aggregate Functions</strong>: For queries involving counts, sums, etc.</p>
    </li>
    <li><p><strong>Subqueries</strong>: When queries need to reference other queries</p>
    </li>
</ol>
<p>The Criteria API is particularly useful in complex enterprise applications where queries need to be built dynamically based on user input or application state.</p>
<h3 id="25-what-is-the-difference-between-getreference-and-find-in-entitymanager">25. What is the difference between getReference() and find() in EntityManager?</h3>
<p><strong>Answer:</strong> Both <code>find()</code> and <code>getReference()</code> methods in EntityManager are used to retrieve entities by their primary key, but they have important differences in behavior:</p>
<p><strong>find() method:</strong></p>
<ul>
    <li>Immediately hits the database to retrieve the entity</li>
    <li>Returns null if the entity doesn&#39;t exist</li>
    <li>Always returns a fully initialized entity object</li>
    <li>Used when you need the entity object immediately</li>
</ul>
<pre><code class="language-java">// Immediate database access
Employee employee = entityManager.find(Employee.class, 101L);
if (employee != null) {
    System.out.println(employee.getName()); // No additional query needed
}
</code></pre>
<p><strong>getReference() method:</strong></p>
<ul>
    <li>Returns a proxy (reference) to the entity without hitting the database immediately</li>
    <li>Actual database access is deferred until a non-identifier method is accessed on the entity</li>
    <li>Throws EntityNotFoundException if the entity doesn&#39;t exist when actually accessed</li>
    <li>Primarily used for setting relationships when you only need the reference (foreign key)</li>
</ul>
<pre><code class="language-java">// No immediate database access
Employee employee = entityManager.getReference(Employee.class, 101L);
// Assignment to a relationship doesn&#39;t trigger database access
Department dept = entityManager.find(Department.class, 1L);
dept.setManager(employee); // Only needs the ID, no query needed

// Database query happens here when a non-ID property is accessed
System.out.println(employee.getName()); // Triggers database access now
</code></pre>
<p><strong>Key differences summarized:</strong></p>
<ol>
    <li><p><strong>Timing of Database Access</strong>:</p>
        <ul>
            <li><code>find()</code>: Immediate</li>
            <li><code>getReference()</code>: Lazy/deferred until needed</li>
        </ul>
    </li>
    <li><p><strong>Return Value for Non-existent Entity</strong>:</p>
        <ul>
            <li><code>find()</code>: Returns null</li>
            <li><code>getReference()</code>: Returns proxy, throws EntityNotFoundException when accessed</li>
        </ul>
    </li>
    <li><p><strong>Use Cases</strong>:</p>
        <ul>
            <li><code>find()</code>: When you need the entity data immediately</li>
            <li><code>getReference()</code>: When setting relationships and performance matters</li>
        </ul>
    </li>
    <li><p><strong>Performance Implications</strong>:</p>
        <ul>
            <li><code>find()</code>: More expensive upfront</li>
            <li><code>getReference()</code>: More efficient when just needing relationships/foreign keys</li>
        </ul>
    </li>
</ol>
<p>Choosing between them depends on whether you need immediate access to entity data or if you&#39;re just establishing relationships between entities.</p>
<h3 id="26-what-are-projections-in-jpa-and-how-do-you-implement-them">26. What are projections in JPA and how do you implement them?</h3>
<p><strong>Answer:</strong> Projections in JPA are a way to retrieve only specific fields or computed values from entities rather than the entire entity objects. This can significantly improve performance when you only need a subset of data.</p>
<p><strong>Types of projections in JPA:</strong></p>
<ol>
    <li><p><strong>Interface-based Projections</strong>:</p>
        <pre><code class="language-java">// Define projection interface
public interface EmployeeNameView {
    String getFirstName();
    String getLastName();
}

// Query using projection
TypedQuery&lt;EmployeeNameView&gt; query = entityManager.createQuery(
    &quot;SELECT new com.example.EmployeeNameView(e.firstName, e.lastName) FROM Employee e&quot;,
    EmployeeNameView.class);
List&lt;EmployeeNameView&gt; results = query.getResultList();
</code></pre>
    </li>
    <li><p><strong>Constructor Expressions</strong>:</p>
        <pre><code class="language-java">// DTO class
public class EmployeeDTO {
    private final String firstName;
    private final String lastName;

    public EmployeeDTO(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    // Getters
}

// Query with constructor expression
TypedQuery&lt;EmployeeDTO&gt; query = entityManager.createQuery(
    &quot;SELECT new com.example.EmployeeDTO(e.firstName, e.lastName) FROM Employee e&quot;,
    EmployeeDTO.class);
List&lt;EmployeeDTO&gt; results = query.getResultList();
</code></pre>
    </li>
    <li><p><strong>Object Arrays</strong>:</p>
        <pre><code class="language-java">TypedQuery&lt;Object[]&gt; query = entityManager.createQuery(
    &quot;SELECT e.firstName, e.lastName, e.salary FROM Employee e&quot;, Object[].class);
List&lt;Object[]&gt; results = query.getResultList();

for (Object[] result : results) {
    String firstName = (String) result[0];
    String lastName = (String) result[1];
    BigDecimal salary = (BigDecimal) result[2];
}
</code></pre>
    </li>
    <li><p><strong>Single Value Projections</strong>:</p>
        <pre><code class="language-java">TypedQuery&lt;String&gt; query = entityManager.createQuery(
    &quot;SELECT e.firstName FROM Employee e WHERE e.id = :id&quot;, String.class);
query.setParameter(&quot;id&quot;, 101L);
String firstName = query.getSingleResult();
</code></pre>
    </li>
    <li><p><strong>Dynamic Projections (Criteria API)</strong>:</p>
        <pre><code class="language-java">CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery&lt;Tuple&gt; cq = cb.createTupleQuery();
Root&lt;Employee&gt; employee = cq.from(Employee.class);

cq.multiselect(
    employee.get(&quot;firstName&quot;).alias(&quot;firstName&quot;),
    employee.get(&quot;lastName&quot;).alias(&quot;lastName&quot;),
    employee.get(&quot;salary&quot;).alias(&quot;salary&quot;)
);

TypedQuery&lt;Tuple&gt; query = entityManager.createQuery(cq);
List&lt;Tuple&gt; results = query.getResultList();

for (Tuple tuple : results) {
    String firstName = tuple.get(&quot;firstName&quot;, String.class);
    String lastName = tuple.get(&quot;lastName&quot;, String.class);
    BigDecimal salary = tuple.get(&quot;salary&quot;, BigDecimal.class);
}
</code></pre>
    </li>
</ol>
<p><strong>Benefits of projections:</strong></p>
<ol>
    <li><strong>Performance</strong>: Reduced memory usage and faster queries by retrieving only necessary data</li>
    <li><strong>Network efficiency</strong>: Less data transferred from database to application</li>
    <li><strong>Focus</strong>: Direct mapping to DTOs for specific use cases</li>
</ol>
<p>Projections are particularly useful for read-only operations, reports, and API responses where complete entities aren&#39;t needed.</p>
<h3 id="27-what-is-the-n1-query-problem-and-how-do-you-solve-it">27. What is the N+1 query problem and how do you solve it?</h3>
<p><strong>Answer:</strong> The N+1 query problem is a common performance issue in ORM frameworks like Hibernate where loading a collection of N parent entities results in N additional queries to fetch their child entities (1 query for parent entities + N queries for child collections = N+1 queries).</p>
<p><strong>Example of N+1 problem:</strong></p>
<pre><code class="language-java">// Initial query to get all departments (1 query)
List&lt;Department&gt; departments = entityManager.createQuery(
    &quot;SELECT d FROM Department d&quot;, Department.class).getResultList();

// For each department, when accessing employees, Hibernate executes an additional query (N queries)
for (Department dept : departments) {
    System.out.println(&quot;Department: &quot; + dept.getName());
    // This access triggers a lazy load - a separate query for each department
    System.out.println(&quot;Employee count: &quot; + dept.getEmployees().size());
}
</code></pre>
<p><strong>Solutions to the N+1 query problem:</strong></p>
<ol>
    <li><p><strong>Fetch Joins in JPQL</strong>:</p>
        <pre><code class="language-java">// Single query with fetch join
List&lt;Department&gt; departments = entityManager.createQuery(
    &quot;SELECT d FROM Department d LEFT JOIN FETCH d.employees&quot;, Department.class)
    .getResultList();

// Now no additional queries needed
for (Department dept : departments) {
    System.out.println(&quot;Department: &quot; + dept.getName());
    System.out.println(&quot;Employee count: &quot; + dept.getEmployees().size());
}
</code></pre>
    </li>
    <li><p><strong>Entity Graphs</strong>:</p>
        <pre><code class="language-java">// Define entity graph on entity
@Entity
@NamedEntityGraph(name = &quot;Department.employees&quot;,
    attributeNodes = @NamedAttributeNode(&quot;employees&quot;))
public class Department {
    // Fields, getters, setters
}

// Use entity graph in query
EntityGraph&lt;?&gt; graph = entityManager.getEntityGraph(&quot;Department.employees&quot;);
Map&lt;String, Object&gt; hints = new HashMap&lt;&gt;();
hints.put(&quot;javax.persistence.fetchgraph&quot;, graph);

List&lt;Department&gt; departments = entityManager.createQuery(
    &quot;SELECT d FROM Department d&quot;, Department.class)
    .setHint(&quot;javax.persistence.fetchgraph&quot;, graph)
    .getResultList();
</code></pre>
    </li>
    <li><p><strong>Batch Fetching</strong>:</p>
        <pre><code class="language-java">// Configure batch fetching in entity
@Entity
public class Department {
    @Id
    private Long id;

    @BatchSize(size = 25)  // Or configure globally in hibernate.properties
    @OneToMany(mappedBy = &quot;department&quot;)
    private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();

    // Getters and setters
}
</code></pre>
    </li>
    <li><p><strong>DTO Projections</strong>:</p>
        <pre><code class="language-java">// Create DTO with necessary data
public class DepartmentSummaryDTO {
    private final String name;
    private final int employeeCount;

    public DepartmentSummaryDTO(String name, int employeeCount) {
        this.name = name;
        this.employeeCount = employeeCount;
    }

    // Getters
}

// Single optimized query
List&lt;DepartmentSummaryDTO&gt; summaries = entityManager.createQuery(
    &quot;SELECT new com.example.DepartmentSummaryDTO(d.name, SIZE(d.employees)) &quot; +
    &quot;FROM Department d&quot;, DepartmentSummaryDTO.class).getResultList();
</code></pre>
    </li>
    <li><p><strong>Join fetching with Criteria API</strong>:</p>
        <pre><code class="language-java">CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery&lt;Department&gt; cq = cb.createQuery(Department.class);
Root&lt;Department&gt; dept = cq.from(Department.class);
dept.fetch(&quot;employees&quot;, JoinType.LEFT);
cq.select(dept);

List&lt;Department&gt; departments = entityManager.createQuery(cq).getResultList();
</code></pre>
    </li>
</ol>
<p>The N+1 query problem can significantly impact performance in applications with many relationships. Choosing the appropriate solution depends on the specific use case, data volume, and access patterns.</p>
<h3 id="28-what-are-the-different-types-of-caching-in-hibernate">28. What are the different types of caching in Hibernate?</h3>
<p><strong>Answer:</strong> Hibernate provides multiple levels of caching to improve application performance by reducing database access:</p>
<ol>
    <li><p><strong>First-Level Cache (Session/Persistence Context Cache)</strong>:</p>
        <ul>
            <li>Enabled by default, cannot be disabled</li>
            <li>Scoped to a single <code>Session</code>/<code>EntityManager</code> instance</li>
            <li>Ensures that the same entity instance is returned for the same database row within a session</li>
            <li>Manages entity state and identity within transactions</li>
            <li>Automatically cleared when session is closed</li>
        </ul>
        <pre><code class="language-java">// First query hits the database
Employee emp1 = entityManager.find(Employee.class, 101L);

// Second query uses the first-level cache (no database hit)
Employee emp2 = entityManager.find(Employee.class, 101L);

// emp1 and emp2 are the same Java object
System.out.println(emp1 == emp2); // true
</code></pre>
    </li>
    <li><p><strong>Second-Level Cache</strong>:</p>
        <ul>
            <li>Optional, disabled by default</li>
            <li>Shared across all sessions/entity managers in an application</li>
            <li>Configured at the SessionFactory/EntityManagerFactory level</li>
            <li>Can be enabled for specific entities and collections</li>
            <li>Multiple cache providers: EHCache, Infinispan, Hazelcast, etc.</li>
        </ul>
        <p>Configuration:</p>
        <pre><code class="language-java">// In persistence.xml
&lt;property name=&quot;hibernate.cache.use_second_level_cache&quot; value=&quot;true&quot;/&gt;
&lt;property name=&quot;hibernate.cache.region.factory_class&quot;
          value=&quot;org.hibernate.cache.ehcache.EhCacheRegionFactory&quot;/&gt;

// Entity configuration
@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Employee {
    // Fields, getters, setters
}
</code></pre>
        <p>Usage:</p>
        <pre><code class="language-java">// First session - hits the database
Employee emp1 = entityManager1.find(Employee.class, 101L);
entityManager1.close();

// Second session - retrieves from second-level cache (no database hit)
Employee emp2 = entityManager2.find(Employee.class, 101L);
</code></pre>
    </li>
    <li><p><strong>Query Cache</strong>:</p>
        <ul>
            <li>Caches the results of JPQL/HQL queries</li>
            <li>Must be explicitly enabled</li>
            <li>Requires second-level cache to be enabled</li>
            <li>Caches query results by query string and parameters</li>
        </ul>
        <p>Configuration:</p>
        <pre><code class="language-java">// In persistence.xml
&lt;property name=&quot;hibernate.cache.use_query_cache&quot; value=&quot;true&quot;/&gt;
</code></pre>
        <p>Usage:</p>
        <pre><code class="language-java">TypedQuery&lt;Employee&gt; query = entityManager.createQuery(
    &quot;SELECT e FROM Employee e WHERE e.department.name = :deptName&quot;, Employee.class);
query.setParameter(&quot;deptName&quot;, &quot;IT&quot;);
query.setHint(&quot;org.hibernate.cacheable&quot;, true);
List&lt;Employee&gt; employees = query.getResultList();
</code></pre>
    </li>
    <li><p><strong>Collection Cache</strong>:</p>
        <ul>
            <li>Caches collections of entities (one-to-many, many-to-many)</li>
            <li>Must be explicitly configured</li>
        </ul>
        <pre><code class="language-java">@Entity
public class Department {
    @Id
    private Long id;

    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    @OneToMany(mappedBy = &quot;department&quot;)
    private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();

    // Getters and setters
}
</code></pre>
    </li>
</ol>
<p><strong>Cache Concurrency Strategies</strong>:</p>
<ul>
    <li><strong>READ_ONLY</strong>: For reference data that never changes</li>
    <li><strong>NONSTRICT_READ_WRITE</strong>: For data that rarely changes, with no strict transaction isolation</li>
    <li><strong>READ_WRITE</strong>: For read-mostly data with strict transaction isolation</li>
    <li><strong>TRANSACTIONAL</strong>: For full transaction support with JTA</li>
</ul>
<p>Caching can dramatically improve application performance but requires careful consideration of data update patterns and consistency requirements.</p>
<h3 id="29-how-do-you-execute-native-sql-queries-in-jpa">29. How do you execute native SQL queries in JPA?</h3>
<p><strong>Answer:</strong> JPA provides the ability to execute native SQL queries when you need database-specific features or optimizations that aren&#39;t available through JPQL. There are several ways to execute native SQL queries:</p>
<p><strong>1. Basic Native Query (returning entities)</strong>:</p>
<pre><code class="language-java">// Native SQL query mapped to entity
Query query = entityManager.createNativeQuery(
    &quot;SELECT * FROM employees WHERE department_id = ?&quot;, Employee.class);
query.setParameter(1, departmentId);
List&lt;Employee&gt; employees = query.getResultList();
</code></pre>
<p><strong>2. Native Query with Custom Result Mapping</strong>:</p>
<pre><code class="language-java">// Define SQL result set mapping in entity
@Entity
@SqlResultSetMapping(
    name = &quot;EmployeeSummaryMapping&quot;,
    classes = @ConstructorResult(
        targetClass = EmployeeSummary.class,
        columns = {
            @ColumnResult(name = &quot;id&quot;, type = Long.class),
            @ColumnResult(name = &quot;full_name&quot;, type = String.class),
            @ColumnResult(name = &quot;salary&quot;, type = BigDecimal.class)
        }
    )
)
public class Employee {
    // Fields, getters, setters
}

// Use result set mapping
Query query = entityManager.createNativeQuery(
    &quot;SELECT e.id, CONCAT(e.first_name, &#39; &#39;, e.last_name) AS full_name, e.salary &quot; +
    &quot;FROM employees e WHERE e.department_id = ?&quot;,
    &quot;EmployeeSummaryMapping&quot;);
query.setParameter(1, departmentId);
List&lt;EmployeeSummary&gt; results = query.getResultList();
</code></pre>
<p><strong>3. Native Query Returning Scalar Values</strong>:</p>
<pre><code class="language-java">// Get scalar values
Query query = entityManager.createNativeQuery(
    &quot;SELECT COUNT(*), AVG(salary) FROM employees WHERE department_id = ?&quot;);
query.setParameter(1, departmentId);
Object[] result = (Object[]) query.getSingleResult();
Long count = ((Number) result[0]).longValue();
Double avgSalary = ((Number) result[1]).doubleValue();
</code></pre>
<p><strong>4. Named Native Query</strong>:</p>
<pre><code class="language-java">// Define named native query in entity
@Entity
@NamedNativeQuery(
    name = &quot;Employee.findByDepartmentNative&quot;,
    query = &quot;SELECT * FROM employees WHERE department_id = ?&quot;,
    resultClass = Employee.class
)
public class Employee {
    // Fields, getters, setters
}

// Use named native query
Query query = entityManager.createNamedQuery(&quot;Employee.findByDepartmentNative&quot;);
query.setParameter(1, departmentId);
List&lt;Employee&gt; employees = query.getResultList();
</code></pre>
<p><strong>5. Native Query with Pagination</strong>:</p>
<pre><code class="language-java">Query query = entityManager.createNativeQuery(
    &quot;SELECT * FROM employees ORDER BY last_name, first_name&quot;,
    Employee.class);
query.setFirstResult(pageNumber * pageSize);
query.setMaxResults(pageSize);
List&lt;Employee&gt; employees = query.getResultList();
</code></pre>
<p><strong>6. Native Query with Hibernate Session API</strong>:</p>
<pre><code class="language-java">Session session = entityManager.unwrap(Session.class);
NativeQuery&lt;Employee&gt; query = session.createNativeQuery(
    &quot;SELECT * FROM employees WHERE salary &gt; :minSalary&quot;, Employee.class);
query.setParameter(&quot;minSalary&quot;, new BigDecimal(&quot;50000&quot;));
List&lt;Employee&gt; employees = query.list();
</code></pre>
<p><strong>Considerations when using native SQL queries</strong>:</p>
<ol>
    <li><strong>Portability</strong>: Native queries are database-specific and can reduce application portability</li>
    <li><strong>Maintenance</strong>: Changes in entity structure may not be reflected in native queries</li>
    <li><strong>Type Safety</strong>: Native queries lack the type safety of JPQL or Criteria API</li>
    <li><strong>Performance</strong>: Native queries can be more performant for complex operations</li>
    <li><strong>Special Features</strong>: Allows access to database-specific features not available in JPQL</li>
</ol>
<p>Use native queries when you need database-specific optimizations or features, but prefer JPQL for standard operations to maintain portability.</p>
<h3 id="30-what-is-the-flush-method-in-entitymanager-and-when-would-you-use-it">30. What is the flush() method in EntityManager and when would you use it?</h3>
<p><strong>Answer:</strong> The <code>flush()</code> method in EntityManager synchronizes the persistence context with the underlying database, applying all pending entity state changes (inserts, updates, deletes) without committing the transaction. It&#39;s part of the JPA specification and is important for controlling when changes are sent to the database.</p>
<p><strong>How flush() works:</strong></p>
<ol>
    <li>Detects changes made to managed entities</li>
    <li>Performs dirty checking to identify modified entities</li>
    <li>Generates and executes appropriate SQL statements</li>
    <li>Updates entity state to reflect database changes</li>
    <li>Does NOT commit the transaction</li>
</ol>
<p><strong>Example of using flush():</strong></p>
<pre><code class="language-java">// Start transaction
entityManager.getTransaction().begin();

// Make some changes
Employee employee = entityManager.find(Employee.class, 101L);
employee.setSalary(new BigDecimal(&quot;55000&quot;));

// Add a new entity
Department newDept = new Department(&quot;Research&quot;);
entityManager.persist(newDept);

// Flush changes to the database before querying
entityManager.flush();

// Now we can query the database and see our changes,
// even though the transaction hasn&#39;t been committed
BigDecimal avgSalary = entityManager.createQuery(
    &quot;SELECT AVG(e.salary) FROM Employee e&quot;, BigDecimal.class)
    .getSingleResult();

// Commit or rollback as needed
entityManager.getTransaction().commit();
</code></pre>
<p><strong>When to use flush():</strong></p>
<ol>
    <li><p><strong>Before Queries</strong>: To ensure queries see the latest changes</p>
        <pre><code class="language-java">employee.setSalary(new BigDecimal(&quot;60000&quot;));
// Need to flush before query to see the updated salary in results
entityManager.flush();
List&lt;Employee&gt; highestPaid = entityManager.createQuery(
    &quot;SELECT e FROM Employee e ORDER BY e.salary DESC&quot;, Employee.class)
    .setMaxResults(5)
    .getResultList();
</code></pre>
    </li>
    <li><p><strong>Batch Processing</strong>: To control memory usage during large operations</p>
        <pre><code class="language-java">entityManager.getTransaction().begin();
int batchSize = 50;
for (int i = 0; i &lt; 10000; i++) {
    Employee emp = new Employee(&quot;Employee&quot; + i);
    entityManager.persist(emp);
    if (i % batchSize == 0) {
        // Flush a batch of inserts and clear persistence context
        entityManager.flush();
        entityManager.clear();
    }
}
entityManager.getTransaction().commit();
</code></pre>
    </li>
    <li><p><strong>Error Checking</strong>: To detect constraint violations or other database errors earlier</p>
        <pre><code class="language-java">entityManager.getTransaction().begin();
try {
    Employee emp = new Employee(&quot;John Doe&quot;);
    emp.setEmail(&quot;existing.email@company.com&quot;); // Potentially duplicate email
    entityManager.persist(emp);
    entityManager.flush(); // Will throw exception if constraint violation occurs

    // More operations here that won&#39;t execute if flush() fails

    entityManager.getTransaction().commit();
} catch (Exception e) {
    entityManager.getTransaction().rollback();
    // Handle the exception
}
</code></pre>
    </li>
    <li><p><strong>Testing</strong>: To verify entity state without committing a transaction</p>
    </li>
</ol>
<p><strong>Flush modes:</strong></p>
<ul>
    <li><strong>AUTO</strong> (default): JPA provider determines when to flush (typically before queries, commit)</li>
    <li><strong>COMMIT</strong>: Only flush when transaction is committed (may lead to unexpected query results)</li>
</ul>
<pre><code class="language-java">// Changing flush mode
entityManager.setFlushMode(FlushModeType.COMMIT);
</code></pre>
<p>Understanding when and how to use <code>flush()</code> helps control transaction behavior and optimize performance in JPA applications.</p>

<h3 id="31-what-is-a-transaction-in-jpahibernate-and-why-is-it-important">31. What is a transaction in JPA/Hibernate and why is it important?</h3>
<p><strong>Answer:</strong> A transaction in JPA/Hibernate is a sequence of operations that are executed as a single unit of work. Either all operations complete successfully (commit) or none of them take effect (rollback), ensuring data consistency.</p>
<p><strong>Key transaction properties (ACID):</strong></p>
<ol>
    <li><strong>Atomicity</strong>: All operations complete successfully or none at all</li>
    <li><strong>Consistency</strong>: Database moves from one valid state to another</li>
    <li><strong>Isolation</strong>: Transactions are isolated from each other&#39;s intermediate states</li>
    <li><strong>Durability</strong>: Once committed, changes are permanent</li>
</ol>
<p><strong>JPA transaction management:</strong></p>
<pre><code class="language-java">// Using JPA transaction API
EntityTransaction tx = entityManager.getTransaction();
try {
    tx.begin();

    Employee employee = entityManager.find(Employee.class, 101L);
    employee.setSalary(employee.getSalary().multiply(new BigDecimal(&quot;1.1&quot;)));

    Department dept = new Department(&quot;Innovation Lab&quot;);
    entityManager.persist(dept);

    tx.commit();
} catch (Exception e) {
    if (tx != null &amp;&amp; tx.isActive()) {
        tx.rollback();
    }
    throw e;
}
</code></pre>
<p><strong>Spring transaction management:</strong></p>
<pre><code class="language-java">@Transactional
public void giveRaise(Long employeeId, BigDecimal percentage) {
    Employee employee = entityManager.find(Employee.class, employeeId);
    BigDecimal newSalary = employee.getSalary().multiply(
        BigDecimal.ONE.add(percentage.divide(new BigDecimal(100))));
    employee.setSalary(newSalary);

    // Transaction automatically committed if successful
    // or rolled back if exception occurs
}
</code></pre>
<p><strong>Importance of transactions:</strong></p>
<ol>
    <li><strong>Data Integrity</strong>: Ensures related changes are applied together</li>
    <li><strong>Concurrency Control</strong>: Manages multiple users accessing the same data</li>
    <li><strong>Error Recovery</strong>: Provides ability to rollback on failure</li>
    <li><strong>Consistent View</strong>: Gives a consistent view of data during operations</li>
    <li><strong>Business Rule Enforcement</strong>: Ensures business rules are applied atomically</li>
</ol>
<p>Transactions are essential for maintaining data consistency, especially in multi-user environments and when performing multiple related database operations.</p>
<h3 id="32-what-is-the-difference-between-resource_local-and-jta-transactions">32. What is the difference between RESOURCE_LOCAL and JTA transactions?</h3>
<p><strong>Answer:</strong> JPA supports two types of transaction management: RESOURCE_LOCAL and JTA (Java Transaction API), which differ in scope, control, and usage scenarios.</p>
<p><strong>RESOURCE_LOCAL Transactions:</strong></p>
<ul>
    <li>Manage transactions for a single database resource</li>
    <li>Controlled directly through the EntityManager</li>
    <li>Simpler to set up and use</li>
    <li>Typically used in standalone applications or simple web applications</li>
    <li>Not suitable for transactions spanning multiple resources</li>
</ul>
<pre><code class="language-java">// Configuration in persistence.xml
&lt;persistence-unit name=&quot;myPU&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;
    &lt;!-- Configuration details --&gt;
&lt;/persistence-unit&gt;

// Usage
EntityTransaction tx = entityManager.getTransaction();
try {
    tx.begin();
    // Database operations
    tx.commit();
} catch (Exception e) {
    if (tx != null &amp;&amp; tx.isActive()) {
        tx.rollback();
    }
    throw e;
}
</code></pre>
<p><strong>JTA Transactions:</strong></p>
<ul>
    <li>Support distributed transactions across multiple resources (databases, message queues, etc.)</li>
    <li>Managed by an application server or standalone JTA provider</li>
    <li>Can coordinate operations across multiple systems</li>
    <li>Typically used in enterprise applications</li>
    <li>Support XA protocol for two-phase commit</li>
</ul>
<pre><code class="language-java">// Configuration in persistence.xml
&lt;persistence-unit name=&quot;myPU&quot; transaction-type=&quot;JTA&quot;&gt;
    &lt;jta-data-source&gt;jdbc/MyDataSource&lt;/jta-data-source&gt;
    &lt;!-- Other configuration details --&gt;
&lt;/persistence-unit&gt;

// Usage in Java EE environment
@Stateless
public class EmployeeService {
    @PersistenceContext
    private EntityManager entityManager;

    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public void updateEmployeeAndSendMessage(Employee employee) {
        // Database operation using entityManager
        entityManager.merge(employee);

        // JMS operation or another resource
        jmsContext.createProducer().send(queue, &quot;Employee updated: &quot; + employee.getId());

        // Both operations will be committed or rolled back together
    }
}

// Spring JTA example
@Transactional
public void updateEmployeeAndSendMessage(Employee employee) {
    // Database operation
    entityManager.merge(employee);

    // JMS operation
    jmsTemplate.convertAndSend(&quot;employeeQueue&quot;, &quot;Employee updated: &quot; + employee.getId());
}
</code></pre>
<p><strong>Key Differences:</strong></p>
<ol>
    <li><p><strong>Scope</strong>:</p>
        <ul>
            <li>RESOURCE_LOCAL: Single resource (one database)</li>
            <li>JTA: Multiple resources (multiple databases, JMS queues, etc.)</li>
        </ul>
    </li>
    <li><p><strong>Control</strong>:</p>
        <ul>
            <li>RESOURCE_LOCAL: Directly controlled via EntityTransaction API</li>
            <li>JTA: Controlled by container or transaction manager</li>
        </ul>
    </li>
    <li><p><strong>Configuration</strong>:</p>
        <ul>
            <li>RESOURCE_LOCAL: Simpler configuration</li>
            <li>JTA: Requires JTA-compliant data sources and transaction manager</li>
        </ul>
    </li>
    <li><p><strong>Usage Context</strong>:</p>
        <ul>
            <li>RESOURCE_LOCAL: Standalone applications, simple web apps</li>
            <li>JTA: Enterprise applications requiring distributed transactions</li>
        </ul>
    </li>
    <li><p><strong>Performance</strong>:</p>
        <ul>
            <li>RESOURCE_LOCAL: Generally better performance for single-resource operations</li>
            <li>JTA: Additional overhead for transaction coordination</li>
        </ul>
    </li>
</ol>
<p>Choose RESOURCE_LOCAL for simple applications accessing a single database, and JTA when operations need to span multiple transactional resources.</p>
<h3 id="33-what-is-optimistic-locking-in-hibernate-and-how-do-you-implement-it">33. What is optimistic locking in Hibernate and how do you implement it?</h3>
<p><strong>Answer:</strong> Optimistic locking is a concurrency control strategy that assumes conflicts between transactions are rare. Rather than locking records during updates, it detects conflicts at commit time and prevents data corruption by rejecting conflicting changes.</p>
<p><strong>How optimistic locking works in Hibernate:</strong></p>
<ol>
    <li>Each entity gets a version attribute (number or timestamp)</li>
    <li>When an entity is loaded, its current version is noted</li>
    <li>When updating the entity, Hibernate includes the version in the WHERE clause</li>
    <li>If another transaction changed the entity, the version won&#39;t match</li>
    <li>Hibernate throws an OptimisticLockException when a version conflict occurs</li>
</ol>
<p><strong>Implementation using @Version annotation:</strong></p>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private BigDecimal salary;

    @Version
    private Long version;  // Can also use Integer, Short, Timestamp

    // Getters and setters
}
</code></pre>
<p><strong>Handling optimistic lock exceptions:</strong></p>
<pre><code class="language-java">EntityManager em = emf.createEntityManager();
try {
    em.getTransaction().begin();

    // Load the entity
    Employee employee = em.find(Employee.class, id);

    // Make changes
    employee.setSalary(employee.getSalary().add(new BigDecimal(&quot;5000&quot;)));

    // Try to commit
    em.getTransaction().commit();
} catch (OptimisticLockException e) {
    // Handle concurrency conflict
    em.getTransaction().rollback();

    // Different strategies:
    // 1. Inform user about conflict
    // 2. Retry the operation with fresh data
    // 3. Merge changes automatically if possible
    // 4. Log the conflict for later resolution

    throw new ServiceException(&quot;Another user has already updated this employee&quot;, e);
} finally {
    em.close();
}
</code></pre>
<p><strong>Types of optimistic locking in Hibernate:</strong></p>
<ol>
    <li><p><strong>Version-based locking</strong> (most common):</p>
        <ul>
            <li>Uses a dedicated version column</li>
            <li>Increments on each update</li>
            <li>Implemented with @Version</li>
        </ul>
    </li>
    <li><p><strong>All columns optimistic locking</strong>:</p>
        <ul>
            <li>Compares all columns in WHERE clause</li>
            <li>No version column needed</li>
            <li>Configure using <code>optimistic-lock=&quot;all&quot;</code> in mapping files</li>
        </ul>
    </li>
    <li><p><strong>Dirty optimistic locking</strong>:</p>
        <ul>
            <li>Only compares modified columns</li>
            <li>Configure using <code>optimistic-lock=&quot;dirty&quot;</code> in mapping files</li>
        </ul>
    </li>
    <li><p><strong>Timestamp-based locking</strong>:</p>
        <ul>
            <li>Uses a timestamp column</li>
            <li>Updates timestamp on each change</li>
        </ul>
        <pre><code class="language-java">@Entity
public class Employee {
    // Other fields

    @Version
    @Temporal(TemporalType.TIMESTAMP)
    private Date lastUpdated;
}
</code></pre>
    </li>
</ol>
<p>Optimistic locking is preferred when data conflicts are infrequent, as it avoids the overhead of database locks and provides better concurrency. It&#39;s particularly suitable for web applications where users may have long periods of inactivity between loading and updating data.</p>
<h3 id="34-what-is-pessimistic-locking-in-hibernate-and-when-would-you-use-it">34. What is pessimistic locking in Hibernate and when would you use it?</h3>
<p><strong>Answer:</strong> Pessimistic locking is a concurrency control mechanism that assumes conflicts will occur and prevents them by acquiring locks on database records before making changes. Unlike optimistic locking, which detects conflicts at commit time, pessimistic locking blocks other transactions from modifying the same data while it&#39;s being processed.</p>
<p><strong>Types of pessimistic locks in JPA/Hibernate:</strong></p>
<ol>
    <li><p><strong>PESSIMISTIC_READ (LockModeType.PESSIMISTIC_READ)</strong>:</p>
        <ul>
            <li>Acquires a shared lock</li>
            <li>Other transactions can read but not write</li>
            <li>Equivalent to SELECT ... FOR SHARE in most databases</li>
        </ul>
    </li>
    <li><p><strong>PESSIMISTIC_WRITE (LockModeType.PESSIMISTIC_WRITE)</strong>:</p>
        <ul>
            <li>Acquires an exclusive lock</li>
            <li>Other transactions cannot read or write</li>
            <li>Equivalent to SELECT ... FOR UPDATE in most databases</li>
        </ul>
    </li>
    <li><p><strong>PESSIMISTIC_FORCE_INCREMENT (LockModeType.PESSIMISTIC_FORCE_INCREMENT)</strong>:</p>
        <ul>
            <li>Acquires an exclusive lock</li>
            <li>Increments the version even when entity hasn&#39;t changed</li>
            <li>Useful when non-persistent changes occur</li>
        </ul>
    </li>
</ol>
<p><strong>Implementation using EntityManager:</strong></p>
<pre><code class="language-java">EntityManager em = emf.createEntityManager();
try {
    em.getTransaction().begin();

    // Acquire a pessimistic write lock
    Employee employee = em.find(Employee.class, id, LockModeType.PESSIMISTIC_WRITE);

    // Make changes
    employee.setSalary(employee.getSalary().add(new BigDecimal(&quot;5000&quot;)));

    // Commit transaction - lock is released
    em.getTransaction().commit();
} catch (PessimisticLockException e) {
    em.getTransaction().rollback();
    throw new ServiceException(&quot;Could not obtain lock. Try again later.&quot;, e);
} catch (LockTimeoutException e) {
    em.getTransaction().rollback();
    throw new ServiceException(&quot;Lock acquisition timed out. Try again later.&quot;, e);
} finally {
    em.close();
}
</code></pre>
<p><strong>Using pessimistic locking with queries:</strong></p>
<pre><code class="language-java">// Using JPQL
TypedQuery&lt;Employee&gt; query = em.createQuery(
    &quot;SELECT e FROM Employee e WHERE e.department.id = :deptId&quot;, Employee.class);
query.setParameter(&quot;deptId&quot;, departmentId);
query.setLockMode(LockModeType.PESSIMISTIC_WRITE);
List&lt;Employee&gt; employees = query.getResultList();

// Using Criteria API
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery&lt;Employee&gt; cq = cb.createQuery(Employee.class);
Root&lt;Employee&gt; employee = cq.from(Employee.class);
cq.where(cb.equal(employee.get(&quot;department&quot;).get(&quot;id&quot;), departmentId));
TypedQuery&lt;Employee&gt; query = em.createQuery(cq);
query.setLockMode(LockModeType.PESSIMISTIC_WRITE);
List&lt;Employee&gt; employees = query.getResultList();
</code></pre>
<p><strong>Setting lock timeout:</strong></p>
<pre><code class="language-java">Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();
// Set timeout to 5 seconds
properties.put(&quot;javax.persistence.lock.timeout&quot;, 5000);
Employee employee = em.find(Employee.class, id,
    LockModeType.PESSIMISTIC_WRITE, properties);
</code></pre>
<p><strong>When to use pessimistic locking:</strong></p>
<ol>
    <li><strong>High contention scenarios</strong>: When multiple transactions frequently try to update the same data</li>
    <li><strong>Critical operations</strong>: For operations where data integrity is absolutely critical</li>
    <li><strong>Short-lived transactions</strong>: When transactions are executed quickly, reducing lock time</li>
    <li><strong>Financial operations</strong>: For financial transactions requiring strict serialization</li>
    <li><strong>When integrity &gt; throughput</strong>: When data integrity is more important than high throughput</li>
</ol>
<p><strong>Drawbacks:</strong></p>
<ol>
    <li>Reduced concurrency and potential deadlocks</li>
    <li>Performance overhead from lock management</li>
    <li>Requires longer database connections</li>
    <li>May cause application timeouts</li>
</ol>
<p>Choose pessimistic locking when data conflicts are likely and the cost of conflict resolution is high, but be aware of the concurrency implications.</p>
<h3 id="35-how-do-you-handle-batch-operations-efficiently-in-jpahibernate">35. How do you handle batch operations efficiently in JPA/Hibernate?</h3>
<p><strong>Answer:</strong> Batch operations in JPA/Hibernate allow processing multiple entities in groups to improve performance by reducing the number of database round trips. Here are the key techniques for efficient batch processing:</p>
<p><strong>1. Batch Inserts</strong></p>
<pre><code class="language-java">EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
try {
    tx.begin();

    int batchSize = 50;
    for (int i = 0; i &lt; 10000; i++) {
        Employee employee = new Employee(&quot;Employee&quot; + i,
            &quot;department&quot; + (i % 10), new BigDecimal(50000));
        em.persist(employee);

        // Flush and clear every batchSize entities
        if (i &gt; 0 &amp;&amp; i % batchSize == 0) {
            em.flush();  // Push to database
            em.clear();  // Clear persistence context to free memory
        }
    }

    tx.commit();
} catch (Exception e) {
    tx.rollback();
    throw e;
} finally {
    em.close();
}
</code></pre>
<p><strong>2. Batch Updates with JPQL</strong></p>
<pre><code class="language-java">EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
try {
    tx.begin();

    // Update all employees in a department
    int updatedCount = em.createQuery(
        &quot;UPDATE Employee e SET e.salary = e.salary * 1.1 WHERE e.department.id = :deptId&quot;)
        .setParameter(&quot;deptId&quot;, departmentId)
        .executeUpdate();

    tx.commit();
    System.out.println(&quot;Updated &quot; + updatedCount + &quot; employees&quot;);
} catch (Exception e) {
    tx.rollback();
    throw e;
} finally {
    em.close();
}
</code></pre>
<p><strong>3. Batch Deletes with JPQL</strong></p>
<pre><code class="language-java">EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
try {
    tx.begin();

    // Delete inactive employees
    int deletedCount = em.createQuery(
        &quot;DELETE FROM Employee e WHERE e.active = false&quot;)
        .executeUpdate();

    tx.commit();
    System.out.println(&quot;Deleted &quot; + deletedCount + &quot; employees&quot;);
} catch (Exception e) {
    tx.rollback();
    throw e;
} finally {
    em.close();
}
</code></pre>
<p><strong>4. Configuring JDBC Batch Size</strong></p>
<pre><code class="language-properties"># In persistence.xml or hibernate.properties
&lt;property name=&quot;hibernate.jdbc.batch_size&quot; value=&quot;50&quot;/&gt;
&lt;property name=&quot;hibernate.order_inserts&quot; value=&quot;true&quot;/&gt;
&lt;property name=&quot;hibernate.order_updates&quot; value=&quot;true&quot;/&gt;
&lt;property name=&quot;hibernate.jdbc.batch_versioned_data&quot; value=&quot;true&quot;/&gt;
</code></pre>
<p><strong>5. Stateless Sessions (Hibernate-specific)</strong></p>
<pre><code class="language-java">// For very large batch operations, bypass persistence context
SessionFactory sessionFactory = entityManager.unwrap(Session.class)
    .getSessionFactory();

try (StatelessSession session = sessionFactory.openStatelessSession()) {
    Transaction tx = session.beginTransaction();
    try {
        // Process CSV file with 1 million records
        try (CSVReader reader = new CSVReader(new FileReader(&quot;data.csv&quot;))) {
            String[] line;
            while ((line = reader.readNext()) != null) {
                Employee employee = new Employee(line[0], line[1],
                    new BigDecimal(line[2]));
                session.insert(employee); // Direct insert, no persistence context
            }
        }
        tx.commit();
    } catch (Exception e) {
        tx.rollback();
        throw e;
    }
}
</code></pre>
<p><strong>6. Using Native SQL for Bulk Operations</strong></p>
<pre><code class="language-java">EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
try {
    tx.begin();

    // For very large operations, native SQL might be more efficient
    int updatedCount = em.createNativeQuery(
        &quot;UPDATE employees SET salary = salary * 1.1 WHERE department_id = ?&quot;)
        .setParameter(1, departmentId)
        .executeUpdate();

    tx.commit();
} catch (Exception e) {
    tx.rollback();
    throw e;
} finally {
    em.close();
}
</code></pre>
<p><strong>7. Multi-level Batching (parent-child relationships)</strong></p>
<pre><code class="language-java">// To maintain batch efficiency with relationships,
// use a combination of strategies
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
try {
    tx.begin();

    int batchSize = 50;
    for (int i = 0; i &lt; 1000; i++) {
        Department dept = new Department(&quot;Department&quot; + i);
        em.persist(dept);

        // Add employees to each department
        for (int j = 0; j &lt; 10; j++) {
            Employee emp = new Employee(&quot;Emp &quot; + i + &quot;-&quot; + j, dept);
            em.persist(emp);
        }

        if (i % batchSize == 0) {
            em.flush();
            em.clear();
        }
    }

    tx.commit();
} catch (Exception e) {
    tx.rollback();
    throw e;
} finally {
    em.close();
}
</code></pre>
<p><strong>Common batch processing pitfalls to avoid:</strong></p>
<ol>
    <li>Not setting appropriate JDBC batch sizes</li>
    <li>Not flushing and clearing the persistence context periodically</li>
    <li>Using identity generators with batching (sequence generators work better)</li>
    <li>Ignoring cascading effects on related entities</li>
    <li>Not considering the memory footprint of large operations</li>
</ol>
<p>Effective batch processing can significantly improve performance for large operations by reducing database round trips and persistence context overhead.</p>
<h3 id="36-what-are-the-best-practices-for-optimizing-jpahibernate-performance">36. What are the best practices for optimizing JPA/Hibernate performance?</h3>
<p><strong>Answer:</strong> Optimizing JPA/Hibernate performance involves multiple strategies at different levels of the application. Here are key best practices:</p>
<p><strong>1. Entity Design and Mapping</strong></p>
<ul>
    <li><strong>Use lazy loading appropriately</strong><pre><code class="language-java">@Entity
public class Department {
    @OneToMany(mappedBy = &quot;department&quot;, fetch = FetchType.LAZY)
    private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();
}
</code></pre>
    </li>
    <li><strong>Choose efficient ID generation strategies</strong> (avoid IDENTITY for batching)<pre><code class="language-java">@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;emp_seq&quot;)
@SequenceGenerator(name = &quot;emp_seq&quot;, sequenceName = &quot;EMP_SEQ&quot;, allocationSize = 50)
private Long id;
</code></pre>
    </li>
    <li><strong>Use appropriate fetch strategies</strong></li>
    <li><strong>Avoid excessive entity relationships</strong></li>
    <li><strong>Consider using DTOs for read operations</strong></li>
</ul>
<p><strong>2. Query Optimization</strong></p>
<ul>
    <li><strong>Fetch only what you need</strong><pre><code class="language-java">// Instead of fetching full entities
TypedQuery&lt;EmployeeDTO&gt; query = em.createQuery(
    &quot;SELECT new com.example.EmployeeDTO(e.id, e.name) FROM Employee e&quot;,
    EmployeeDTO.class);
</code></pre>
    </li>
    <li><strong>Use fetch joins for needed relationships</strong><pre><code class="language-java">TypedQuery&lt;Employee&gt; query = em.createQuery(
    &quot;SELECT e FROM Employee e JOIN FETCH e.department WHERE e.id = :id&quot;,
    Employee.class);
</code></pre>
    </li>
    <li><strong>Leverage named queries for frequently used queries</strong><pre><code class="language-java">@NamedQuery(name = &quot;Employee.findWithDepartment&quot;,
    query = &quot;SELECT e FROM Employee e JOIN FETCH e.department WHERE e.id = :id&quot;)
</code></pre>
    </li>
    <li><strong>Implement pagination for large result sets</strong><pre><code class="language-java">TypedQuery&lt;Employee&gt; query = em.createQuery(jpql, Employee.class)
    .setFirstResult(pageNumber * pageSize)
    .setMaxResults(pageSize);
</code></pre>
    </li>
    <li><strong>Use query hints for specific optimizations</strong><pre><code class="language-java">query.setHint(&quot;org.hibernate.readOnly&quot;, true);
query.setHint(&quot;org.hibernate.fetchSize&quot;, 50);
</code></pre>
    </li>
</ul>
<p><strong>3. Session/EntityManager Management</strong></p>
<ul>
    <li><strong>Keep sessions short-lived</strong></li>
    <li><strong>Clear the persistence context for long operations</strong><pre><code class="language-java">if (i % 100 == 0) {
    em.flush();
    em.clear();
}
</code></pre>
    </li>
    <li><strong>Use read-only transactions when appropriate</strong><pre><code class="language-java">@Transactional(readOnly = true)
public List&lt;Employee&gt; findAllEmployees() {
    return employeeRepository.findAll();
}
</code></pre>
    </li>
</ul>
<p><strong>4. Caching Strategies</strong></p>
<ul>
    <li><strong>Configure second-level cache for reference data</strong><pre><code class="language-java">@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
public class Country {
    @Id
    private String code;
    private String name;
}
</code></pre>
    </li>
    <li><strong>Use query cache for frequently executed queries</strong><pre><code class="language-java">query.setHint(&quot;org.hibernate.cacheable&quot;, true);
</code></pre>
    </li>
    <li><strong>Choose appropriate caching provider (EHCache, Infinispan, etc.)</strong><pre><code class="language-xml">&lt;property name=&quot;hibernate.cache.region.factory_class&quot;
    value=&quot;org.hibernate.cache.ehcache.EhCacheRegionFactory&quot;/&gt;
</code></pre>
    </li>
</ul>
<p><strong>5. Batching and Bulk Operations</strong></p>
<ul>
    <li><strong>Configure JDBC batch size</strong><pre><code class="language-xml">&lt;property name=&quot;hibernate.jdbc.batch_size&quot; value=&quot;50&quot;/&gt;
&lt;property name=&quot;hibernate.order_inserts&quot; value=&quot;true&quot;/&gt;
&lt;property name=&quot;hibernate.order_updates&quot; value=&quot;true&quot;/&gt;
</code></pre>
    </li>
    <li><strong>Use bulk update/delete operations</strong><pre><code class="language-java">int updated = em.createQuery(&quot;UPDATE Employee e SET e.status = :status &quot; +
    &quot;WHERE e.department.id = :deptId&quot;)
    .setParameter(&quot;status&quot;, &quot;ACTIVE&quot;)
    .setParameter(&quot;deptId&quot;, 5L)
    .executeUpdate();
</code></pre>
    </li>
    <li><strong>Use StatelessSession for very large operations</strong></li>
</ul>
<p><strong>6. Database-Level Optimizations</strong></p>
<ul>
    <li><strong>Create proper database indexes</strong></li>
    <li><strong>Use the explain plan to analyze query performance</strong></li>
    <li><strong>Optimize database schema for common access patterns</strong></li>
    <li><strong>Consider database-specific optimizations</strong></li>
</ul>
<p><strong>7. Connection and Statement Management</strong></p>
<ul>
    <li><strong>Use connection pooling</strong><pre><code class="language-xml">&lt;property name=&quot;hibernate.connection.provider_class&quot;
    value=&quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;/&gt;
&lt;property name=&quot;hibernate.hikari.maximumPoolSize&quot; value=&quot;20&quot;/&gt;
</code></pre>
    </li>
    <li><strong>Set appropriate statement fetch size</strong><pre><code class="language-xml">&lt;property name=&quot;hibernate.jdbc.fetch_size&quot; value=&quot;50&quot;/&gt;
</code></pre>
    </li>
</ul>
<p><strong>8. Development and Testing Practices</strong></p>
<ul>
    <li><strong>Enable statistics for performance tuning</strong><pre><code class="language-xml">&lt;property name=&quot;hibernate.generate_statistics&quot; value=&quot;true&quot;/&gt;
</code></pre>
    </li>
    <li><strong>Profile your application using tools (JProfiler, VisualVM)</strong></li>
    <li><strong>Analyze SQL statements with logging</strong><pre><code class="language-xml">&lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt;
&lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;
&lt;property name=&quot;hibernate.use_sql_comments&quot; value=&quot;true&quot;/&gt;
</code></pre>
    </li>
</ul>
<p><strong>9. Common Anti-Patterns to Avoid</strong></p>
<ul>
    <li>N+1 select problem</li>
    <li>Fetching more data than needed</li>
    <li>Using eager fetching for all relationships</li>
    <li>Not closing resources properly</li>
    <li>Putting too many entities in the persistence context</li>
</ul>
<p>By applying these best practices, you can significantly improve the performance of your JPA/Hibernate applications while maintaining code quality and maintainability.</p>
<h3 id="37-what-is-the-lazyinitializationexception-and-how-do-you-handle-it">37. What is the LazyInitializationException and how do you handle it?</h3>
<p><strong>Answer:</strong> LazyInitializationException is one of the most common exceptions in Hibernate. It occurs when you try to access a lazily loaded association after the Hibernate session (persistence context) is closed.</p>
<p><strong>Cause of the exception:</strong></p>
<pre><code class="language-java">public List&lt;EmployeeDTO&gt; getEmployeesByDepartment(Long departmentId) {
    EntityManager em = emf.createEntityManager();
    try {
        Department department = em.find(Department.class, departmentId);
        List&lt;EmployeeDTO&gt; result = new ArrayList&lt;&gt;();

        // Session is closed after this block
    } finally {
        em.close();
    }

    // LazyInitializationException occurs here - session is already closed
    for (Employee employee : department.getEmployees()) {
        result.add(new EmployeeDTO(employee));
    }

    return result;
}
</code></pre>
<p><strong>Common solutions to handle LazyInitializationException:</strong></p>
<ol>
    <li><strong>Fetch Join</strong>: Eager load the association in the initial query</li>
</ol>
<pre><code class="language-java">public Department getDepartmentWithEmployees(Long departmentId) {
    EntityManager em = emf.createEntityManager();
    try {
        // Fetch employees along with department in a single query
        return em.createQuery(
            &quot;SELECT d FROM Department d JOIN FETCH d.employees WHERE d.id = :id&quot;,
            Department.class)
            .setParameter(&quot;id&quot;, departmentId)
            .getSingleResult();
    } finally {
        em.close();
    }
}
</code></pre>
<ol start="2">
    <li><strong>Open Session in View Pattern</strong>: Keep the session open during request processing</li>
</ol>
<pre><code class="language-java">// In a web filter or Spring configuration
@Bean
public OpenEntityManagerInViewFilter openEntityManagerInViewFilter() {
    return new OpenEntityManagerInViewFilter();
}
</code></pre>
<ol start="3">
    <li><strong>Initialize Collections</strong>: Explicitly initialize lazy collections while session is open</li>
</ol>
<pre><code class="language-java">public Department getDepartmentWithEmployees(Long departmentId) {
    EntityManager em = emf.createEntityManager();
    try {
        Department department = em.find(Department.class, departmentId);
        // Force initialization while session is still open
        Hibernate.initialize(department.getEmployees());
        return department;
    } finally {
        em.close();
    }
}
</code></pre>
<ol start="4">
    <li><strong>Use DTO Projections</strong>: Select only needed data without lazy associations</li>
</ol>
<pre><code class="language-java">public List&lt;EmployeeDTO&gt; getEmployeesByDepartment(Long departmentId) {
    EntityManager em = emf.createEntityManager();
    try {
        return em.createQuery(
            &quot;SELECT new com.example.EmployeeDTO(e.id, e.name, e.email) &quot; +
            &quot;FROM Employee e WHERE e.department.id = :deptId&quot;, EmployeeDTO.class)
            .setParameter(&quot;deptId&quot;, departmentId)
            .getResultList();
    } finally {
        em.close();
    }
}
</code></pre>
<ol start="5">
    <li><strong>Entity Graphs</strong>: Define which associations to load</li>
</ol>
<pre><code class="language-java">public Department getDepartmentWithEmployees(Long departmentId) {
    EntityManager em = emf.createEntityManager();
    try {
        EntityGraph&lt;Department&gt; graph = em.createEntityGraph(Department.class);
        graph.addAttributeNodes(&quot;employees&quot;);

        Map&lt;String, Object&gt; hints = new HashMap&lt;&gt;();
        hints.put(&quot;javax.persistence.fetchgraph&quot;, graph);

        return em.find(Department.class, departmentId, hints);
    } finally {
        em.close();
    }
}
</code></pre>
<ol start="6">
    <li><strong>Use bidirectional relationships carefully</strong></li>
</ol>
<pre><code class="language-java">// Instead of accessing from the &quot;many&quot; side
for (Employee e : department.getEmployees()) {
    // Process employee
}

// Access from the &quot;one&quot; side if possible
// Assuming employees are already loaded
for (Employee e : allEmployees) {
    if (e.getDepartment().getId().equals(departmentId)) {
        // Process employee
    }
}
</code></pre>
<ol start="7">
    <li><strong>Change fetch type</strong> (use carefully, can affect performance)</li>
</ol>
<pre><code class="language-java">@Entity
public class Department {
    @OneToMany(mappedBy = &quot;department&quot;, fetch = FetchType.EAGER)
    private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();
}
</code></pre>
<p><strong>Best practices to avoid LazyInitializationException:</strong></p>
<ol>
    <li>Understand your data access patterns and fetch data accordingly</li>
    <li>Prefer fetch joins or entity graphs over EAGER fetching</li>
    <li>Use DTOs for read operations with specific data needs</li>
    <li>Be aware of session boundaries in your application</li>
    <li>Consider using tools like Spring Data JPA&#39;s @EntityGraph for cleaner code</li>
</ol>
<p>While Open Session in View is a common solution, be aware that it can lead to performance issues by keeping the session open longer than necessary and potentially causing N+1 query problems.</p>
<h3 id="38-what-are-the-different-states-of-an-entity-in-hibernate">38. What are the different states of an entity in Hibernate?</h3>
<p><strong>Answer:</strong> In Hibernate, an entity can exist in one of four states, which determine how the entity is managed by the persistence context and how changes to the entity are tracked.</p>
<p><strong>1. Transient State</strong></p>
<ul>
    <li>Entity instance created with <code>new</code> operator</li>
    <li>Not associated with any persistence context</li>
    <li>No representation in the database yet</li>
    <li>Changes to the entity are not tracked</li>
    <li>Has no persistent identifier value (unless manually assigned)</li>
    <li>Will be garbage collected if no references remain</li>
</ul>
<pre><code class="language-java">// Transient object
Employee employee = new Employee();
employee.setName(&quot;John Doe&quot;);
employee.setSalary(new BigDecimal(&quot;60000&quot;));
// Not saved to database yet
</code></pre>
<p><strong>2. Persistent State (Managed)</strong></p>
<ul>
    <li>Entity instance associated with a persistence context</li>
    <li>Has a representation in the database (or will have after flush)</li>
    <li>Changes are tracked and synchronized to database at flush/commit</li>
    <li>Automatic dirty checking: modified properties are detected and updated</li>
    <li>Identity exists within the context of the session</li>
</ul>
<pre><code class="language-java">// Making a transient entity persistent
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
tx.begin();

// Now the entity becomes persistent (managed)
em.persist(employee);

// Changes are automatically tracked
employee.setSalary(new BigDecimal(&quot;65000&quot;));
// No explicit update call needed

tx.commit();
em.close();
</code></pre>
<p><strong>3. Detached State</strong></p>
<ul>
    <li>Previously persistent entity that is no longer associated with a persistence context</li>
    <li>Still has database identifier</li>
    <li>Changes are not tracked or synchronized</li>
    <li>Can be reattached to a new session via merge()</li>
</ul>
<pre><code class="language-java">EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
tx.begin();

// Load an entity (persistent state)
Employee employee = em.find(Employee.class, 1L);

tx.commit();
em.close();
// Now &#39;employee&#39; is in detached state

// Changes to detached entity are not tracked
employee.setSalary(new BigDecimal(&quot;70000&quot;));

// To save changes, must reattach via a new session
EntityManager em2 = emf.createEntityManager();
tx = em2.getTransaction();
tx.begin();

// Merge the detached entity back to persistent state
employee = em2.merge(employee);

tx.commit();
em2.close();
</code></pre>
<p><strong>4. Removed State</strong></p>
<ul>
    <li>Entity instance scheduled for deletion from the database</li>
    <li>Still in persistence context until flush/commit</li>
    <li>Will be removed from database when transaction commits</li>
</ul>
<pre><code class="language-java">EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
tx.begin();

// Load an entity (persistent state)
Employee employee = em.find(Employee.class, 1L);

// Mark for removal
em.remove(employee);
// Entity is in removed state, but still in persistence context

// After commit, it&#39;s removed from database
tx.commit();
em.close();
</code></pre>
<p><strong>State Transitions:</strong></p>
<ol>
    <li><p><strong>Transient → Persistent</strong>:</p>
        <ul>
            <li><code>persist()</code>: Makes a new entity managed</li>
            <li><code>save()</code>: Hibernate-specific alternative</li>
            <li><code>saveOrUpdate()</code>: For both new and detached entities (Hibernate-specific)</li>
        </ul>
    </li>
    <li><p><strong>Persistent → Detached</strong>:</p>
        <ul>
            <li>Session/EntityManager closes</li>
            <li>Transaction commits</li>
            <li><code>evict()</code>/<code>detach()</code>: Explicitly detaches a single entity</li>
            <li><code>clear()</code>: Detaches all entities in the persistence context</li>
        </ul>
    </li>
    <li><p><strong>Detached → Persistent</strong>:</p>
        <ul>
            <li><code>merge()</code>: Creates a new persistent instance with the detached entity&#39;s state</li>
            <li><code>update()</code>: Reattaches the specific entity instance (Hibernate-specific)</li>
            <li><code>saveOrUpdate()</code>: Reattaches if it has an identifier (Hibernate-specific)</li>
        </ul>
    </li>
    <li><p><strong>Persistent → Removed</strong>:</p>
        <ul>
            <li><code>remove()</code>: Marks entity for deletion</li>
        </ul>
    </li>
    <li><p><strong>Removed → Persistent</strong>:</p>
        <ul>
            <li><code>persist()</code>: Cancels the removal (uncommon)</li>
        </ul>
    </li>
</ol>
<p>Understanding entity states is crucial for effective Hibernate usage, particularly for managing the entity lifecycle correctly and avoiding common pitfalls like LazyInitializationException.</p>
<h3 id="39-what-is-the-difference-between-get-and-load-methods-in-hibernate">39. What is the difference between get() and load() methods in Hibernate?</h3>
<p><strong>Answer:</strong> Both <code>get()</code> and <code>load()</code> methods in Hibernate are used to retrieve entities by their identifier, but they have important differences in behavior, particularly related to how they handle non-existent entities and when they access the database.</p>
<p><strong>get() Method</strong>:</p>
<ul>
    <li>Immediately hits the database if the entity is not in the session cache</li>
    <li>Returns <code>null</code> if the entity doesn&#39;t exist</li>
    <li>Always returns a fully initialized entity object</li>
    <li>Use when you&#39;re not sure if the entity exists</li>
    <li>Similar to JPA&#39;s <code>EntityManager.find()</code></li>
</ul>
<pre><code class="language-java">Session session = sessionFactory.openSession();
try {
    // Immediate database hit if not in cache
    Employee employee = session.get(Employee.class, 101L);

    // Safe null check
    if (employee != null) {
        System.out.println(&quot;Employee name: &quot; + employee.getName());
    } else {
        System.out.println(&quot;Employee not found&quot;);
    }
} finally {
    session.close();
}
</code></pre>
<p><strong>load() Method</strong>:</p>
<ul>
    <li>Returns a proxy (reference) without hitting the database</li>
    <li>Throws <code>ObjectNotFoundException</code> if the entity doesn&#39;t exist (when accessing non-identifier properties)</li>
    <li>Actual database access is deferred until a non-identifier property is accessed</li>
    <li>Use when you&#39;re certain the entity exists and may not need all its data</li>
    <li>Similar to JPA&#39;s <code>EntityManager.getReference()</code></li>
</ul>
<pre><code class="language-java">Session session = sessionFactory.openSession();
try {
    // Returns a proxy - no immediate database hit
    Employee employee = session.load(Employee.class, 101L);

    // Just getting the ID doesn&#39;t hit the database
    System.out.println(&quot;Employee ID: &quot; + employee.getId());

    try {
        // This will hit the database
        System.out.println(&quot;Employee name: &quot; + employee.getName());
    } catch (ObjectNotFoundException e) {
        System.out.println(&quot;Employee does not exist!&quot;);
    }
} finally {
    session.close();
}
</code></pre>
<p><strong>Key Differences Summarized</strong>:</p>
<ol>
    <li><p><strong>Database Access Timing</strong>:</p>
        <ul>
            <li><code>get()</code>: Immediate database access</li>
            <li><code>load()</code>: Lazy database access (on demand)</li>
        </ul>
    </li>
    <li><p><strong>Non-Existent Entity Behavior</strong>:</p>
        <ul>
            <li><code>get()</code>: Returns null</li>
            <li><code>load()</code>: Returns proxy, throws exception when accessed</li>
        </ul>
    </li>
    <li><p><strong>Return Type</strong>:</p>
        <ul>
            <li><code>get()</code>: Always returns the actual entity instance</li>
            <li><code>load()</code>: May return a proxy (subclass of the entity)</li>
        </ul>
    </li>
    <li><p><strong>Performance Implications</strong>:</p>
        <ul>
            <li><code>get()</code>: Less efficient when you only need the ID</li>
            <li><code>load()</code>: More efficient for relationship mappings</li>
        </ul>
    </li>
    <li><p><strong>Use Cases</strong>:</p>
        <ul>
            <li><code>get()</code>: When you need to check if entity exists</li>
            <li><code>load()</code>: When setting relationships and you know the entity exists</li>
        </ul>
    </li>
</ol>
<p><strong>Practical example showing the difference</strong>:</p>
<pre><code class="language-java">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

try {
    // Scenario 1: Setting a relationship when you know the entity exists
    Department dept = session.get(Department.class, 1L);

    // Using load() is more efficient here - we only need the ID
    Employee manager = session.load(Employee.class, 101L);
    dept.setManager(manager); // No database hit needed

    // Scenario 2: Need to verify if entity exists
    Long employeeId = 102L;
    Employee employee = session.get(Employee.class, employeeId); // Immediate check

    if (employee != null) {
        employee.setSalary(employee.getSalary().multiply(new BigDecimal(&quot;1.1&quot;)));
    } else {
        System.out.println(&quot;Cannot give raise - employee &quot; + employeeId + &quot; not found&quot;);
    }

    tx.commit();
} catch (Exception e) {
    tx.rollback();
    throw e;
} finally {
    session.close();
}
</code></pre>
<p>Understanding when to use <code>get()</code> vs. <code>load()</code> can help optimize your application by reducing unnecessary database queries, particularly when working with entity relationships.</p>
<h3 id="40-what-is-dirty-checking-in-hibernate">40. What is dirty checking in Hibernate?</h3>
<p><strong>Answer:</strong> Dirty checking is a feature in Hibernate that automatically detects changes to managed entities during a transaction and synchronizes those changes with the database during flush operations, without requiring explicit update calls.</p>
<p><strong>How Dirty Checking Works</strong>:</p>
<ol>
    <li>When an entity is loaded or persisted, Hibernate creates a snapshot of its state</li>
    <li>Before transaction commit or session flush, Hibernate compares current state with snapshot</li>
    <li>If differences are detected, the entity is considered &quot;dirty&quot; and SQL updates are generated</li>
    <li>Changes are propagated to the database, keeping it in sync with object state</li>
</ol>
<p><strong>Example of Dirty Checking</strong>:</p>
<pre><code class="language-java">EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();

try {
    tx.begin();

    // Load entity into persistence context
    Employee employee = em.find(Employee.class, 101L);

    // Modify the entity - Hibernate tracks this change
    employee.setSalary(employee.getSalary().multiply(new BigDecimal(&quot;1.1&quot;)));
    employee.setTitle(&quot;Senior &quot; + employee.getTitle());

    // No explicit update/save call needed!

    // At commit time, Hibernate detects changes and generates UPDATE statement
    tx.commit();
} catch (Exception e) {
    if (tx != null &amp;&amp; tx.isActive()) {
        tx.rollback();
    }
    throw e;
} finally {
    em.close();
}
</code></pre>
<p><strong>Benefits of Dirty Checking</strong>:</p>
<ol>
    <li>Reduces boilerplate code (no explicit update calls)</li>
    <li>Ensures database consistency with object state</li>
    <li>Minimizes SQL generation (only changed fields are updated)</li>
    <li>Prevents accidental omission of update calls</li>
    <li>Simplifies transaction management</li>
</ol>
<p><strong>Optimizing Dirty Checking</strong>:</p>
<ol>
    <li><strong>Dynamic Update</strong>: Update only changed columns</li>
</ol>
<pre><code class="language-java">@Entity
@DynamicUpdate
public class Employee {
    // Entity fields and methods
}
</code></pre>
<ol start="2">
    <li><strong>Selective Attribute Updates</strong>: Update only specific properties</li>
</ol>
<pre><code class="language-java">Session session = entityManager.unwrap(Session.class);
Employee employee = session.get(Employee.class, 101L);

// Create a copy with only changed attributes
Employee copy = new Employee();
copy.setId(employee.getId());
copy.setSalary(new BigDecimal(&quot;65000&quot;));

// Update specific attributes only
session.update(employee, copy,
    AttributeAccessor.getAttributeNames(&quot;salary&quot;));
</code></pre>
<ol start="3">
    <li><strong>Batch Size Configuration</strong>: Process updates in batches</li>
</ol>
<pre><code class="language-xml">&lt;property name=&quot;hibernate.jdbc.batch_size&quot; value=&quot;50&quot;/&gt;
&lt;property name=&quot;hibernate.order_updates&quot; value=&quot;true&quot;/&gt;
</code></pre>
<p><strong>When Dirty Checking Occurs</strong>:</p>
<ul>
    <li>On transaction commit</li>
    <li>When session.flush() is called</li>
    <li>Before query execution (to ensure consistent results)</li>
    <li>When StatelessSession is used (no dirty checking)</li>
</ul>
<p><strong>Potential Pitfalls</strong>:</p>
<ol>
    <li><strong>Collection modifications</strong>: Must use collection accessor methods for proper tracking</li>
</ol>
<pre><code class="language-java">// Correct way to modify collections
department.getEmployees().add(newEmployee);

// Wrong way - not tracked by dirty checking
Set&lt;Employee&gt; employees = department.getEmployees();
employees = new HashSet&lt;&gt;(employees);
employees.add(newEmployee);
department.setEmployees(employees);
</code></pre>
<ol start="2">
    <li><strong>Performance with large objects</strong>: Tracking many entities may cause memory issues</li>
    <li><strong>Non-entity property changes</strong>: Changes to value types not automatically tracked if mutable</li>
</ol>
<p>Dirty checking is one of the most convenient features of Hibernate&#39;s persistence context, making the programming model simpler while ensuring database synchronization without explicit update statements.</p>


<h3 id="41-what-is-hibernate-validator">41. What is Hibernate Validator?</h3>
<p><strong>Answer:</strong> Hibernate Validator is an implementation of the Bean Validation specification (JSR 380) that allows you to express and validate constraints on object models using annotations. It enables validation of form inputs, method parameters, and return values using annotations like <code>@NotNull</code>, <code>@Size</code>, <code>@Email</code>, etc. The validation can be performed at the database level, service layer, or presentation layer.</p>
<h3 id="42-what-are-named-queries-in-jpa">42. What are named queries in JPA?</h3>
<p><strong>Answer:</strong> Named queries are predefined, reusable JPQL queries declared in entity classes using annotations like <code>@NamedQuery</code> or <code>@NamedQueries</code>. They improve code organization, enable reuse, and can be optimized by the JPA provider. Named queries are referenced by name when executed and help separate SQL from Java code.</p>
<pre><code class="language-java">@Entity
@NamedQuery(name = &quot;Employee.findByDepartment&quot;,
           query = &quot;SELECT e FROM Employee e WHERE e.department.name = :deptName&quot;)
public class Employee { /* fields and methods */ }

// Usage
TypedQuery&lt;Employee&gt; query = entityManager.createNamedQuery(&quot;Employee.findByDepartment&quot;, Employee.class);
query.setParameter(&quot;deptName&quot;, &quot;IT&quot;);
</code></pre>
<h3 id="43-how-does-jpa-handle-inheritance">43. How does JPA handle inheritance?</h3>
<p><strong>Answer:</strong> JPA supports three inheritance strategies:</p>
<ol>
    <li><strong>Single Table</strong>: All classes in the hierarchy map to one table with a discriminator column</li>
    <li><strong>Joined Table</strong>: Each class has its own table with foreign key relationships</li>
    <li><strong>Table Per Class</strong>: Each concrete class has its own complete table</li>
</ol>
<p>The strategy is specified using the <code>@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</code> annotation.</p>
<h3 id="44-what-is-the-difference-between-fetchtypeeager-and-fetchtypelazy">44. What is the difference between FetchType.EAGER and FetchType.LAZY?</h3>
<p><strong>Answer:</strong> </p>
<ul>
    <li><strong>EAGER</strong>: Loads related entities immediately when the parent entity is loaded</li>
    <li><strong>LAZY</strong>: Loads related entities only when they&#39;re explicitly accessed</li>
</ul>
<p>EAGER can lead to performance issues with large object graphs, while LAZY can cause LazyInitializationException if accessed outside a session. OneToMany and ManyToMany default to LAZY, while ManyToOne and OneToOne default to EAGER.</p>
<h3 id="45-how-do-you-implement-soft-delete-in-hibernate">45. How do you implement soft delete in Hibernate?</h3>
<p><strong>Answer:</strong> Soft delete keeps records in the database but marks them as deleted using a flag. Implement it by:</p>
<ol>
    <li>Adding a boolean field like <code>deleted</code> or <code>active</code> to entities</li>
    <li>Using <code>@SQLDelete</code> and <code>@Where</code> annotations to override SQL operations</li>
    <li>Creating custom repositories that filter deleted records</li>
</ol>
<pre><code class="language-java">@Entity
@SQLDelete(sql = &quot;UPDATE employee SET deleted = true WHERE id = ?&quot;)
@Where(clause = &quot;deleted = false&quot;)
public class Employee {
    @Id
    private Long id;
    private String name;
    private boolean deleted = false;
}
</code></pre>
<h3 id="46-what-is-the-entitymanagerfactory-and-how-is-it-different-from-entitymanager">46. What is the EntityManagerFactory and how is it different from EntityManager?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><strong>EntityManagerFactory</strong>: Thread-safe, heavyweight object that creates EntityManager instances</li>
    <li><strong>EntityManager</strong>: Not thread-safe, lightweight object for database operations</li>
</ul>
<p>EntityManagerFactory is typically created once per database at application startup, while EntityManager is created for each unit of work or transaction.</p>
<h3 id="47-what-is-the-purpose-of-transactional-annotation-in-spring-applications-using-jpa">47. What is the purpose of @Transactional annotation in Spring applications using JPA?</h3>
<p><strong>Answer:</strong> The <code>@Transactional</code> annotation in Spring:</p>
<ul>
    <li>Automatically begins a transaction before entering the method</li>
    <li>Commits transaction if method completes successfully</li>
    <li>Rolls back transaction if exceptions occur</li>
    <li>Supports attributes like isolation, propagation, readOnly, timeout, etc.</li>
</ul>
<p>It eliminates manual transaction handling code and declaratively manages database transactions.</p>
<h3 id="48-how-can-you-execute-native-sql-queries-in-jpa">48. How can you execute native SQL queries in JPA?</h3>
<p><strong>Answer:</strong> To execute native SQL queries in JPA:</p>
<pre><code class="language-java">// For entity mapping
Query query = entityManager.createNativeQuery(&quot;SELECT * FROM employees WHERE department_id = ?&quot;, Employee.class);
query.setParameter(1, departmentId);
List&lt;Employee&gt; employees = query.getResultList();

// For scalar results
Query query = entityManager.createNativeQuery(&quot;SELECT COUNT(*) FROM employees&quot;);
Number count = (Number) query.getSingleResult();
</code></pre>
<p>Use native queries when you need database-specific features not available in JPQL.</p>
<h3 id="49-what-is-the-use-of-hibernate-statistics">49. What is the use of Hibernate Statistics?</h3>
<p><strong>Answer:</strong> Hibernate Statistics provides runtime metrics about performance and resource usage, including:</p>
<ul>
    <li>Cache hit/miss ratios</li>
    <li>Query execution counts and times</li>
    <li>Transaction counts</li>
    <li>Connection usage data</li>
</ul>
<p>Enable it with <code>hibernate.generate_statistics = true</code> property. It helps identify bottlenecks, optimize queries, and monitor session/entity performance.</p>
<h3 id="50-what-are-common-hibernatejpa-performance-issues-and-how-to-solve-them">50. What are common Hibernate/JPA performance issues and how to solve them?</h3>
<p><strong>Answer:</strong> Common performance issues and solutions:</p>
<ol>
    <li><strong>N+1 query problem</strong>: Use join fetch, entity graphs, or batch fetching</li>
    <li><strong>Cartesian product issue</strong>: Use separate queries or paging when joining collections</li>
    <li><strong>Inefficient queries</strong>: Use projections, optimize fetch strategies</li>
    <li><strong>Large result sets</strong>: Implement pagination</li>
    <li><strong>Excessive flushing</strong>: Control flush modes</li>
    <li><strong>Connection leaks</strong>: Close resources properly in try/finally blocks</li>
    <li><strong>Cache misuse</strong>: Configure appropriate caching strategies</li>
    <li><strong>Inefficient eager loading</strong>: Review and adjust fetch types</li>
    <li><strong>Slow transactions</strong>: Optimize transaction boundaries</li>
    <li><strong>Improper batching</strong>: Configure JDBC batch size for bulk operations</li>
</ol>


<h3 id="51-how-do-you-map-a-composite-primary-key-in-jpa">51. How do you map a composite primary key in JPA?</h3>
<p><strong>Answer:</strong> Composite primary keys in JPA can be mapped using either <code>@IdClass</code> or <code>@EmbeddedId</code>:</p>
<pre><code class="language-java">// Using @IdClass
@Entity
@IdClass(EmployeePK.class)
public class Employee {
    @Id
    private String departmentId;
    @Id
    private Long employeeNumber;
    // other fields
}

public class EmployeePK implements Serializable {
    private String departmentId;
    private Long employeeNumber;
    // equals, hashCode, constructors
}

// Or using @EmbeddedId
@Entity
public class Employee {
    @EmbeddedId
    private EmployeePK id;
    // other fields
}

@Embeddable
public class EmployeePK implements Serializable {
    private String departmentId;
    private Long employeeNumber;
    // equals, hashCode, constructors
}
</code></pre>
<h3 id="52-what-is-the-difference-between-spring-data-jpa-and-plain-jpa">52. What is the difference between Spring Data JPA and plain JPA?</h3>
<p><strong>Answer:</strong> Spring Data JPA builds on top of JPA to reduce boilerplate code:</p>
<ul>
    <li>Provides repository interfaces with pre-built CRUD methods</li>
    <li>Supports method name query generation (findByLastName)</li>
    <li>Offers pagination, sorting, and dynamic queries out of the box</li>
    <li>Simplifies custom query creation with @Query annotation</li>
    <li>Integrates with Spring&#39;s transaction management</li>
    <li>Reduces boilerplate code compared to plain JPA implementations</li>
</ul>
<h3 id="53-how-do-you-implement-auditing-in-jpa-entities">53. How do you implement auditing in JPA entities?</h3>
<p><strong>Answer:</strong> Implement auditing by:</p>
<ol>
    <li>Using annotations like <code>@CreatedBy</code>, <code>@LastModifiedBy</code>, <code>@CreatedDate</code>, <code>@LastModifiedDate</code></li>
    <li>Creating an audit listener class or using Spring Data&#39;s <code>AuditingEntityListener</code></li>
</ol>
<pre><code class="language-java">@Entity
@EntityListeners(AuditingEntityListener.class)
public class Employee {
    @Id
    private Long id;

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    @CreatedBy
    private String createdBy;

    @LastModifiedBy
    private String updatedBy;

    // Regular fields
}
</code></pre>
<p>With Spring, also enable auditing with <code>@EnableJpaAuditing</code>.</p>
<h3 id="54-what-are-lifecycle-callbacks-in-jpa">54. What are lifecycle callbacks in JPA?</h3>
<p><strong>Answer:</strong> Lifecycle callbacks are methods that are automatically invoked at certain points in an entity&#39;s lifecycle. Annotate methods with:</p>
<ul>
    <li><code>@PrePersist</code>: Before persisting</li>
    <li><code>@PostPersist</code>: After persisting</li>
    <li><code>@PreUpdate</code>: Before updating</li>
    <li><code>@PostUpdate</code>: After updating</li>
    <li><code>@PreRemove</code>: Before removing</li>
    <li><code>@PostRemove</code>: After removing</li>
    <li><code>@PostLoad</code>: After loading</li>
</ul>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    private Long id;
    private String name;

    @PrePersist
    void prePersist() {
        // Logic before entity is persisted
    }
}
</code></pre>
<h3 id="55-how-does-jpa-handle-concurrency">55. How does JPA handle concurrency?</h3>
<p><strong>Answer:</strong> JPA handles concurrency through:</p>
<ol>
    <li><strong>Optimistic locking</strong>: Using <code>@Version</code> fields to detect conflicts</li>
    <li><strong>Pessimistic locking</strong>: Using <code>LockModeType</code> to lock entities during transactions</li>
    <li><strong>Isolation levels</strong>: Transaction isolation settings</li>
    <li><strong>Named lock modes</strong>: OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT, PESSIMISTIC_READ, PESSIMISTIC_WRITE</li>
</ol>
<p>Optimistic locking is most common, adding minimal overhead while detecting conflicts at commit time.</p>
<h3 id="56-what-is-the-difference-between-crudrepository-jparepository-and-pagingandsortingrepository">56. What is the difference between CrudRepository, JpaRepository, and PagingAndSortingRepository?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><strong>CrudRepository</strong>: Basic CRUD operations (save, findById, delete)</li>
    <li><strong>PagingAndSortingRepository</strong>: Extends CrudRepository, adds pagination and sorting methods</li>
    <li><strong>JpaRepository</strong>: Extends PagingAndSortingRepository, adds JPA-specific methods like flush(), saveAndFlush(), deleteInBatch()</li>
</ul>
<p>JpaRepository is typically used as it provides the most functionality while maintaining the hierarchy:</p>
<pre><code>CrudRepository → PagingAndSortingRepository → JpaRepository
</code></pre>
<h3 id="57-how-do-you-implement-a-custom-repository-method-in-spring-data-jpa">57. How do you implement a custom repository method in Spring Data JPA?</h3>
<p><strong>Answer:</strong> Create custom repository methods by:</p>
<ol>
    <li>Defining methods in repository interface using name conventions</li>
    <li>Using <code>@Query</code> annotation for custom JPQL or native SQL</li>
    <li>Creating a custom repository implementation</li>
</ol>
<pre><code class="language-java">// Method naming convention
public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {
    List&lt;Employee&gt; findBySalaryGreaterThan(BigDecimal salary);
}

// Using @Query
@Query(&quot;SELECT e FROM Employee e WHERE e.department.name = :deptName&quot;)
List&lt;Employee&gt; findByDepartmentName(@Param(&quot;deptName&quot;) String deptName);

// Native query
@Query(value = &quot;SELECT * FROM employees WHERE YEAR(hire_date) = :year&quot;, nativeQuery = true)
List&lt;Employee&gt; findByHireYear(@Param(&quot;year&quot;) int year);
</code></pre>
<h3 id="58-what-are-the-different-transaction-propagation-types">58. What are the different transaction propagation types?</h3>
<p><strong>Answer:</strong> Spring&#39;s transaction propagation types control how transactions behave when methods call each other:</p>
<ul>
    <li><strong>REQUIRED</strong>: Use current transaction or create new one (default)</li>
    <li><strong>SUPPORTS</strong>: Use current transaction if exists, otherwise non-transactional</li>
    <li><strong>MANDATORY</strong>: Use current transaction, throw exception if none exists</li>
    <li><strong>REQUIRES_NEW</strong>: Create new transaction, suspend current one if exists</li>
    <li><strong>NOT_SUPPORTED</strong>: Execute non-transactionally, suspend current transaction if exists</li>
    <li><strong>NEVER</strong>: Execute non-transactionally, throw exception if transaction exists</li>
    <li><strong>NESTED</strong>: Execute within nested transaction if transaction exists</li>
</ul>
<p>Set using <code>@Transactional(propagation = Propagation.REQUIRED)</code>.</p>
<h3 id="59-what-is-the-hibernate-session-flush-mode">59. What is the Hibernate Session Flush Mode?</h3>
<p><strong>Answer:</strong> Flush mode determines when Hibernate synchronizes the persistence context with the database:</p>
<ul>
    <li><strong>AUTO</strong>: Flush before queries and when transaction commits (default)</li>
    <li><strong>COMMIT</strong>: Flush only when transaction commits</li>
    <li><strong>ALWAYS</strong>: Flush before every query</li>
    <li><strong>MANUAL</strong>: Flush only when explicitly called</li>
</ul>
<p>Set flush mode with:</p>
<pre><code class="language-java">session.setHibernateFlushMode(FlushMode.COMMIT);
// or JPA way
entityManager.setFlushMode(FlushModeType.COMMIT);
</code></pre>
<p>Choose COMMIT mode when you want to minimize database writes during read-heavy operations.</p>
<h3 id="60-what-is-the-n1-select-problem-and-how-to-solve-it">60. What is the N+1 select problem and how to solve it?</h3>
<p><strong>Answer:</strong> The N+1 select problem occurs when accessing a collection of N child entities triggers N additional queries, one for each parent entity.</p>
<p>Solutions:</p>
<ol>
    <li><strong>Fetch joins</strong>: <code>SELECT d FROM Department d JOIN FETCH d.employees</code></li>
    <li><strong>EntityGraph</strong>: <code>@EntityGraph(attributePaths = {&quot;employees&quot;})</code></li>
    <li><strong>Batch fetching</strong>: <code>@BatchSize(size = 25)</code> on collection</li>
    <li><strong>Subselect fetching</strong>: <code>@Fetch(FetchMode.SUBSELECT)</code></li>
    <li><strong>DTO projections</strong>: Query only needed data</li>
</ol>
<p>This is one of the most common performance issues in Hibernate applications, especially when looping through collections of loaded entities.</p>

<h3 id="61-what-is-a-database-sequence-and-how-do-you-use-it-in-jpa">61. What is a database sequence and how do you use it in JPA?</h3>
<p><strong>Answer:</strong> A database sequence is a database object that generates unique numeric values. In JPA, sequences are used for ID generation with the <code>@SequenceGenerator</code> annotation:</p>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;emp_seq&quot;)
    @SequenceGenerator(name = &quot;emp_seq&quot;, sequenceName = &quot;EMPLOYEE_SEQ&quot;,
                      initialValue = 1, allocationSize = 50)
    private Long id;
    // Other fields
}
</code></pre>
<p>Sequences are more efficient than IDENTITY for batch inserts because IDs are pre-allocated.</p>
<h3 id="62-what-is-the-difference-between-joincolumn-and-column">62. What is the difference between @JoinColumn and @Column?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><code>@Column</code>: Maps a field to a column in the entity&#39;s table</li>
    <li><code>@JoinColumn</code>: Specifies a foreign key column that joins to another entity&#39;s table</li>
</ul>
<p><code>@JoinColumn</code> is used with relationships (@OneToOne, @ManyToOne), while <code>@Column</code> is used for regular fields.</p>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    private Long id;

    @Column(name = &quot;full_name&quot;, length = 100)
    private String name;

    @ManyToOne
    @JoinColumn(name = &quot;department_id&quot;)
    private Department department;
}
</code></pre>
<h3 id="63-how-do-you-map-enumerations-in-jpa">63. How do you map enumerations in JPA?</h3>
<p><strong>Answer:</strong> Enums can be mapped using <code>@Enumerated</code> annotation with two strategies:</p>
<pre><code class="language-java">public enum EmployeeStatus { ACTIVE, ON_LEAVE, TERMINATED }

@Entity
public class Employee {
    // Store as ordinal (0, 1, 2) - default
    @Enumerated(EnumType.ORDINAL)
    private EmployeeStatus status;

    // Store as string (&quot;ACTIVE&quot;, &quot;ON_LEAVE&quot;, &quot;TERMINATED&quot;)
    @Enumerated(EnumType.STRING)
    private EmployeeStatus statusAsString;
}
</code></pre>
<p>EnumType.STRING is generally safer as it&#39;s not affected by enum order changes.</p>
<h3 id="64-what-is-the-hibernate-second-level-cache">64. What is the Hibernate second-level cache?</h3>
<p><strong>Answer:</strong> The second-level cache is a shared cache that persists data beyond a single session/transaction. It caches entity data across sessions to reduce database access. To configure:</p>
<ol>
    <li>Enable caching in configuration:</li>
</ol>
<pre><code>hibernate.cache.use_second_level_cache=true
hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
</code></pre>
<ol start="2">
    <li>Mark entities as cacheable:</li>
</ol>
<pre><code class="language-java">@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Country {
    @Id
    private String code;
    private String name;
}
</code></pre>
<h3 id="65-how-do-you-map-a-bidirectional-relationship-in-jpa">65. How do you map a bidirectional relationship in JPA?</h3>
<p><strong>Answer:</strong> In bidirectional relationships, one side is the owner and the other uses <code>mappedBy</code> to indicate the owning side:</p>
<pre><code class="language-java">@Entity
public class Department {
    @Id
    private Long id;

    @OneToMany(mappedBy = &quot;department&quot;)
    private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();
}

@Entity
public class Employee {
    @Id
    private Long id;

    @ManyToOne
    @JoinColumn(name = &quot;department_id&quot;)
    private Department department;
}
</code></pre>
<p>The &quot;mappedBy&quot; side is the inverse (non-owning) side. The owner side contains the foreign key.</p>
<h3 id="66-what-are-transient-temporal-and-lob-annotations">66. What are @Transient, @Temporal, and @Lob annotations?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><code>@Transient</code>: Marks a field to be ignored by JPA (not persisted to database)</li>
    <li><code>@Temporal</code>: Specifies mapping for java.util.Date/Calendar fields (DATE, TIME, TIMESTAMP)</li>
    <li><code>@Lob</code>: Marks a field to be stored as a BLOB (Binary) or CLOB (Character) in the database</li>
</ul>
<pre><code class="language-java">@Entity
public class Employee {
    @Transient
    private BigDecimal calculatedBonus;

    @Temporal(TemporalType.DATE)
    private Date hireDate;

    @Lob
    private String description;

    @Lob
    private byte[] profilePicture;
}
</code></pre>
<h3 id="67-what-is-the-purpose-of-mappedsuperclass">67. What is the purpose of @MappedSuperclass?</h3>
<p><strong>Answer:</strong> <code>@MappedSuperclass</code> defines a class whose mappings are applied to entities that inherit from it. It&#39;s used for common fields across multiple entities:</p>
<pre><code class="language-java">@MappedSuperclass
public abstract class BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(updatable = false)
    private LocalDateTime createdAt;

    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

@Entity
public class Employee extends BaseEntity {
    private String name;
    // No need to define id, createdAt, updatedAt
}
</code></pre>
<p>Unlike <code>@Entity</code>, <code>@MappedSuperclass</code> is not queryable directly.</p>
<h3 id="68-what-is-the-difference-between-unidirectional-and-bidirectional-relationships">68. What is the difference between unidirectional and bidirectional relationships?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><strong>Unidirectional</strong>: Only one entity references the other</li>
    <li><strong>Bidirectional</strong>: Both entities reference each other</li>
</ul>
<p>Example unidirectional:</p>
<pre><code class="language-java">@Entity
public class Student {
    @ManyToMany
    @JoinTable(name = &quot;student_course&quot;)
    private List&lt;Course&gt; courses;
}

@Entity
public class Course {
    // No reference back to Student
}
</code></pre>
<p>Bidirectional relationships provide navigation from both sides but require proper synchronization to maintain consistency.</p>
<h3 id="69-what-is-the-entitygraph-api-in-jpa">69. What is the EntityGraph API in JPA?</h3>
<p><strong>Answer:</strong> EntityGraph API lets you dynamically specify which attributes to fetch, solving the N+1 problem without changing entity mappings:</p>
<pre><code class="language-java">// Define named entity graph
@Entity
@NamedEntityGraph(
    name = &quot;Department.withEmployees&quot;,
    attributeNodes = @NamedAttributeNode(&quot;employees&quot;)
)
public class Department { /*...*/ }

// Use named entity graph
EntityGraph&lt;?&gt; graph = em.getEntityGraph(&quot;Department.withEmployees&quot;);
Map&lt;String, Object&gt; hints = new HashMap&lt;&gt;();
hints.put(&quot;javax.persistence.fetchgraph&quot;, graph);
Department dept = em.find(Department.class, id, hints);

// Or create dynamic entity graph
EntityGraph&lt;Department&gt; graph = em.createEntityGraph(Department.class);
graph.addAttributeNodes(&quot;employees&quot;);
</code></pre>
<h3 id="70-what-is-the-purpose-of-prepersist-and-postload-annotations">70. What is the purpose of @PrePersist and @PostLoad annotations?</h3>
<p><strong>Answer:</strong> These are JPA entity lifecycle callback annotations:</p>
<ul>
    <li><code>@PrePersist</code>: Method runs before an entity is persisted (inserted)</li>
    <li><code>@PostLoad</code>: Method runs after an entity is loaded from the database</li>
</ul>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    private Long id;
    private String name;
    private BigDecimal salary;
    @Transient
    private BigDecimal taxAmount;

    @PrePersist
    private void generateId() {
        if (id == null) {
            // Custom ID generation logic
        }
    }

    @PostLoad
    private void calculateDerivedFields() {
        taxAmount = salary.multiply(new BigDecimal(&quot;0.2&quot;));
    }
}
</code></pre>
<p>They&#39;re useful for default values, validation, and calculating derived properties.</p>

<h3 id="71-what-is-the-criteria-api-in-jpa">71. What is the criteria API in JPA?</h3>
<p><strong>Answer:</strong> The Criteria API is a type-safe, programmatic way to build queries in JPA. It helps create dynamic queries without string concatenation and provides compile-time checking:</p>
<pre><code class="language-java">CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery&lt;Employee&gt; cq = cb.createQuery(Employee.class);
Root&lt;Employee&gt; employee = cq.from(Employee.class);

// Where clause: department = &#39;IT&#39; and salary &gt; 50000
cq.select(employee)
  .where(
      cb.equal(employee.get(&quot;department&quot;).get(&quot;name&quot;), &quot;IT&quot;),
      cb.greaterThan(employee.get(&quot;salary&quot;), 50000)
  );

List&lt;Employee&gt; results = entityManager.createQuery(cq).getResultList();
</code></pre>
<p>It&#39;s useful for building filters dynamically based on user input.</p>
<h3 id="72-how-do-you-implement-a-custom-id-generator-in-hibernate">72. How do you implement a custom ID generator in Hibernate?</h3>
<p><strong>Answer:</strong> Create a custom ID generator by implementing the <code>IdentifierGenerator</code> interface:</p>
<pre><code class="language-java">public class CustomIdGenerator implements IdentifierGenerator {
    @Override
    public Serializable generate(SharedSessionContractImplementor session, Object object) {
        // Custom ID generation logic
        return &quot;CUST-&quot; + System.currentTimeMillis();
    }
}

@Entity
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.CUSTOM, generator = &quot;customId&quot;)
    @GenericGenerator(name = &quot;customId&quot;, strategy = &quot;com.example.CustomIdGenerator&quot;)
    private String id;
    // Other fields
}
</code></pre>
<p>This is useful for complex ID requirements like prefixed IDs or business rule-based identifiers.</p>
<h3 id="73-what-is-schema-generation-in-jpa">73. What is schema generation in JPA?</h3>
<p><strong>Answer:</strong> JPA can automatically create, update, or validate database schemas based on entity mappings. Configure it in persistence.xml:</p>
<pre><code class="language-xml">&lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt;
</code></pre>
<p>Values include:</p>
<ul>
    <li><code>create</code>: Drops and creates tables on startup</li>
    <li><code>update</code>: Updates schema to match entities</li>
    <li><code>validate</code>: Validates schema matches entities</li>
    <li><code>create-drop</code>: Creates schema on startup, drops on shutdown</li>
    <li><code>none</code>: No schema changes (default)</li>
</ul>
<p>For production, use <code>none</code> or <code>validate</code> to prevent accidental data loss.</p>
<h3 id="74-what-is-a-native-sql-named-query">74. What is a native SQL named query?</h3>
<p><strong>Answer:</strong> A native SQL named query is a predefined SQL query (not JPQL) that can be referenced by name:</p>
<pre><code class="language-java">@Entity
@NamedNativeQuery(
    name = &quot;Employee.findByDepartmentNative&quot;,
    query = &quot;SELECT * FROM employees WHERE department_id = :deptId&quot;,
    resultClass = Employee.class
)
public class Employee {
    // Entity fields
}

// Usage
Query query = entityManager.createNamedQuery(&quot;Employee.findByDepartmentNative&quot;);
query.setParameter(&quot;deptId&quot;, 10);
List&lt;Employee&gt; results = query.getResultList();
</code></pre>
<p>Use it when you need database-specific features not supported by JPQL.</p>
<h3 id="75-how-do-you-handle-date-and-time-fields-in-jpa">75. How do you handle date and time fields in JPA?</h3>
<p><strong>Answer:</strong> JPA provides several ways to handle date and time:</p>
<pre><code class="language-java">@Entity
public class Event {
    // For java.util.Date and Calendar
    @Temporal(TemporalType.DATE) // Just date without time
    private Date eventDate;

    @Temporal(TemporalType.TIME) // Just time without date
    private Date eventTime;

    @Temporal(TemporalType.TIMESTAMP) // Both date and time
    private Date createdAt;

    // For Java 8 and above (no @Temporal needed)
    private LocalDate localEventDate;
    private LocalTime localEventTime;
    private LocalDateTime localTimestamp;
    private ZonedDateTime zonedDateTime;
}
</code></pre>
<p>For Java 8 date/time types, you might need <code>hibernate-java8</code> dependency or a proper JPA provider that supports them.</p>
<h3 id="76-what-is-the-difference-between-elementcollection-and-onetomany">76. What is the difference between ElementCollection and OneToMany?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><code>@ElementCollection</code>: Maps a collection of simple types or embeddables (not entities)</li>
    <li><code>@OneToMany</code>: Maps a collection of entities</li>
</ul>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    private Long id;

    // Element collection of basic types
    @ElementCollection
    @CollectionTable(name = &quot;employee_phones&quot;, joinColumns = @JoinColumn(name = &quot;employee_id&quot;))
    @Column(name = &quot;phone_number&quot;)
    private Set&lt;String&gt; phoneNumbers = new HashSet&lt;&gt;();

    // Element collection of embeddables
    @ElementCollection
    @CollectionTable(name = &quot;employee_addresses&quot;, joinColumns = @JoinColumn(name = &quot;employee_id&quot;))
    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();

    // One-to-many relationship with entities
    @OneToMany(mappedBy = &quot;employee&quot;)
    private List&lt;Task&gt; tasks = new ArrayList&lt;&gt;();
}
</code></pre>
<p>ElementCollection is simpler but doesn&#39;t allow the collection elements to be referenced independently.</p>
<h3 id="77-what-is-flush-mode-in-jpa-and-what-are-the-available-modes">77. What is flush mode in JPA and what are the available modes?</h3>
<p><strong>Answer:</strong> Flush mode determines when JPA sends SQL to the database to synchronize entity state. Available modes in <code>FlushModeType</code>:</p>
<ul>
    <li><code>AUTO</code> (default): Automatically flushes before queries and at transaction commit</li>
    <li><code>COMMIT</code>: Flushes only at transaction commit, not before queries</li>
</ul>
<p>Set it with:</p>
<pre><code class="language-java">entityManager.setFlushMode(FlushModeType.COMMIT);
</code></pre>
<p>COMMIT mode can improve performance for read-heavy operations by reducing unnecessary flushes, but can return stale data from queries if entities were modified but not flushed.</p>
<h3 id="78-how-do-you-map-a-map-collection-in-jpa">78. How do you map a Map collection in JPA?</h3>
<p><strong>Answer:</strong> JPA supports mapping Map collections using <code>@ElementCollection</code> for simple values or <code>@OneToMany</code>/<code>@ManyToMany</code> for entity values:</p>
<pre><code class="language-java">@Entity
public class Department {
    @Id
    private Long id;

    // Map of primitive values
    @ElementCollection
    @CollectionTable(name = &quot;department_attributes&quot;)
    @MapKeyColumn(name = &quot;attribute_name&quot;)
    @Column(name = &quot;attribute_value&quot;)
    private Map&lt;String, String&gt; attributes = new HashMap&lt;&gt;();

    // Map with entity values and string keys
    @OneToMany(cascade = CascadeType.ALL)
    @JoinColumn(name = &quot;department_id&quot;)
    @MapKeyColumn(name = &quot;position_title&quot;)
    private Map&lt;String, Employee&gt; employeesByPosition = new HashMap&lt;&gt;();

    // Map with entity keys and entity values
    @ManyToMany
    @JoinTable(name = &quot;mentor_apprentice&quot;)
    @MapKeyJoinColumn(name = &quot;apprentice_id&quot;)
    private Map&lt;Employee, Employee&gt; mentorships = new HashMap&lt;&gt;();
}
</code></pre>
<h3 id="79-what-is-the-difference-between-merge-and-update-in-hibernate">79. What is the difference between merge() and update() in Hibernate?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><code>merge()</code>: JPA standard method that creates a new managed instance with detached entity&#39;s state</li>
    <li><code>update()</code>: Hibernate-specific method that reattaches the specific entity instance</li>
</ul>
<p>Key differences:</p>
<ol>
    <li><code>merge()</code> returns a new instance, while <code>update()</code> makes the passed instance managed</li>
    <li><code>merge()</code> works with both transient and detached entities, but <code>update()</code> only with detached</li>
    <li><code>merge()</code> copies state to existing managed entity if found by ID</li>
</ol>
<pre><code class="language-java">// merge() - returns new managed instance
Employee detached = getDetachedEmployee();
detached.setName(&quot;New Name&quot;);
Employee managed = entityManager.merge(detached);
// detached is still detached, managed is the persistent entity

// update() - makes passed instance managed
Session session = entityManager.unwrap(Session.class);
Employee detached = getDetachedEmployee();
detached.setName(&quot;New Name&quot;);
session.update(detached);
// detached is now managed
</code></pre>
<h3 id="80-what-are-derived-queries-in-spring-data-jpa">80. What are derived queries in Spring Data JPA?</h3>
<p><strong>Answer:</strong> Derived queries in Spring Data JPA are methods that automatically generate query implementations based on their names:</p>
<pre><code class="language-java">public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {
    // Finds employees by name
    List&lt;Employee&gt; findByName(String name);

    // More complex derived query
    List&lt;Employee&gt; findByDepartmentNameAndSalaryGreaterThan(String deptName, BigDecimal salary);

    // Ordering results
    List&lt;Employee&gt; findByActiveOrderByNameAsc(boolean active);

    // Pagination
    Page&lt;Employee&gt; findByDepartmentId(Long deptId, Pageable pageable);

    // Limiting results
    List&lt;Employee&gt; findTop3ByOrderBySalaryDesc();
}
</code></pre>
<p>No query implementation needed - Spring creates the queries at runtime by parsing the method names according to a specific pattern.</p>


<h3 id="81-how-does-jpa-integrate-with-spring-framework">81. How does JPA integrate with Spring Framework?</h3>
<p><strong>Answer:</strong> Spring Framework provides comprehensive support for JPA through:</p>
<ul>
    <li><code>JpaTransactionManager</code> for transaction management</li>
    <li><code>@Repository</code> component scanning and exception translation</li>
    <li><code>JpaTemplate</code> (older) and direct EntityManager injection</li>
    <li><code>@EnableJpaRepositories</code> for Spring Data JPA integration</li>
    <li><code>LocalContainerEntityManagerFactoryBean</code> for configuring EntityManagerFactory</li>
    <li>XML or Java-based configuration options</li>
</ul>
<p>Example configuration:</p>
<pre><code class="language-java">@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(&quot;com.example.repository&quot;)
public class JpaConfig {
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        // EntityManager configuration
    }

    @Bean
    public PlatformTransactionManager transactionManager() {
        return new JpaTransactionManager(entityManagerFactory().getObject());
    }
}
</code></pre>
<h3 id="82-what-is-spring-data-jpa-projection">82. What is Spring Data JPA projection?</h3>
<p><strong>Answer:</strong> Spring Data JPA projections allow returning only specific fields from entities instead of entire objects. There are two types:</p>
<ol>
    <li><strong>Interface-based projections</strong>:</li>
</ol>
<pre><code class="language-java">// Projection interface
public interface EmployeeNameView {
    String getName();
    String getEmail();
}

// Repository method
public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {
    List&lt;EmployeeNameView&gt; findByDepartmentName(String department);
}
</code></pre>
<ol start="2">
    <li><strong>Class-based projections</strong> (DTOs):</li>
</ol>
<pre><code class="language-java">// DTO class
public class EmployeeDTO {
    private final String name;
    private final String email;

    public EmployeeDTO(String name, String email) {
        this.name = name;
        this.email = email;
    }
    // getters
}

// Repository with constructor expression
public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {
    @Query(&quot;SELECT new com.example.EmployeeDTO(e.name, e.email) FROM Employee e WHERE e.department.name = :dept&quot;)
    List&lt;EmployeeDTO&gt; findByDepartment(@Param(&quot;dept&quot;) String department);
}
</code></pre>
<h3 id="83-how-do-you-configure-jpa-in-a-spring-boot-application">83. How do you configure JPA in a Spring Boot application?</h3>
<p><strong>Answer:</strong> Spring Boot auto-configures JPA with minimal setup:</p>
<ol>
    <li>Add dependencies:</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;!-- or any other DB driver --&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
    <li>Configure properties in application.properties/yml:</li>
</ol>
<pre><code class="language-properties">spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=user
spring.datasource.password=password
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
</code></pre>
<ol start="3">
    <li>Create entity classes and repositories:</li>
</ol>
<pre><code class="language-java">@Entity
public class Employee { /* fields and methods */ }

@Repository
public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; { }
</code></pre>
<p>Spring Boot automatically sets up EntityManagerFactory, TransactionManager, and repositories.</p>
<h3 id="84-what-is-the-difference-between-persistencecontext-and-autowired-for-entitymanager-injection">84. What is the difference between @PersistenceContext and @Autowired for EntityManager injection?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><code>@PersistenceContext</code> is a JPA standard annotation that provides container-managed EntityManager</li>
    <li><code>@Autowired</code> is a Spring annotation for general dependency injection</li>
</ul>
<p>Key differences:</p>
<ol>
    <li><code>@PersistenceContext</code> creates a proxy that&#39;s aware of the current transaction context</li>
    <li>With <code>@PersistenceContext</code>, each transaction gets a different EntityManager instance</li>
    <li><code>@Autowired</code> would inject the same EntityManager (unless scoped)</li>
    <li><code>@PersistenceContext</code> integrates with JTA transactions automatically</li>
</ol>
<pre><code class="language-java">@Service
public class EmployeeService {
    // Recommended approach
    @PersistenceContext
    private EntityManager entityManager;

    // Alternative approach (works but less ideal)
    @Autowired
    private EntityManager autowiredEntityManager;
}
</code></pre>
<p>Always prefer <code>@PersistenceContext</code> for EntityManager injection.</p>
<h3 id="85-how-do-you-test-jpa-repositories-in-spring">85. How do you test JPA repositories in Spring?</h3>
<p><strong>Answer:</strong> Spring provides several ways to test JPA repositories:</p>
<ol>
    <li><strong>@DataJpaTest</strong> for focused repository tests:</li>
</ol>
<pre><code class="language-java">@DataJpaTest
class EmployeeRepositoryTest {
    @Autowired
    private EmployeeRepository repository;

    @Test
    void findByDepartment() {
        // Given
        Employee emp = new Employee(&quot;John&quot;, &quot;IT&quot;);
        repository.save(emp);

        // When
        List&lt;Employee&gt; found = repository.findByDepartmentName(&quot;IT&quot;);

        // Then
        assertEquals(1, found.size());
        assertEquals(&quot;John&quot;, found.get(0).getName());
    }
}
</code></pre>
<ol start="2">
    <li><strong>@SpringBootTest</strong> for integration tests:</li>
</ol>
<pre><code class="language-java">@SpringBootTest
class EmployeeIntegrationTest {
    @Autowired
    private EmployeeService service;

    @Test
    void transferDepartment() {
        // Test service method involving transactions
    }
}
</code></pre>
<p>Features include in-memory database, transaction rollback, custom test profile, and EntityManager access.</p>
<h3 id="86-what-is-query-by-example-in-spring-data-jpa">86. What is query by example in Spring Data JPA?</h3>
<p><strong>Answer:</strong> Query by Example (QBE) is a user-friendly querying technique that uses domain objects as examples to match:</p>
<pre><code class="language-java">public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt;, QueryByExampleExecutor&lt;Employee&gt; { }

// Usage
Employee example = new Employee();
example.setDepartment(new Department(&quot;IT&quot;));
example.setActive(true);

// Create matcher with additional options
ExampleMatcher matcher = ExampleMatcher.matching()
    .withIgnorePaths(&quot;salary&quot;)         // Ignore null and 0 values
    .withStringMatcher(StringMatcher.CONTAINING); // For String fields

Example&lt;Employee&gt; query = Example.of(example, matcher);
List&lt;Employee&gt; results = employeeRepository.findAll(query);
</code></pre>
<p>QBE is useful for dynamic queries without writing complex specifications.</p>
<h3 id="87-what-is-the-difference-between-jpa-and-spring-data-jpa">87. What is the difference between JPA and Spring Data JPA?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><strong>JPA</strong> is the Java standard specification (API) for ORM</li>
    <li><strong>Spring Data JPA</strong> is a Spring abstraction built on top of JPA</li>
</ul>
<p>Key differences:</p>
<ol>
    <li>JPA defines the EntityManager, annotations, and JPQL</li>
    <li>Spring Data JPA adds repository abstraction, method name queries, and pagination</li>
    <li>JPA requires more boilerplate code for repositories</li>
    <li>Spring Data JPA automatically implements common CRUD operations</li>
    <li>Spring Data JPA provides additional features like projections, auditing, query by example</li>
</ol>
<p>JPA example:</p>
<pre><code class="language-java">@PersistenceContext
private EntityManager em;

public List&lt;Employee&gt; findByDepartment(String dept) {
    return em.createQuery(&quot;SELECT e FROM Employee e WHERE e.department.name = :dept&quot;, Employee.class)
        .setParameter(&quot;dept&quot;, dept)
        .getResultList();
}
</code></pre>
<p>Spring Data JPA equivalent:</p>
<pre><code class="language-java">public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {
    List&lt;Employee&gt; findByDepartmentName(String departmentName);
}
</code></pre>
<h3 id="88-how-do-you-use-native-queries-with-named-parameters-in-jpa">88. How do you use native queries with named parameters in JPA?</h3>
<p><strong>Answer:</strong> Native SQL queries with named parameters can be created using <code>@Query</code> annotation:</p>
<pre><code class="language-java">// In repository interface
@Query(value = &quot;SELECT * FROM employees e WHERE e.department_id = :deptId AND e.salary &gt; :minSalary&quot;,
       nativeQuery = true)
List&lt;Employee&gt; findByDepartmentAndSalary(@Param(&quot;deptId&quot;) Long deptId,
                                        @Param(&quot;minSalary&quot;) BigDecimal minSalary);

// With EntityManager
Query query = entityManager.createNativeQuery(
    &quot;SELECT * FROM employees WHERE hire_date BETWEEN :startDate AND :endDate&quot;, Employee.class);
query.setParameter(&quot;startDate&quot;, startDate, TemporalType.DATE);
query.setParameter(&quot;endDate&quot;, endDate, TemporalType.DATE);
List&lt;Employee&gt; results = query.getResultList();
</code></pre>
<p>Named parameters make queries more readable and less prone to parameter position errors.</p>
<h3 id="89-what-is-the-difference-between-fetchmode-and-fetchtype">89. What is the difference between FetchMode and FetchType?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><strong>FetchType</strong> is a JPA standard enum (EAGER, LAZY) defining when associations are loaded</li>
    <li><strong>FetchMode</strong> is Hibernate-specific (SELECT, JOIN, SUBSELECT) defining how associations are loaded</li>
</ul>
<pre><code class="language-java">// FetchType (JPA standard)
@OneToMany(mappedBy = &quot;department&quot;, fetch = FetchType.LAZY)
private List&lt;Employee&gt; employees;

// FetchMode (Hibernate specific)
@OneToMany(mappedBy = &quot;department&quot;)
@Fetch(FetchMode.SUBSELECT)
private List&lt;Employee&gt; employees;
</code></pre>
<p>FetchMode options:</p>
<ul>
    <li>SELECT: Default, one query per association (N+1 issue)</li>
    <li>JOIN: Single query with join (similar to fetch join)</li>
    <li>SUBSELECT: Load all collections for all parent entities in one subselect query</li>
</ul>
<h3 id="90-how-do-you-configure-a-connection-pool-with-hibernate-in-spring">90. How do you configure a connection pool with Hibernate in Spring?</h3>
<p><strong>Answer:</strong> Configure a connection pool in Spring with Hibernate using properties or Java config:</p>
<ol>
    <li><strong>Using HikariCP</strong> (Spring Boot default):</li>
</ol>
<pre><code class="language-properties"># application.properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=user
spring.datasource.password=password
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
</code></pre>
<ol start="2">
    <li><strong>Java Configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class DataSourceConfig {
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/mydb&quot;);
        config.setUsername(&quot;user&quot;);
        config.setPassword(&quot;password&quot;);
        config.setMaximumPoolSize(20);
        config.setMinimumIdle(5);
        return new HikariDataSource(config);
    }
}
</code></pre>
<p>Connection pools improve performance by reusing database connections instead of creating new ones for each request.</p>
<h3 id="91-what-are-common-causes-of-the-lazyinitializationexception">91. What are common causes of the LazyInitializationException?</h3>
<p><strong>Answer:</strong> LazyInitializationException occurs when trying to access a lazily-loaded association outside a persistence context. Common causes include:</p>
<ol>
    <li>Accessing lazy collections after the session is closed</li>
    <li>Returning entities from services and accessing their lazy associations in controllers/views</li>
    <li>Using lazy-loaded entities in async operations after transaction completion</li>
    <li>Serializing entities with lazy associations (like in REST APIs)</li>
</ol>
<p>Fix by using eager fetching, join fetches, entity graphs, or keeping the session open with OpenSessionInView (with caution).</p>
<h3 id="92-how-do-you-implement-an-audit-trail-with-jpa">92. How do you implement an audit trail with JPA?</h3>
<p><strong>Answer:</strong> Implement an audit trail using:</p>
<ol>
    <li><strong>Spring Data JPA Auditing</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableJpaAuditing
public class AuditConfig {
    @Bean
    public AuditorAware&lt;String&gt; auditorProvider() {
        return () -&gt; Optional.ofNullable(SecurityContextHolder.getContext())
            .map(context -&gt; context.getAuthentication().getName())
            .or(() -&gt; Optional.of(&quot;system&quot;));
    }
}

@Entity
@EntityListeners(AuditingEntityListener.class)
public class Employee {
    @CreatedBy
    private String createdBy;

    @CreatedDate
    private LocalDateTime createdDate;

    @LastModifiedBy
    private String lastModifiedBy;

    @LastModifiedDate
    private LocalDateTime lastModifiedDate;
}
</code></pre>
<ol start="2">
    <li><strong>Hibernate Envers</strong> for full history tracking</li>
</ol>
<h3 id="93-what-is-the-difference-between-hibernate-and-jpa">93. What is the difference between Hibernate and JPA?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><strong>JPA</strong> (Java Persistence API) is a standard specification for ORM in Java</li>
    <li><strong>Hibernate</strong> is an implementation of the JPA specification</li>
</ul>
<p>Key differences:</p>
<ol>
    <li>JPA is just an interface/specification; Hibernate provides concrete implementation</li>
    <li>Hibernate has features beyond JPA (natural IDs, filters, custom SQL operations)</li>
    <li>JPA uses <code>javax.persistence.*</code> or <code>jakarta.persistence.*</code> packages; Hibernate adds <code>org.hibernate.*</code></li>
    <li>JPA ensures portability across providers; Hibernate-specific features create vendor lock-in</li>
    <li>Hibernate existed before JPA and influenced its design</li>
</ol>
<h3 id="94-how-does-hibernate-dirty-checking-work">94. How does Hibernate dirty checking work?</h3>
<p><strong>Answer:</strong> Hibernate&#39;s dirty checking mechanism:</p>
<ol>
    <li>When loading an entity, Hibernate creates a snapshot of its state</li>
    <li>Before flushing/committing, it compares current state with the snapshot</li>
    <li>If differences are detected, SQL UPDATE statements are generated</li>
    <li>Only changed properties are included in the UPDATE statement (if dynamic update is enabled)</li>
</ol>
<p>This automatic change detection eliminates the need for explicit update() calls. Dirty checking only works for managed entities within a persistence context.</p>
<h3 id="95-what-are-the-ways-to-improve-hibernate-performance">95. What are the ways to improve Hibernate performance?</h3>
<p><strong>Answer:</strong> Ways to improve Hibernate performance:</p>
<ol>
    <li>Use appropriate fetch strategies (lazy loading by default)</li>
    <li>Solve N+1 queries with join fetches or entity graphs</li>
    <li>Use projection queries (DTOs) to fetch only needed data</li>
    <li>Enable second-level caching for read-heavy entities</li>
    <li>Use batch processing for bulk operations</li>
    <li>Set JDBC batch size for multiple inserts/updates</li>
    <li>Use pagination for large result sets</li>
    <li>Choose efficient ID generation strategies (SEQUENCE over IDENTITY)</li>
    <li>Enable query caching for frequent identical queries</li>
    <li>Use read-only transactions when appropriate</li>
</ol>
<h3 id="96-how-do-you-handle-composite-primary-keys-with-spring-data-jpa">96. How do you handle composite primary keys with Spring Data JPA?</h3>
<p><strong>Answer:</strong></p>
<ol>
    <li>Create an ID class with <code>@Embeddable</code> or implement <code>Serializable</code></li>
    <li>Reference it in the entity with <code>@EmbeddedId</code> or <code>@IdClass</code></li>
    <li>Repository interface extends <code>JpaRepository&lt;Entity, IdClass&gt;</code></li>
</ol>
<pre><code class="language-java">@Embeddable
public class OrderItemId implements Serializable {
    private Long orderId;
    private Long productId;
    // equals, hashCode, getters, setters
}

@Entity
public class OrderItem {
    @EmbeddedId
    private OrderItemId id;

    private Integer quantity;
    // other fields and methods
}

public interface OrderItemRepository extends JpaRepository&lt;OrderItem, OrderItemId&gt; {
    List&lt;OrderItem&gt; findByIdOrderId(Long orderId);
}
</code></pre>
<h3 id="97-how-do-you-implement-soft-delete-in-spring-data-jpa">97. How do you implement soft delete in Spring Data JPA?</h3>
<p><strong>Answer:</strong> Implement soft delete using:</p>
<ol>
    <li><strong>@SQLDelete and @Where annotations</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@SQLDelete(sql = &quot;UPDATE employees SET deleted = true WHERE id = ?&quot;)
@Where(clause = &quot;deleted = false&quot;)
public class Employee {
    @Id
    private Long id;
    private boolean deleted = false;
}
</code></pre>
<ol start="2">
    <li><strong>Spring Data JPA filters</strong>:</li>
</ol>
<pre><code class="language-java">public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {
    @Override
    @Query(&quot;UPDATE Employee e SET e.deleted = true WHERE e.id = ?1&quot;)
    void deleteById(Long id);

    @Override
    default void delete(Employee employee) {
        employee.setDeleted(true);
        save(employee);
    }

    // Find including deleted
    @Query(&quot;SELECT e FROM Employee e WHERE e.id = ?1&quot;)
    Optional&lt;Employee&gt; findByIdIncludingDeleted(Long id);
}
</code></pre>
<p>Soft delete preserves data for auditing while hiding it from normal queries.</p>
<h3 id="98-what-is-the-difference-between-table-sequence-identity-and-auto-generation-types">98. What is the difference between TABLE, SEQUENCE, IDENTITY and AUTO generation types?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><strong>IDENTITY</strong>: Uses database auto-increment columns (MySQL AUTO_INCREMENT, SQL Server IDENTITY)<ul>
        <li>Simple but inefficient for batch inserts (can&#39;t batch as ID is known only after insert)</li>
    </ul>
    </li>
    <li><strong>SEQUENCE</strong>: Uses database sequence objects (Oracle, PostgreSQL)<ul>
        <li>Efficient for batching as IDs are pre-allocated</li>
        <li>Requires sequence support in database</li>
    </ul>
    </li>
    <li><strong>TABLE</strong>: Uses a dedicated table to simulate a sequence<ul>
        <li>Works on any database but has performance overhead</li>
        <li>Useful for legacy databases without sequence support</li>
    </ul>
    </li>
    <li><strong>AUTO</strong>: Provider chooses appropriate strategy based on database<ul>
        <li>Default strategy, delegates choice to Hibernate</li>
    </ul>
    </li>
</ul>
<pre><code class="language-java">// Sequence example
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;emp_seq&quot;)
@SequenceGenerator(name = &quot;emp_seq&quot;, sequenceName = &quot;EMPLOYEE_SEQ&quot;, allocationSize = 50)
private Long id;
</code></pre>
<h3 id="99-how-do-you-debug-hibernate-generated-sql">99. How do you debug Hibernate-generated SQL?</h3>
<p><strong>Answer:</strong> Debug Hibernate SQL by:</p>
<ol>
    <li><strong>Enabling SQL logging</strong>:</li>
</ol>
<pre><code class="language-properties"># In application.properties
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
</code></pre>
<ol start="2">
    <li><strong>Using StatisticsService</strong>:</li>
</ol>
<pre><code class="language-java">@Service
public class HibernateStatisticsService {
    @PersistenceContext
    private EntityManager entityManager;

    public void logStatistics() {
        Session session = entityManager.unwrap(Session.class);
        SessionFactory factory = session.getSessionFactory();
        Statistics stats = factory.getStatistics();

        log.info(&quot;Query executions: {}&quot;, stats.getQueryExecutionCount());
        log.info(&quot;Entities loaded: {}&quot;, stats.getEntityLoadCount());
    }
}
</code></pre>
<ol start="3">
    <li><strong>Using P6Spy</strong> for database monitoring</li>
</ol>
<h3 id="100-what-are-the-best-practices-for-using-jpa-in-a-microservices-architecture">100. What are the best practices for using JPA in a microservices architecture?</h3>
<p><strong>Answer:</strong> Best practices for JPA in microservices:</p>
<ol>
    <li><strong>Keep persistence contexts short-lived</strong> - don&#39;t span service boundaries</li>
    <li><strong>Use DTOs for service boundaries</strong> instead of passing entities</li>
    <li><strong>Each microservice should own its database</strong> and not directly access others</li>
    <li><strong>Use event-based communication</strong> for cross-service data consistency</li>
    <li><strong>Consider using read-models or CQRS</strong> for complex queries</li>
    <li><strong>Keep entities small and focused</strong> on the microservice&#39;s domain</li>
    <li><strong>Be cautious with distributed transactions</strong> - consider eventual consistency</li>
    <li><strong>Use lightweight JPA implementation</strong> like Hibernate with Spring Boot</li>
    <li><strong>Apply proper connection pooling</strong> for efficiency</li>
    <li><strong>Containerize with appropriate memory settings</strong> for JVM and Hibernate</li>
</ol>
<p>These practices help maintain service independence and scalability while leveraging JPA&#39;s benefits.</p>

<h3 id="101-what-is-hibernate-envers-and-how-is-it-used">101. What is Hibernate Envers and how is it used?</h3>
<p><strong>Answer:</strong> Hibernate Envers is an auditing solution that automatically tracks historical changes to entities. It creates audit tables that store all versions of entity data:</p>
<pre><code class="language-java">@Entity
@Audited
public class Employee {
    @Id
    private Long id;
    private String name;
    private BigDecimal salary;
}
</code></pre>
<p>This creates an <code>employee_aud</code> table and <code>revinfo</code> table. You can query historical data using AuditReader:</p>
<pre><code class="language-java">AuditReader reader = AuditReaderFactory.get(entityManager);
Employee oldVersion = reader.find(Employee.class, employeeId, revisionNumber);
</code></pre>
<p>Envers simplifies compliance requirements and provides built-in data history.</p>
<h3 id="102-what-is-attribute-converter-in-jpa">102. What is attribute converter in JPA?</h3>
<p><strong>Answer:</strong> Attribute converter allows custom conversion between database column values and entity attribute types:</p>
<pre><code class="language-java">@Converter
public class BooleanToYNConverter implements AttributeConverter&lt;Boolean, String&gt; {
    @Override
    public String convertToDatabaseColumn(Boolean attribute) {
        return (attribute != null &amp;&amp; attribute) ? &quot;Y&quot; : &quot;N&quot;;
    }

    @Override
    public Boolean convertToEntityAttribute(String dbData) {
        return &quot;Y&quot;.equals(dbData);
    }
}

@Entity
public class User {
    @Convert(converter = BooleanToYNConverter.class)
    private Boolean active;
}
</code></pre>
<p>This is useful for legacy databases, custom data formats, or encryption/decryption of sensitive data.</p>
<h3 id="103-what-is-a-discriminator-column">103. What is a discriminator column?</h3>
<p><strong>Answer:</strong> A discriminator column is used in single-table inheritance to identify which concrete class a row represents:</p>
<pre><code class="language-java">@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = &quot;employee_type&quot;)
public abstract class Employee {
    @Id
    private Long id;
    private String name;
}

@Entity
@DiscriminatorValue(&quot;FTE&quot;)
public class FullTimeEmployee extends Employee {
    private BigDecimal salary;
}

@Entity
@DiscriminatorValue(&quot;TEMP&quot;)
public class TemporaryEmployee extends Employee {
    private BigDecimal hourlyRate;
}
</code></pre>
<p>All subclass data is stored in one table with a column indicating the specific type.</p>
<h3 id="104-what-is-a-database-view-and-how-can-you-map-it-in-jpa">104. What is a database view and how can you map it in JPA?</h3>
<p><strong>Answer:</strong> A database view is a stored query that acts like a virtual table. Map it in JPA using:</p>
<pre><code class="language-java">@Entity
@Immutable
@Table(name = &quot;employee_summary_view&quot;)
@Subselect(&quot;SELECT e.id, e.name, d.name as department, e.salary &quot; +
           &quot;FROM employees e JOIN departments d ON e.department_id = d.id&quot;)
public class EmployeeSummary {
    @Id
    private Long id;
    private String name;
    private String department;
    private BigDecimal salary;

    // getters only (immutable)
}
</code></pre>
<p>The <code>@Immutable</code> annotation indicates that the entity is read-only since views typically cannot be updated directly.</p>
<h3 id="105-what-is-the-difference-between-cascadetypeall-and-orphanremovaltrue">105. What is the difference between CascadeType.ALL and orphanRemoval=true?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><strong>CascadeType.ALL</strong>: Propagates all entity operations (PERSIST, MERGE, REMOVE, REFRESH, DETACH) to related entities</li>
    <li><strong>orphanRemoval=true</strong>: Removes child entities when they&#39;re no longer referenced by the parent</li>
</ul>
<pre><code class="language-java">@Entity
public class Department {
    @Id
    private Long id;

    // Both options
    @OneToMany(mappedBy = &quot;department&quot;, cascade = CascadeType.ALL, orphanRemoval = true)
    private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();
}
</code></pre>
<p>Key differences:</p>
<ol>
    <li>CascadeType.ALL affects operations between parent and attached children</li>
    <li>orphanRemoval removes children when they&#39;re removed from the collection</li>
    <li>CascadeType.REMOVE deletes children when parent is deleted</li>
    <li>orphanRemoval treats children as part of the parent&#39;s lifecycle</li>
</ol>
<h3 id="106-how-do-you-implement-custom-repository-methods-in-spring-data-jpa">106. How do you implement custom repository methods in Spring Data JPA?</h3>
<p><strong>Answer:</strong> Implement custom repository methods by:</p>
<ol>
    <li><strong>Creating a custom interface</strong>:</li>
</ol>
<pre><code class="language-java">public interface CustomEmployeeRepository {
    List&lt;Employee&gt; findEmployeesWithHighSalary(BigDecimal threshold);
}
</code></pre>
<ol start="2">
    <li><strong>Creating an implementation</strong>:</li>
</ol>
<pre><code class="language-java">public class CustomEmployeeRepositoryImpl implements CustomEmployeeRepository {
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public List&lt;Employee&gt; findEmployeesWithHighSalary(BigDecimal threshold) {
        return entityManager.createQuery(
            &quot;SELECT e FROM Employee e WHERE e.salary &gt; :threshold&quot;, Employee.class)
            .setParameter(&quot;threshold&quot;, threshold)
            .getResultList();
    }
}
</code></pre>
<ol start="3">
    <li><strong>Extending in main repository</strong>:</li>
</ol>
<pre><code class="language-java">public interface EmployeeRepository extends
    JpaRepository&lt;Employee, Long&gt;, CustomEmployeeRepository {
}
</code></pre>
<p>Spring Data automatically combines the implementations.</p>
<h3 id="107-what-is-the-purpose-of-dynamicupdate-and-dynamicinsert">107. What is the purpose of @DynamicUpdate and @DynamicInsert?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><strong>@DynamicUpdate</strong>: Generates SQL UPDATE statements that only include changed columns</li>
    <li><strong>@DynamicInsert</strong>: Generates SQL INSERT statements that only include non-null columns</li>
</ul>
<pre><code class="language-java">@Entity
@DynamicUpdate
@DynamicInsert
public class Employee {
    @Id
    private Long id;
    private String name;
    private BigDecimal salary;
    private String notes;
}
</code></pre>
<p>Benefits:</p>
<ol>
    <li>More efficient SQL statements with fewer columns</li>
    <li>Useful for tables with many columns where only a few are typically modified</li>
    <li>Reduces update conflicts in concurrent environments</li>
    <li>Avoids overwriting default values on insert</li>
</ol>
<p>These annotations can improve performance but add overhead for dynamic SQL generation.</p>
<h3 id="108-what-is-bootstrapping-in-hibernate">108. What is bootstrapping in Hibernate?</h3>
<p><strong>Answer:</strong> Bootstrapping is the process of initializing Hibernate and creating a SessionFactory or EntityManagerFactory. Two approaches:</p>
<ol>
    <li><strong>Native Hibernate bootstrapping</strong>:</li>
</ol>
<pre><code class="language-java">StandardServiceRegistry registry = new StandardServiceRegistryBuilder()
    .configure(&quot;hibernate.cfg.xml&quot;)
    .build();

SessionFactory sessionFactory = new MetadataSources(registry)
    .addAnnotatedClass(Employee.class)
    .buildMetadata()
    .buildSessionFactory();
</code></pre>
<ol start="2">
    <li><strong>JPA bootstrapping</strong>:</li>
</ol>
<pre><code class="language-java">EntityManagerFactory emf = Persistence
    .createEntityManagerFactory(&quot;persistence-unit-name&quot;);
</code></pre>
<ol start="3">
    <li><strong>Spring Boot bootstrapping</strong> (automatic):</li>
</ol>
<pre><code class="language-java">// Just add dependencies and properties, Spring Boot handles the rest
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<p>Bootstrapping sets up connection pools, caches, and other essential Hibernate services.</p>
<h3 id="109-what-is-the-purpose-of-formula-annotation-in-hibernate">109. What is the purpose of @Formula annotation in Hibernate?</h3>
<p><strong>Answer:</strong> <code>@Formula</code> allows you to define a read-only computed property using a SQL expression:</p>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    private Long id;
    private BigDecimal baseSalary;
    private BigDecimal commission;

    @Formula(&quot;base_salary + commission&quot;)
    private BigDecimal totalCompensation;

    @Formula(&quot;(SELECT COUNT(t.id) FROM tasks t WHERE t.employee_id = id)&quot;)
    private int taskCount;

    // getters
}
</code></pre>
<p>Benefits:</p>
<ol>
    <li>Database computes values instead of Java</li>
    <li>Can leverage database functions and complex calculations</li>
    <li>Reduces query complexity and data transfer</li>
    <li>Properties are automatically available in JPQL queries</li>
</ol>
<p>Formula properties are read-only and calculated when entity is loaded.</p>
<h3 id="110-how-do-you-implement-multi-tenancy-in-hibernate">110. How do you implement multi-tenancy in Hibernate?</h3>
<p><strong>Answer:</strong> Hibernate supports three multi-tenancy strategies:</p>
<ol>
    <li><strong>Database per tenant</strong>:</li>
</ol>
<pre><code class="language-properties">hibernate.multiTenancy=DATABASE
hibernate.multi_tenant_connection_provider=com.example.MultiTenantConnectionProviderImpl
hibernate.tenant_identifier_resolver=com.example.CurrentTenantIdentifierResolverImpl
</code></pre>
<ol start="2">
    <li><strong>Schema per tenant</strong>:</li>
</ol>
<pre><code class="language-properties">hibernate.multiTenancy=SCHEMA
hibernate.multi_tenant_connection_provider=com.example.SchemaMultiTenantConnectionProvider
hibernate.tenant_identifier_resolver=com.example.CurrentTenantIdentifierResolverImpl
</code></pre>
<ol start="3">
    <li><strong>Partitioned data (discriminator column)</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@FilterDef(name = &quot;tenantFilter&quot;, parameters = @ParamDef(name = &quot;tenantId&quot;, type = &quot;string&quot;))
@Filter(name = &quot;tenantFilter&quot;, condition = &quot;tenant_id = :tenantId&quot;)
public class Employee {
    @Id
    private Long id;
    private String tenantId;
}

// Enable filter in session
session.enableFilter(&quot;tenantFilter&quot;).setParameter(&quot;tenantId&quot;, currentTenant);
</code></pre>
<p>Each strategy offers different isolation levels and implementation complexity based on your multi-tenancy requirements.</p>
<h3 id="111-what-is-the-namedentitygraph-annotation-used-for">111. What is the @NamedEntityGraph annotation used for?</h3>
<p><strong>Answer:</strong> <code>@NamedEntityGraph</code> defines reusable entity graphs that specify which attributes to fetch eagerly. It helps solve the N+1 query problem without changing entity mappings:</p>
<pre><code class="language-java">@Entity
@NamedEntityGraph(
    name = &quot;Department.withEmployees&quot;,
    attributeNodes = {
        @NamedAttributeNode(&quot;employees&quot;)
    }
)
public class Department {
    @Id
    private Long id;
    private String name;

    @OneToMany(mappedBy = &quot;department&quot;)
    private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();
}

// Usage
EntityGraph&lt;?&gt; graph = entityManager.getEntityGraph(&quot;Department.withEmployees&quot;);
Map&lt;String, Object&gt; hints = new HashMap&lt;&gt;();
hints.put(&quot;javax.persistence.fetchgraph&quot;, graph);

Department dept = entityManager.find(Department.class, id, hints);
// employees are loaded eagerly in a single query
</code></pre>
<h3 id="112-what-is-the-difference-between-persist-and-merge-in-jpa">112. What is the difference between persist() and merge() in JPA?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><code>persist()</code>: Makes a new entity managed and persistent</li>
    <li><code>merge()</code>: Updates the persistent store with detached entity state</li>
</ul>
<p>Key differences:</p>
<ol>
    <li><code>persist()</code> is for new entities; <code>merge()</code> for detached entities</li>
    <li><code>persist()</code> returns void; <code>merge()</code> returns a managed copy</li>
    <li><code>persist()</code> throws exception if entity has ID; <code>merge()</code> doesn&#39;t</li>
    <li><code>merge()</code> creates a copy; <code>persist()</code> makes the actual entity managed</li>
</ol>
<pre><code class="language-java">// persist() - for new entities
Employee newEmployee = new Employee(&quot;John&quot;);
entityManager.persist(newEmployee); // newEmployee is now managed

// merge() - for detached entities
Employee detached = getDetachedEmployee();
detached.setName(&quot;Updated Name&quot;);
Employee managed = entityManager.merge(detached); // detached stays detached
</code></pre>
<h3 id="113-what-is-the-purpose-of-columntransformer-in-hibernate">113. What is the purpose of @ColumnTransformer in Hibernate?</h3>
<p><strong>Answer:</strong> <code>@ColumnTransformer</code> allows specifying SQL expressions for reading/writing entity properties, enabling database-level transformations:</p>
<pre><code class="language-java">@Entity
public class User {
    @Id
    private Long id;

    private String username;

    @ColumnTransformer(
        read = &quot;UPPER(email)&quot;,             // When reading from DB
        write = &quot;LOWER(?)&quot;                 // When writing to DB
    )
    private String email;

    @ColumnTransformer(
        read = &quot;DECRYPT(credit_card_num)&quot;, // When reading from DB
        write = &quot;ENCRYPT(?)&quot;               // When writing to DB
    )
    @Column(name = &quot;credit_card_num&quot;)
    private String creditCardNumber;
}
</code></pre>
<p>It&#39;s useful for encryption/decryption, case normalization, and other database-level transformations.</p>
<h3 id="114-how-do-you-handle-database-migrations-with-jpa-applications">114. How do you handle database migrations with JPA applications?</h3>
<p><strong>Answer:</strong> Database migrations are typically managed using dedicated tools:</p>
<ol>
    <li><strong>Flyway</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class FlywayConfig {
    @Bean
    public Flyway flyway(DataSource dataSource) {
        Flyway flyway = Flyway.configure()
            .dataSource(dataSource)
            .locations(&quot;classpath:db/migration&quot;)
            .baselineOnMigrate(true)
            .load();
        flyway.migrate();
        return flyway;
    }
}
</code></pre>
<ol start="2">
    <li><strong>Liquibase</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;!-- Example changelog.xml --&gt;
&lt;databaseChangeLog&gt;
    &lt;changeSet id=&quot;1&quot; author=&quot;developer&quot;&gt;
        &lt;createTable tableName=&quot;employees&quot;&gt;
            &lt;column name=&quot;id&quot; type=&quot;bigint&quot; autoIncrement=&quot;true&quot;&gt;
                &lt;constraints primaryKey=&quot;true&quot; nullable=&quot;false&quot;/&gt;
            &lt;/column&gt;
            &lt;column name=&quot;name&quot; type=&quot;varchar(255)&quot;&gt;
                &lt;constraints nullable=&quot;false&quot;/&gt;
            &lt;/column&gt;
        &lt;/createTable&gt;
    &lt;/changeSet&gt;
&lt;/databaseChangeLog&gt;
</code></pre>
<ol start="3">
    <li><strong>Best practices</strong>:<ul>
        <li>Never use <code>hibernate.hbm2ddl.auto=update</code> in production</li>
        <li>Version control all migration scripts</li>
        <li>Test migrations before production deployment</li>
        <li>Include both schema changes and reference data</li>
    </ul>
    </li>
</ol>
<h3 id="115-what-is-query-timeout-and-how-do-you-configure-it-in-jpa">115. What is query timeout and how do you configure it in JPA?</h3>
<p><strong>Answer:</strong> Query timeout specifies the maximum time a query can run before being canceled. Configure it with:</p>
<ol>
    <li><strong>Per query</strong>:</li>
</ol>
<pre><code class="language-java">Query query = entityManager.createQuery(&quot;SELECT e FROM Employee e&quot;);
query.setHint(&quot;javax.persistence.query.timeout&quot;, 5000); // 5 seconds
List&lt;Employee&gt; results = query.getResultList();
</code></pre>
<ol start="2">
    <li><strong>In persistence.xml</strong>:</li>
</ol>
<pre><code class="language-xml">&lt;property name=&quot;javax.persistence.query.timeout&quot; value=&quot;5000&quot;/&gt;
</code></pre>
<ol start="3">
    <li><strong>In Spring Data repository methods</strong>:</li>
</ol>
<pre><code class="language-java">@QueryHints(@QueryHint(name = &quot;javax.persistence.query.timeout&quot;, value = &quot;5000&quot;))
List&lt;Employee&gt; findByDepartmentId(Long departmentId);
</code></pre>
<p>Query timeouts prevent long-running queries from blocking resources and help maintain application responsiveness.</p>
<h3 id="116-what-is-the-difference-between-direct-fetching-and-entity-queries">116. What is the difference between direct fetching and entity queries?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><strong>Direct fetching</strong> retrieves entities by ID using <code>find()</code>, <code>getReference()</code>, or <code>byId()</code> methods</li>
    <li><strong>Entity queries</strong> use JPQL or Criteria API to select entities based on conditions</li>
</ul>
<pre><code class="language-java">// Direct fetching - most efficient when ID is known
Employee employee = entityManager.find(Employee.class, 101L);

// Entity query - flexible but typically less efficient
TypedQuery&lt;Employee&gt; query = entityManager.createQuery(
    &quot;SELECT e FROM Employee e WHERE e.department.name = :dept&quot;, Employee.class);
query.setParameter(&quot;dept&quot;, &quot;IT&quot;);
List&lt;Employee&gt; employees = query.getResultList();
</code></pre>
<p>Direct fetching:</p>
<ol>
    <li>Takes advantage of caches</li>
    <li>Generates simpler SQL with primary key lookup</li>
    <li>More efficient for single record retrieval</li>
    <li>Less flexible (only works with known IDs)</li>
</ol>
<p>Entity queries allow filtering, projections, and joins but might be less efficient.</p>
<h3 id="117-what-is-a-natural-id-in-hibernate">117. What is a natural ID in Hibernate?</h3>
<p><strong>Answer:</strong> A natural ID is a unique, business-meaningful identifier that isn&#39;t the primary key. It&#39;s implemented using the <code>@NaturalId</code> annotation:</p>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    @GeneratedValue
    private Long id;

    @NaturalId
    private String employeeNumber;

    @NaturalId(mutable = true)
    private String email;

    private String name;
}

// Usage
Session session = entityManager.unwrap(Session.class);

// Load by natural ID
Employee employee = session.byNaturalId(Employee.class)
    .using(&quot;employeeNumber&quot;, &quot;EMP-1001&quot;)
    .load();
</code></pre>
<p>Natural IDs provide:</p>
<ol>
    <li>More efficient lookups than regular queries</li>
    <li>Special caching</li>
    <li>Better expression of business concepts</li>
    <li>Support for composite natural IDs</li>
</ol>
<h3 id="118-how-do-you-implement-pagination-with-spring-data-jpa">118. How do you implement pagination with Spring Data JPA?</h3>
<p><strong>Answer:</strong> Spring Data JPA offers several ways to implement pagination:</p>
<ol>
    <li><strong>Using Pageable parameter</strong>:</li>
</ol>
<pre><code class="language-java">public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {
    // Returns Page with content and metadata
    Page&lt;Employee&gt; findByDepartmentId(Long departmentId, Pageable pageable);

    // Returns just content
    List&lt;Employee&gt; findByDepartmentName(String departmentName, Pageable pageable);
}

// Usage
Pageable pageable = PageRequest.of(0, 20, Sort.by(&quot;lastName&quot;).ascending());
Page&lt;Employee&gt; page = employeeRepository.findByDepartmentId(deptId, pageable);

// Access page details
List&lt;Employee&gt; content = page.getContent();
int totalPages = page.getTotalPages();
long totalElements = page.getTotalElements();
</code></pre>
<ol start="2">
    <li><strong>Using Slice for more efficient next-page queries</strong>:</li>
</ol>
<pre><code class="language-java">Slice&lt;Employee&gt; slice = employeeRepository.findByLastNameStartingWith(&quot;S&quot;, pageable);
boolean hasNext = slice.hasNext();
</code></pre>
<ol start="3">
    <li><strong>Manual pagination with @Query</strong>:</li>
</ol>
<pre><code class="language-java">@Query(&quot;SELECT e FROM Employee e WHERE e.salary &gt; :minSalary&quot;)
List&lt;Employee&gt; findBySalaryPaginated(
    @Param(&quot;minSalary&quot;) BigDecimal minSalary,
    Pageable pageable);
</code></pre>
<h3 id="119-what-is-metamodel-in-jpa-and-how-is-it-used">119. What is metamodel in JPA and how is it used?</h3>
<p><strong>Answer:</strong> The JPA metamodel provides type-safe access to entity model attributes for use with the Criteria API:</p>
<pre><code class="language-java">// Generated metamodel class
@StaticMetamodel(Employee.class)
public class Employee_ {
    public static volatile SingularAttribute&lt;Employee, Long&gt; id;
    public static volatile SingularAttribute&lt;Employee, String&gt; name;
    public static volatile SingularAttribute&lt;Employee, Department&gt; department;
    public static volatile SingularAttribute&lt;Employee, BigDecimal&gt; salary;
}

// Using metamodel with Criteria API
CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery&lt;Employee&gt; cq = cb.createQuery(Employee.class);
Root&lt;Employee&gt; employee = cq.from(Employee.class);

// Type-safe path expressions
cq.select(employee)
  .where(cb.greaterThan(employee.get(Employee_.salary), minSalary))
  .orderBy(cb.asc(employee.get(Employee_.name)));
</code></pre>
<p>Benefits:</p>
<ol>
    <li>Compile-time checking of attribute names</li>
    <li>Refactoring safety (IDE rename refactoring works)</li>
    <li>Better IDE code completion</li>
    <li>Type safety for attribute types</li>
</ol>
<p>Generate metamodel classes using an annotation processor like Hibernate&#39;s <code>hibernate-jpamodelgen</code>.</p>
<h3 id="120-what-is-the-difference-between-loadgraph-and-fetchgraph-in-entitygraph">120. What is the difference between loadgraph and fetchgraph in EntityGraph?</h3>
<p><strong>Answer:</strong> Both are JPA entity graph hints that control which attributes to fetch eagerly, but they differ in how they handle attributes not specified in the graph:</p>
<ul>
    <li><strong>fetchgraph</strong>: Only loads attributes specified in the graph; others use their fetch type</li>
    <li><strong>loadgraph</strong>: Loads attributes specified in the graph plus others with EAGER fetch type</li>
</ul>
<pre><code class="language-java">EntityGraph&lt;Employee&gt; graph = entityManager.createEntityGraph(Employee.class);
graph.addAttributeNodes(&quot;department&quot;, &quot;projects&quot;);

Map&lt;String, Object&gt; hints = new HashMap&lt;&gt;();

// fetchgraph - ONLY loads department and projects eagerly
hints.put(&quot;javax.persistence.fetchgraph&quot;, graph);
Employee emp1 = entityManager.find(Employee.class, id, hints);

// loadgraph - loads department, projects, AND any EAGER attributes
hints.clear();
hints.put(&quot;javax.persistence.loadgraph&quot;, graph);
Employee emp2 = entityManager.find(Employee.class, id, hints);
</code></pre>
<p>Choose fetchgraph for stricter control over exactly what&#39;s fetched, and loadgraph when you want to add eager fetches without disrupting existing ones.</p>

<h3 id="121-what-are-bulk-operations-in-jpa-and-when-should-you-use-them">121. What are bulk operations in JPA and when should you use them?</h3>
<p><strong>Answer:</strong> Bulk operations in JPA execute direct SQL-like statements that modify multiple entities in a single operation. They&#39;re implemented using JPQL UPDATE or DELETE statements:</p>
<pre><code class="language-java">// Bulk update
int updatedCount = entityManager.createQuery(
    &quot;UPDATE Employee e SET e.status = :status WHERE e.department.id = :deptId&quot;)
    .setParameter(&quot;status&quot;, EmployeeStatus.ACTIVE)
    .setParameter(&quot;deptId&quot;, departmentId)
    .executeUpdate();

// Bulk delete
int deletedCount = entityManager.createQuery(
    &quot;DELETE FROM TemporaryEmployee e WHERE e.contractEnd &lt; :today&quot;)
    .setParameter(&quot;today&quot;, LocalDate.now())
    .executeUpdate();
</code></pre>
<p>Use bulk operations when:</p>
<ol>
    <li>You need to modify many entities efficiently</li>
    <li>The changes are simple and don&#39;t require entity-specific logic</li>
    <li>You want to avoid loading entities into memory</li>
</ol>
<p>Note that bulk operations bypass the persistence context, so entities in memory won&#39;t reflect these changes.</p>
<h3 id="122-what-is-the-entitymanagerclear-method-used-for">122. What is the EntityManager.clear() method used for?</h3>
<p><strong>Answer:</strong> The <code>clear()</code> method detaches all entities from the persistence context:</p>
<pre><code class="language-java">entityManager.clear();
</code></pre>
<p>Use it to:</p>
<ol>
    <li>Free memory during batch processing</li>
    <li>Avoid excessive persistence context growth</li>
    <li>Force reload of entities from database</li>
    <li>Reset the persistence context state after bulk operations</li>
</ol>
<pre><code class="language-java">// Example in batch processing
for (int i = 0; i &lt; items.size(); i++) {
    entityManager.persist(items.get(i));

    if (i % 50 == 0) {
        entityManager.flush();  // Send to database
        entityManager.clear();  // Clear persistence context
    }
}
</code></pre>
<h3 id="123-how-do-you-use-native-sql-functions-in-jpql-queries">123. How do you use native SQL functions in JPQL queries?</h3>
<p><strong>Answer:</strong> JPQL provides <code>function()</code> to call native database functions:</p>
<pre><code class="language-java">// Using database-specific function
TypedQuery&lt;Employee&gt; query = entityManager.createQuery(
    &quot;SELECT e FROM Employee e WHERE function(&#39;MONTH&#39;, e.hireDate) = :month&quot;,
    Employee.class);
query.setParameter(&quot;month&quot;, currentMonth);

// Using database-specific function in order by
TypedQuery&lt;String&gt; query = entityManager.createQuery(
    &quot;SELECT e.name FROM Employee e ORDER BY function(&#39;SOUNDEX&#39;, e.name)&quot;,
    String.class);
</code></pre>
<p>In Hibernate, you can also register custom functions:</p>
<pre><code class="language-java">// Configure in application properties
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.metadata_builder_contributor=com.example.SqlFunctionsMetadataBuilderContributor

// Contributor class
public class SqlFunctionsMetadataBuilderContributor implements MetadataBuilderContributor {
    @Override
    public void contribute(MetadataBuilder metadataBuilder) {
        metadataBuilder.applySqlFunction(&quot;MY_CUSTOM_FUNCTION&quot;,
            new StandardSQLFunction(&quot;my_custom_function&quot;, StringType.INSTANCE));
    }
}
</code></pre>
<h3 id="124-what-is-the-difference-between-querygetsingleresult-and-querygetresultlistget0">124. What is the difference between query.getSingleResult() and query.getResultList().get(0)?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><code>getSingleResult()</code>: Expects exactly one result; throws exceptions if zero or multiple results</li>
    <li><code>getResultList().get(0)</code>: Returns a list of results; get(0) returns the first element if exists</li>
</ul>
<pre><code class="language-java">try {
    // Throws NoResultException if no results
    // Throws NonUniqueResultException if multiple results
    Employee unique = entityManager.createQuery(
        &quot;SELECT e FROM Employee e WHERE e.email = :email&quot;, Employee.class)
        .setParameter(&quot;email&quot;, email)
        .getSingleResult();
} catch (NoResultException e) {
    // Handle no result
}

// Alternative approach
List&lt;Employee&gt; results = entityManager.createQuery(
    &quot;SELECT e FROM Employee e WHERE e.email = :email&quot;, Employee.class)
    .setParameter(&quot;email&quot;, email)
    .getResultList();
Employee employee = results.isEmpty() ? null : results.get(0);
</code></pre>
<p>Use <code>getSingleResult()</code> when you expect exactly one result, and <code>getResultList()</code> when there might be zero or multiple results.</p>
<h3 id="125-how-does-jpa-handle-concurrent-updates-with-versioning">125. How does JPA handle concurrent updates with versioning?</h3>
<p><strong>Answer:</strong> JPA uses optimistic locking with version attributes to detect concurrent modifications:</p>
<pre><code class="language-java">@Entity
public class Account {
    @Id
    private Long id;

    private BigDecimal balance;

    @Version
    private Integer version;

    public void withdraw(BigDecimal amount) {
        this.balance = this.balance.subtract(amount);
    }
}
</code></pre>
<p>When updating:</p>
<ol>
    <li>JPA reads entity with version (e.g., version = 5)</li>
    <li>Application modifies entity</li>
    <li>On commit, JPA generates: <code>UPDATE account SET balance = ?, version = 6 WHERE id = ? AND version = 5</code></li>
    <li>If another transaction changed the entity, the WHERE condition fails</li>
    <li>JPA throws OptimisticLockException</li>
</ol>
<p>Handle it with:</p>
<pre><code class="language-java">try {
    entityManager.getTransaction().begin();
    Account account = entityManager.find(Account.class, accountId);
    account.withdraw(amount);
    entityManager.getTransaction().commit();
} catch (OptimisticLockException e) {
    // Handle concurrent modification
    // Options: retry, merge changes, notify user, log conflict
}
</code></pre>
<h3 id="126-what-is-a-detached-entity-and-how-do-you-reattach-it">126. What is a detached entity and how do you reattach it?</h3>
<p><strong>Answer:</strong> A detached entity is one that was previously managed but is no longer associated with a persistence context. This happens when:</p>
<ol>
    <li>The EntityManager is closed</li>
    <li>The transaction is committed</li>
    <li>The entity is explicitly detached with <code>detach()</code></li>
    <li>The persistence context is cleared with <code>clear()</code></li>
</ol>
<p>Reattach a detached entity using:</p>
<pre><code class="language-java">// Option 1: merge() - copies state to a managed instance
Employee detached = getDetachedEmployee();
detached.setName(&quot;Updated Name&quot;);
Employee managed = entityManager.merge(detached);  // Returns managed copy
// Work with &#39;managed&#39;, not &#39;detached&#39;

// Option 2: Hibernate-specific update() or saveOrUpdate()
Session session = entityManager.unwrap(Session.class);
Employee detached = getDetachedEmployee();
detached.setName(&quot;Updated Name&quot;);
session.update(detached);  // Makes the actual instance managed
// Now &#39;detached&#39; is actually managed
</code></pre>
<p>Merge is more flexible but returns a new instance; update reattaches the original instance but is Hibernate-specific.</p>
<h3 id="127-how-do-you-implement-custom-id-generators-in-spring-data-jpa">127. How do you implement custom ID generators in Spring Data JPA?</h3>
<p><strong>Answer:</strong> Create custom ID generators in Spring Data JPA by:</p>
<ol>
    <li><strong>Implementing IdentifierGenerator</strong>:</li>
</ol>
<pre><code class="language-java">public class OrderNumberGenerator implements IdentifierGenerator {
    @Override
    public Serializable generate(SharedSessionContractImplementor session, Object object) {
        String prefix = &quot;ORD&quot;;
        LocalDate now = LocalDate.now();
        String datePart = String.format(&quot;%ty%tm%td&quot;, now, now, now);

        // Get sequence from database
        String sql = &quot;SELECT nextval(&#39;order_seq&#39;)&quot;;
        Object result = session.createNativeQuery(sql).uniqueResult();
        int sequenceNumber = ((Number) result).intValue();

        return String.format(&quot;%s-%s-%06d&quot;, prefix, datePart, sequenceNumber);
    }
}
</code></pre>
<ol start="2">
    <li><strong>Using the generator in an entity</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
public class Order {
    @Id
    @GeneratedValue(generator = &quot;order-number&quot;)
    @GenericGenerator(name = &quot;order-number&quot;,
                    strategy = &quot;com.example.OrderNumberGenerator&quot;)
    private String id;
    // Other fields
}
</code></pre>
<ol start="3">
    <li><strong>For simpler needs, use built-in generators</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
public class Document {
    @Id
    @GeneratedValue(generator = &quot;uuid2&quot;)
    @GenericGenerator(name = &quot;uuid2&quot;, strategy = &quot;uuid2&quot;)
    @Column(columnDefinition = &quot;VARCHAR(36)&quot;)
    private String id;
    // Other fields
}
</code></pre>
<h3 id="128-what-is-the-difference-between-onetomanyfetcheager-and-join-fetch-in-jpql">128. What is the difference between @OneToMany(fetch=EAGER) and JOIN FETCH in JPQL?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><code>@OneToMany(fetch=EAGER)</code>: Eager loading defined at mapping level; affects all queries</li>
    <li><code>JOIN FETCH</code> in JPQL: Eager loading at query level; affects only that specific query</li>
</ul>
<pre><code class="language-java">// Entity with EAGER fetch
@Entity
public class Department {
    @OneToMany(mappedBy = &quot;department&quot;, fetch = FetchType.EAGER)
    private List&lt;Employee&gt; employees;
    // Each time Department is loaded, employees are also loaded
}

// JPQL with JOIN FETCH (more selective)
List&lt;Department&gt; departments = entityManager.createQuery(
    &quot;SELECT d FROM Department d JOIN FETCH d.employees WHERE d.location = :location&quot;,
    Department.class)
    .setParameter(&quot;location&quot;, &quot;New York&quot;)
    .getResultList();
</code></pre>
<p>Key differences:</p>
<ol>
    <li>EAGER fetch always loads the collection, potentially causing performance issues</li>
    <li>JOIN FETCH gives more control over when to fetch relationships</li>
    <li>EAGER fetch may generate multiple queries; JOIN FETCH uses a single query with joins</li>
    <li>JOIN FETCH provides better performance control but requires explicit queries</li>
</ol>
<p>Best practice: Use LAZY as default fetch strategy and JOIN FETCH when needed.</p>
<h3 id="129-how-do-you-handle-large-objects-lobs-in-jpa">129. How do you handle large objects (LOBs) in JPA?</h3>
<p><strong>Answer:</strong> JPA supports large objects (text or binary) using the <code>@Lob</code> annotation:</p>
<pre><code class="language-java">@Entity
public class Document {
    @Id
    private Long id;
    private String name;

    // For large text (CLOB)
    @Lob
    @Column(columnDefinition = &quot;TEXT&quot;)
    private String content;

    // For binary data (BLOB)
    @Lob
    @Column(columnDefinition = &quot;BYTEA&quot;) // PostgreSQL
    private byte[] data;

    // For streaming very large data
    @Lob
    private Blob documentBlob; // java.sql.Blob

    @Lob
    private Clob documentClob; // java.sql.Clob
}
</code></pre>
<p>Best practices for LOBs:</p>
<ol>
    <li>Consider storing file metadata in database and actual content in filesystem</li>
    <li>Use streaming APIs for very large objects</li>
    <li>Enable lazy loading for LOB properties</li>
    <li>Set appropriate JDBC fetch size for large LOBs</li>
    <li>Consider using Spring&#39;s LobCreator for creating LOB objects</li>
</ol>
<h3 id="130-what-is-the-filter-annotation-in-hibernate-and-how-is-it-used">130. What is the @Filter annotation in Hibernate and how is it used?</h3>
<p><strong>Answer:</strong> Hibernate&#39;s <code>@Filter</code> enables dynamic filtering of entities at the session level:</p>
<pre><code class="language-java">@Entity
@FilterDef(name = &quot;activeFilter&quot;, parameters = @ParamDef(name = &quot;active&quot;, type = &quot;boolean&quot;))
@Filter(name = &quot;activeFilter&quot;, condition = &quot;active = :active&quot;)
public class Employee {
    @Id
    private Long id;
    private String name;
    private boolean active;

    // Other fields and methods
}

// Using the filter
Session session = entityManager.unwrap(Session.class);
session.enableFilter(&quot;activeFilter&quot;).setParameter(&quot;active&quot;, true);

// Now all queries against Employee will only return active employees
List&lt;Employee&gt; employees = session.createQuery(&quot;from Employee&quot;, Employee.class).list();

// Disable the filter when no longer needed
session.disableFilter(&quot;activeFilter&quot;);
</code></pre>
<p>Filters can be applied to:</p>
<ol>
    <li>Entity queries</li>
    <li>Collection mappings (with additional @Filter on the collection)</li>
    <li>Many entities at once (global filters)</li>
</ol>
<p>They&#39;re useful for implementing row-level security, multi-tenancy, and soft delete functionality.
    ]</p>
<h3 id="131-what-is-database-connection-pooling-and-how-does-it-affect-jpa-applications">131. What is database connection pooling and how does it affect JPA applications?</h3>
<p><strong>Answer:</strong> Connection pooling reuses database connections instead of creating new ones for each operation. Benefits in JPA applications:</p>
<ol>
    <li><strong>Performance</strong>: Eliminates connection establishment overhead</li>
    <li><strong>Resource management</strong>: Limits max connections to prevent overloading</li>
    <li><strong>Scalability</strong>: Handles concurrent requests efficiently</li>
</ol>
<p>Popular connection pool implementations:</p>
<ul>
    <li>HikariCP (Spring Boot default)</li>
    <li>C3P0</li>
    <li>Apache DBCP</li>
    <li>Tomcat JDBC Pool</li>
</ul>
<pre><code class="language-java">// HikariCP configuration in Spring Boot
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=30000
spring.datasource.hikari.connection-timeout=20000
</code></pre>
<h3 id="132-what-are-the-different-transaction-isolation-levels-in-jpa">132. What are the different transaction isolation levels in JPA?</h3>
<p><strong>Answer:</strong> JPA supports standard SQL transaction isolation levels via the <code>@Transactional</code> annotation:</p>
<pre><code class="language-java">@Transactional(isolation = Isolation.READ_COMMITTED)
public void updateEmployee(Long id, EmployeeDTO updates) {
    // Method implementation
}
</code></pre>
<p>Available levels:</p>
<ul>
    <li><strong>READ_UNCOMMITTED</strong>: Dirty reads possible (see uncommitted changes)</li>
    <li><strong>READ_COMMITTED</strong>: No dirty reads, but non-repeatable reads possible</li>
    <li><strong>REPEATABLE_READ</strong>: Same reads return same data, but phantom reads possible</li>
    <li><strong>SERIALIZABLE</strong>: Complete isolation, highest consistency but lowest concurrency</li>
</ul>
<p>The default level depends on the database. Choose based on:</p>
<ol>
    <li>Consistency requirements</li>
    <li>Performance needs</li>
    <li>Database capabilities</li>
</ol>
<h3 id="133-how-do-you-implement-database-sharding-with-jpa">133. How do you implement database sharding with JPA?</h3>
<p><strong>Answer:</strong> Sharding (horizontal partitioning) with JPA typically requires:</p>
<ol>
    <li><strong>Custom routing DataSource</strong>:</li>
</ol>
<pre><code class="language-java">public class ShardingDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return ShardingContext.getCurrentShardId();
    }
}
</code></pre>
<ol start="2">
    <li><strong>Configuration</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
public class ShardingConfig {
    @Bean
    public DataSource dataSource() {
        ShardingDataSource dataSource = new ShardingDataSource();

        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();
        targetDataSources.put(&quot;shard1&quot;, shard1DataSource());
        targetDataSources.put(&quot;shard2&quot;, shard2DataSource());

        dataSource.setTargetDataSources(targetDataSources);
        return dataSource;
    }

    // Individual shard datasources
}
</code></pre>
<ol start="3">
    <li><strong>Routing mechanism</strong>:</li>
</ol>
<pre><code class="language-java">public class ShardingContext {
    private static final ThreadLocal&lt;String&gt; currentShard = new ThreadLocal&lt;&gt;();

    public static void setCurrentShard(String shardId) {
        currentShard.set(shardId);
    }

    public static String getCurrentShardId() {
        return currentShard.get();
    }

    public static void clear() {
        currentShard.remove();
    }
}

// Usage
@Service
public class UserService {
    @Transactional
    public User findById(Long userId) {
        // Determine shard based on user ID
        String shardId = &quot;shard&quot; + (userId % 2 + 1);
        try {
            ShardingContext.setCurrentShard(shardId);
            return userRepository.findById(userId).orElse(null);
        } finally {
            ShardingContext.clear();
        }
    }
}
</code></pre>
<p>Advanced sharding might require specialized frameworks like Apache Shardingsphere.</p>
<h3 id="134-how-do-you-implement-stored-procedure-calls-in-jpa">134. How do you implement stored procedure calls in JPA?</h3>
<p><strong>Answer:</strong> JPA provides multiple ways to call stored procedures:</p>
<ol>
    <li><strong>Using @NamedStoredProcedureQuery</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@NamedStoredProcedureQuery(
    name = &quot;Employee.giveRaise&quot;,
    procedureName = &quot;give_employee_raise&quot;,
    parameters = {
        @StoredProcedureParameter(mode = ParameterMode.IN, name = &quot;emp_id&quot;, type = Long.class),
        @StoredProcedureParameter(mode = ParameterMode.IN, name = &quot;raise_pct&quot;, type = BigDecimal.class),
        @StoredProcedureParameter(mode = ParameterMode.OUT, name = &quot;new_salary&quot;, type = BigDecimal.class)
    }
)
public class Employee {
    // Entity fields
}

// Usage
StoredProcedureQuery query = entityManager.createNamedStoredProcedureQuery(&quot;Employee.giveRaise&quot;);
query.setParameter(&quot;emp_id&quot;, 101L);
query.setParameter(&quot;raise_pct&quot;, new BigDecimal(&quot;0.1&quot;));
query.execute();
BigDecimal newSalary = (BigDecimal) query.getOutputParameterValue(&quot;new_salary&quot;);
</code></pre>
<ol start="2">
    <li><strong>Direct creation</strong>:</li>
</ol>
<pre><code class="language-java">StoredProcedureQuery query = entityManager.createStoredProcedureQuery(&quot;get_employees_by_dept&quot;);
query.registerStoredProcedureParameter(&quot;dept_id&quot;, Long.class, ParameterMode.IN);
query.registerStoredProcedureParameter(&quot;min_salary&quot;, BigDecimal.class, ParameterMode.IN);
query.setParameter(&quot;dept_id&quot;, 10L);
query.setParameter(&quot;min_salary&quot;, new BigDecimal(&quot;50000&quot;));

// For procedures returning result sets
query.execute();
List&lt;Employee&gt; results = query.getResultList();
</code></pre>
<ol start="3">
    <li><strong>Spring Data JPA</strong>:</li>
</ol>
<pre><code class="language-java">public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {
    @Procedure(&quot;give_employee_raise&quot;)
    BigDecimal giveRaise(@Param(&quot;emp_id&quot;) Long id, @Param(&quot;raise_pct&quot;) BigDecimal percentage);

    @Procedure(name = &quot;Employee.giveRaise&quot;) // Using named stored procedure
    BigDecimal executeGiveRaise(@Param(&quot;emp_id&quot;) Long id, @Param(&quot;raise_pct&quot;) BigDecimal percentage);
}
</code></pre>
<h3 id="135-what-is-hibernates-statisticsservice-and-how-can-it-help-diagnose-performance-issues">135. What is Hibernate&#39;s StatisticsService and how can it help diagnose performance issues?</h3>
<p><strong>Answer:</strong> Hibernate&#39;s StatisticsService collects runtime metrics about Hibernate&#39;s internal operations for performance monitoring and tuning:</p>
<pre><code class="language-java">// Enable statistics
hibernate.generate_statistics=true

// Access statistics in code
Session session = entityManager.unwrap(Session.class);
SessionFactory factory = session.getSessionFactory();
Statistics stats = factory.getStatistics();

// Get metrics
long entityFetchCount = stats.getEntityFetchCount();
long queryExecutionCount = stats.getQueryExecutionCount();
long secondLevelCacheHitCount = stats.getSecondLevelCacheHitCount();
double hitRatio = stats.getSecondLevelCacheHitCount() /
                  (double) (stats.getSecondLevelCacheHitCount() + stats.getSecondLevelCacheMissCount());
String[] queries = stats.getQueries();

// Query-specific statistics
QueryStatistics queryStats = stats.getQueryStatistics(&quot;Employee.findByDepartment&quot;);
long execCount = queryStats.getExecutionCount();
long avgTime = queryStats.getExecutionAvgTime();
</code></pre>
<p>Statistics help identify:</p>
<ol>
    <li>N+1 select problems (high entity fetch count)</li>
    <li>Cache effectiveness (hit/miss ratios)</li>
    <li>Slow queries (execution times)</li>
    <li>Connection usage patterns</li>
    <li>Statement preparation overhead</li>
</ol>
<h3 id="136-how-does-jpa-handle-collections-of-basic-types">136. How does JPA handle collections of basic types?</h3>
<p><strong>Answer:</strong> JPA provides the <code>@ElementCollection</code> annotation for mapping collections of basic types or embeddable objects:</p>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    private Long id;

    // Collection of strings
    @ElementCollection
    @CollectionTable(name = &quot;employee_skills&quot;, joinColumns = @JoinColumn(name = &quot;employee_id&quot;))
    @Column(name = &quot;skill&quot;)
    private Set&lt;String&gt; skills = new HashSet&lt;&gt;();

    // Collection of enums
    @ElementCollection
    @CollectionTable(name = &quot;employee_certifications&quot;, joinColumns = @JoinColumn(name = &quot;employee_id&quot;))
    @Enumerated(EnumType.STRING)
    @Column(name = &quot;certification&quot;)
    private List&lt;Certification&gt; certifications = new ArrayList&lt;&gt;();
}
</code></pre>
<p>Key points:</p>
<ol>
    <li>Element collections are always fetched lazily by default</li>
    <li>No cascade options needed (elements are dependent objects)</li>
    <li>Elements don&#39;t have their own identity (no @Id)</li>
    <li>Deletion of owner entity removes all collection entries</li>
    <li>Use @OrderColumn to maintain list order if needed</li>
</ol>
<h3 id="137-what-is-the-hibernate-interceptor-and-how-is-it-used">137. What is the Hibernate interceptor and how is it used?</h3>
<p><strong>Answer:</strong> Hibernate interceptors allow interception of persistence operations to implement cross-cutting concerns:</p>
<pre><code class="language-java">public class AuditInterceptor extends EmptyInterceptor {
    @Override
    public boolean onSave(Object entity, Serializable id, Object[] state,
                         String[] propertyNames, Type[] types) {
        if (entity instanceof Auditable) {
            for (int i = 0; i &lt; propertyNames.length; i++) {
                if (&quot;createdAt&quot;.equals(propertyNames[i])) {
                    state[i] = LocalDateTime.now();
                }
                if (&quot;createdBy&quot;.equals(propertyNames[i])) {
                    state[i] = SecurityContextHolder.getContext().getAuthentication().getName();
                }
            }
            return true; // State was modified
        }
        return false;
    }

    @Override
    public boolean onFlushDirty(Object entity, Serializable id, Object[] currentState,
                               Object[] previousState, String[] propertyNames, Type[] types) {
        if (entity instanceof Auditable) {
            for (int i = 0; i &lt; propertyNames.length; i++) {
                if (&quot;updatedAt&quot;.equals(propertyNames[i])) {
                    currentState[i] = LocalDateTime.now();
                }
                if (&quot;updatedBy&quot;.equals(propertyNames[i])) {
                    currentState[i] = SecurityContextHolder.getContext().getAuthentication().getName();
                }
            }
            return true; // State was modified
        }
        return false;
    }
}
</code></pre>
<p>Register interceptor:</p>
<pre><code class="language-java">// In Hibernate native configuration
SessionFactory sessionFactory = new Configuration()
    .setInterceptor(new AuditInterceptor())
    .buildSessionFactory();

// In Spring Boot
@Bean
public HibernatePropertiesCustomizer hibernatePropertiesCustomizer() {
    return hibernateProperties -&gt;
        hibernateProperties.put(&quot;hibernate.session_factory.interceptor&quot;, new AuditInterceptor());
}
</code></pre>
<p>Use cases:</p>
<ol>
    <li>Automatic auditing</li>
    <li>Encryption/decryption</li>
    <li>Validation</li>
    <li>Logging</li>
    <li>Security checks</li>
</ol>
<h3 id="138-what-is-a-uuid-and-how-do-you-use-it-as-an-identifier-in-jpa">138. What is a UUID and how do you use it as an identifier in JPA?</h3>
<p><strong>Answer:</strong> UUID (Universally Unique Identifier) provides globally unique IDs without coordination. Use in JPA:</p>
<pre><code class="language-java">@Entity
public class Document {
    @Id
    @GeneratedValue(generator = &quot;UUID&quot;)
    @GenericGenerator(
        name = &quot;UUID&quot;,
        strategy = &quot;org.hibernate.id.UUIDGenerator&quot;
    )
    @Column(updatable = false, nullable = false, columnDefinition = &quot;VARCHAR(36)&quot;)
    private String id;

    // Or manually set the UUID
    @Id
    @Column(updatable = false, nullable = false, columnDefinition = &quot;VARCHAR(36)&quot;)
    private String id = UUID.randomUUID().toString();
}
</code></pre>
<p>Benefits:</p>
<ol>
    <li>No need for database sequences</li>
    <li>Distributed ID generation without coordination</li>
    <li>No collision risk across systems</li>
    <li>Good for distributed or replicated databases</li>
</ol>
<p>Drawbacks:</p>
<ol>
    <li>Larger than numeric IDs (storage overhead)</li>
    <li>Not sequential (poor database clustering)</li>
    <li>Less human-readable</li>
</ol>
<h3 id="139-how-do-you-implement-table-inheritance-in-jpa">139. How do you implement table inheritance in JPA?</h3>
<p><strong>Answer:</strong> JPA supports three inheritance strategies:</p>
<ol>
    <li><strong>Single Table</strong> (default):</li>
</ol>
<pre><code class="language-java">@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = &quot;employee_type&quot;)
public abstract class Employee {
    @Id
    private Long id;
    private String name;
}

@Entity
@DiscriminatorValue(&quot;FT&quot;)
public class FullTimeEmployee extends Employee {
    private BigDecimal salary;
}

@Entity
@DiscriminatorValue(&quot;CT&quot;)
public class ContractEmployee extends Employee {
    private BigDecimal hourlyRate;
}
</code></pre>
<ol start="2">
    <li><strong>Joined Table</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class Payment {
    @Id
    private Long id;
    private LocalDate paymentDate;
    private BigDecimal amount;
}

@Entity
@PrimaryKeyJoinColumn(name = &quot;payment_id&quot;)
public class CreditCardPayment extends Payment {
    private String cardNumber;
    private String cardHolderName;
}

@Entity
@PrimaryKeyJoinColumn(name = &quot;payment_id&quot;)
public class BankTransferPayment extends Payment {
    private String accountNumber;
    private String bankName;
}
</code></pre>
<ol start="3">
    <li><strong>Table Per Class</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Vehicle {
    @Id
    private String vin;
    private String manufacturer;
    private String model;
}

@Entity
public class Car extends Vehicle {
    private int numberOfDoors;
    private String fuelType;
}

@Entity
public class Motorcycle extends Vehicle {
    private int engineCapacity;
}
</code></pre>
<p>Strategy selection depends on:</p>
<ol>
    <li>Query complexity and performance needs</li>
    <li>Data integrity requirements</li>
    <li>Storage efficiency concerns</li>
    <li>Number of subclasses and attributes</li>
</ol>
<h3 id="140-how-do-you-handle-entity-lifecycle-events-in-jpa">140. How do you handle entity lifecycle events in JPA?</h3>
<p><strong>Answer:</strong> JPA provides entity lifecycle event annotations that trigger callback methods:</p>
<pre><code class="language-java">@Entity
public class Employee {
    @Id
    private Long id;
    private String name;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @PrePersist
    public void prePersist() {
        createdAt = LocalDateTime.now();
    }

    @PreUpdate
    public void preUpdate() {
        updatedAt = LocalDateTime.now();
    }

    @PostLoad
    public void postLoad() {
        // Initialize transient fields or perform validation
    }

    @PreRemove
    public void preRemove() {
        // Logic before removal
    }

    @PostRemove
    public void postRemove() {
        // Cleanup after removal
    }

    @PostPersist
    public void postPersist() {
        // Logic after entity is persisted
    }

    @PostUpdate
    public void postUpdate() {
        // Logic after entity is updated
    }
}
</code></pre>
<p>For cross-entity listeners, use an entity listener class:</p>
<pre><code class="language-java">@Entity
@EntityListeners(AuditListener.class)
public class Product {
    // Entity fields
}

public class AuditListener {
    @PrePersist
    public void setCreatedOn(Object entity) {
        if (entity instanceof Auditable) {
            ((Auditable) entity).setCreatedAt(LocalDateTime.now());
        }
    }

    @PreUpdate
    public void setUpdatedOn(Object entity) {
        if (entity instanceof Auditable) {
            ((Auditable) entity).setUpdatedAt(LocalDateTime.now());
        }
    }
}
</code></pre>
<h3 id="141-how-can-you-use-database-specific-features-with-jpa">141. How can you use database-specific features with JPA?</h3>
<p><strong>Answer:</strong> Access database-specific features in JPA through:</p>
<ol>
    <li><strong>Native queries</strong>:</li>
</ol>
<pre><code class="language-java">Query query = entityManager.createNativeQuery(
    &quot;SELECT * FROM employees WHERE name ILIKE ?&quot;, Employee.class);
query.setParameter(1, &quot;%smith%&quot;);
</code></pre>
<ol start="2">
    <li><strong>Dialect-specific settings</strong>:</li>
</ol>
<pre><code class="language-properties"># PostgreSQL-specific settings
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQL10Dialect
spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults=false
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
</code></pre>
<ol start="3">
    <li><strong>Database-specific annotations</strong> (Hibernate):</li>
</ol>
<pre><code class="language-java">@Entity
@Table(name = &quot;products&quot;)
public class Product {
    @Id
    private Long id;

    @Column(name = &quot;description&quot;)
    @Type(type = &quot;org.hibernate.type.TextType&quot;)  // PostgreSQL TEXT type
    private String description;

    @org.hibernate.annotations.Check(constraints = &quot;price &gt; 0&quot;)  // DB check constraint
    private BigDecimal price;

    @org.hibernate.annotations.Index(name = &quot;idx_product_code&quot;)  // DB index
    private String code;
}
</code></pre>
<ol start="4">
    <li><strong>Custom types</strong>:</li>
</ol>
<pre><code class="language-java">// PostgreSQL JSON type mapping
@Entity
public class UserPreferences {
    @Id
    private Long userId;

    @Type(type = &quot;jsonb&quot;)
    @Column(columnDefinition = &quot;jsonb&quot;)
    private Map&lt;String, Object&gt; preferences;
}
</code></pre>
<h3 id="142-what-is-spring-data-jpas-specification-api-and-how-is-it-used">142. What is Spring Data JPA&#39;s Specification API and how is it used?</h3>
<p><strong>Answer:</strong> Spring Data JPA&#39;s Specification API enables type-safe, dynamic query composition using the criteria API:</p>
<pre><code class="language-java">public interface EmployeeRepository
    extends JpaRepository&lt;Employee, Long&gt;, JpaSpecificationExecutor&lt;Employee&gt; {
}

// Create reusable specifications
public class EmployeeSpecifications {
    public static Specification&lt;Employee&gt; hasSalaryGreaterThan(BigDecimal salary) {
        return (root, query, cb) -&gt; cb.greaterThan(root.get(&quot;salary&quot;), salary);
    }

    public static Specification&lt;Employee&gt; inDepartment(String department) {
        return (root, query, cb) -&gt; cb.equal(root.get(&quot;department&quot;).get(&quot;name&quot;), department);
    }

    public static Specification&lt;Employee&gt; nameContains(String namePart) {
        return (root, query, cb) -&gt; cb.like(cb.lower(root.get(&quot;name&quot;)),
                                           &quot;%&quot; + namePart.toLowerCase() + &quot;%&quot;);
    }
}

// Usage with dynamic conditions
@Service
public class EmployeeService {
    @Autowired
    private EmployeeRepository repository;

    public List&lt;Employee&gt; findEmployees(String namePart, String department, BigDecimal minSalary) {
        Specification&lt;Employee&gt; spec = Specification.where(null);

        if (namePart != null) {
            spec = spec.and(EmployeeSpecifications.nameContains(namePart));
        }

        if (department != null) {
            spec = spec.and(EmployeeSpecifications.inDepartment(department));
        }

        if (minSalary != null) {
            spec = spec.and(EmployeeSpecifications.hasSalaryGreaterThan(minSalary));
        }

        return repository.findAll(spec);
    }
}
</code></pre>
<p>Benefits:</p>
<ol>
    <li>Type-safe query criteria</li>
    <li>Reusable, composable query parts</li>
    <li>Dynamic query building based on conditions</li>
    <li>Integration with sorting and pagination</li>
</ol>
<h3 id="143-how-do-you-implement-data-encryption-in-jpa-entities">143. How do you implement data encryption in JPA entities?</h3>
<p><strong>Answer:</strong> Implement attribute-level encryption in JPA using:</p>
<ol>
    <li><strong>Custom AttributeConverter</strong>:</li>
</ol>
<pre><code class="language-java">@Converter
public class EncryptedStringConverter implements AttributeConverter&lt;String, String&gt; {
    private static final String SECRET_KEY = &quot;my-secret-key-123&quot;; // Use secure key storage

    @Override
    public String convertToDatabaseColumn(String attribute) {
        if (attribute == null) {
            return null;
        }
        try {
            SecretKeySpec keySpec = new SecretKeySpec(SECRET_KEY.getBytes(), &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec);
            byte[] encrypted = cipher.doFinal(attribute.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(encrypted);
        } catch (Exception e) {
            throw new RuntimeException(&quot;Error encrypting&quot;, e);
        }
    }

    @Override
    public String convertToEntityAttribute(String dbData) {
        if (dbData == null) {
            return null;
        }
        try {
            SecretKeySpec keySpec = new SecretKeySpec(SECRET_KEY.getBytes(), &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);
            cipher.init(Cipher.DECRYPT_MODE, keySpec);
            byte[] decoded = Base64.getDecoder().decode(dbData);
            byte[] decrypted = cipher.doFinal(decoded);
            return new String(decrypted, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException(&quot;Error decrypting&quot;, e);
        }
    }
}
</code></pre>
<ol start="2">
    <li><strong>Using the converter in entities</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
public class Customer {
    @Id
    private Long id;

    private String name;

    @Convert(converter = EncryptedStringConverter.class)
    private String socialSecurityNumber;

    @Convert(converter = EncryptedStringConverter.class)
    private String creditCardNumber;
}
</code></pre>
<ol start="3">
    <li><strong>Hibernate-specific approach with interceptors</strong>:</li>
</ol>
<pre><code class="language-java">public class EncryptionInterceptor extends EmptyInterceptor {
    @Override
    public boolean onSave(Object entity, Serializable id, Object[] state,
                         String[] propertyNames, Type[] types) {
        if (entity instanceof ContainsEncryptedFields) {
            for (String field : ((ContainsEncryptedFields) entity).getEncryptedFields()) {
                int index = indexOf(propertyNames, field);
                if (index &gt;= 0 &amp;&amp; state[index] instanceof String) {
                    state[index] = encrypt((String) state[index]);
                }
            }
            return true;
        }
        return false;
    }

    // Similar handling for onLoad to decrypt
}
</code></pre>
<p>Best practices:</p>
<ol>
    <li>Store encryption keys securely (not in code)</li>
    <li>Use strong encryption algorithms</li>
    <li>Consider database column length for encrypted values</li>
    <li>Add indexing only on non-encrypted fields</li>
    <li>Consider query implications (encrypted fields can&#39;t be efficiently searched)</li>
</ol>
<h3 id="144-what-is-jpa-buddy-and-how-can-it-help-with-jpa-development">144. What is JPA Buddy and how can it help with JPA development?</h3>
<p><strong>Answer:</strong> JPA Buddy is an IntelliJ IDEA plugin that accelerates JPA development through visual tools:</p>
<ol>
    <li><p><strong>Entity Generation</strong>:</p>
        <ul>
            <li>Create entities from database tables</li>
            <li>Visual entity designer</li>
            <li>Relationship mapping visualization</li>
        </ul>
    </li>
    <li><p><strong>Repository Generation</strong>:</p>
        <ul>
            <li>Create Spring Data repositories</li>
            <li>Generate query methods</li>
        </ul>
    </li>
    <li><p><strong>Query Development</strong>:</p>
        <ul>
            <li>Visual JPQL/HQL builder</li>
            <li>Query execution and testing</li>
            <li>Method name query assistance</li>
        </ul>
    </li>
    <li><p><strong>DTO Generation</strong>:</p>
        <ul>
            <li>Convert entities to DTOs</li>
            <li>Create MapStruct mappers</li>
        </ul>
    </li>
    <li><p><strong>Liquibase/Flyway Support</strong>:</p>
        <ul>
            <li>Generate migration scripts</li>
            <li>Compare schema versions</li>
        </ul>
    </li>
    <li><p><strong>Performance Analysis</strong>:</p>
        <ul>
            <li>N+1 query detection</li>
            <li>Fetch plan optimization</li>
        </ul>
    </li>
</ol>
<p>The tool is particularly helpful for:</p>
<ol>
    <li>JPA beginners learning relationships and mappings</li>
    <li>Teams standardizing JPA practices</li>
    <li>Complex schema management</li>
    <li>Visualizing entity relationships</li>
</ol>
<h3 id="145-how-do-you-configure-multiple-persistence-units-in-spring-boot">145. How do you configure multiple persistence units in Spring Boot?</h3>
<p><strong>Answer:</strong> Configure multiple persistence units in Spring Boot:</p>
<pre><code class="language-java">@Configuration
public class MultiplePersistenceConfig {
    // First persistence unit
    @Bean
    @Primary
    @ConfigurationProperties(&quot;spring.datasource.orders&quot;)
    public DataSource ordersDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @Primary
    public LocalContainerEntityManagerFactoryBean ordersEntityManager(
            EntityManagerFactoryBuilder builder,
            @Qualifier(&quot;ordersDataSource&quot;) DataSource dataSource) {
        return builder
            .dataSource(dataSource)
            .packages(&quot;com.example.orders.domain&quot;)
            .persistenceUnit(&quot;orders&quot;)
            .properties(jpaProperties())
            .build();
    }

    @Bean
    @Primary
    public PlatformTransactionManager ordersTransactionManager(
            @Qualifier(&quot;ordersEntityManager&quot;) EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }

    // Second persistence unit
    @Bean
    @ConfigurationProperties(&quot;spring.datasource.customers&quot;)
    public DataSource customersDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean customersEntityManager(
            EntityManagerFactoryBuilder builder,
            @Qualifier(&quot;customersDataSource&quot;) DataSource dataSource) {
        return builder
            .dataSource(dataSource)
            .packages(&quot;com.example.customers.domain&quot;)
            .persistenceUnit(&quot;customers&quot;)
            .properties(jpaProperties())
            .build();
    }

    @Bean
    public PlatformTransactionManager customersTransactionManager(
            @Qualifier(&quot;customersEntityManager&quot;) EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }

    private Map&lt;String, String&gt; jpaProperties() {
        Map&lt;String, String&gt; props = new HashMap&lt;&gt;();
        props.put(&quot;hibernate.physical_naming_strategy&quot;,
                 &quot;org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy&quot;);
        return props;
    }
}
</code></pre>
<p>Usage in repositories:</p>
<pre><code class="language-java">// For orders database
@Repository
@Transactional(transactionManager = &quot;ordersTransactionManager&quot;)
public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {
}

// For customers database
@Repository
@Transactional(transactionManager = &quot;customersTransactionManager&quot;)
public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt; {
}
</code></pre>
<h3 id="146-what-is-the-difference-between-entitymanagerrefresh-and-entitymanagerclear">146. What is the difference between EntityManager.refresh() and EntityManager.clear()?</h3>
<p><strong>Answer:</strong></p>
<ul>
    <li><code>refresh()</code>: Updates a single entity from database, overwriting any changes</li>
    <li><code>clear()</code>: Detaches all entities from the persistence context</li>
</ul>
<pre><code class="language-java">// refresh() example
Employee employee = entityManager.find(Employee.class, 101L);
employee.setSalary(new BigDecimal(&quot;80000&quot;));  // Local change

// Database change by another transaction
executeExternalUpdate(&quot;UPDATE employees SET salary = 75000 WHERE id = 101&quot;);

entityManager.refresh(employee);  // Refreshes from database
// Now employee.getSalary() returns 75000, not 80000

// clear() example
List&lt;Employee&gt; employees = entityManager.createQuery(
    &quot;SELECT e FROM Employee e&quot;, Employee.class).getResultList();
// Make some changes
employees.get(0).setSalary(new BigDecimal(&quot;90000&quot;));

entityManager.clear();  // Detaches all entities
// Changes to employees.get(0) are discarded

// After clear(), entities must be reattached to be persisted
entityManager.merge(employees.get(0));
</code></pre>
<p>Key differences:</p>
<ol>
    <li><code>refresh()</code> affects one entity; <code>clear()</code> affects all entities</li>
    <li><code>refresh()</code> reloads from database; <code>clear()</code> just detaches without loading</li>
    <li><code>refresh()</code> maintains entity identity; <code>clear()</code> breaks identity</li>
    <li><code>refresh()</code> is for entity synchronization; <code>clear()</code> is for memory management</li>
</ol>
<h3 id="147-how-do-you-handle-data-auditing-with-spring-data-jpa">147. How do you handle data auditing with Spring Data JPA?</h3>
<p><strong>Answer:</strong> Spring Data JPA provides built-in auditing support:</p>
<ol>
    <li><strong>Enable auditing</strong>:</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableJpaAuditing
public class AuditingConfig {
    @Bean
    public AuditorAware&lt;String&gt; auditorProvider() {
        return () -&gt; Optional.ofNullable(SecurityContextHolder.getContext())
            .map(ctx -&gt; ctx.getAuthentication())
            .filter(auth -&gt; auth.isAuthenticated() &amp;&amp; !&quot;anonymousUser&quot;.equals(auth.getPrincipal()))
            .map(auth -&gt; auth.getName())
            .or(() -&gt; Optional.of(&quot;system&quot;));
    }
}
</code></pre>
<ol start="2">
    <li><strong>Create auditing entity base class</strong>:</li>
</ol>
<pre><code class="language-java">@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class Auditable {
    @CreatedBy
    @Column(updatable = false)
    private String createdBy;

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedBy
    private String lastModifiedBy;

    @LastModifiedDate
    private LocalDateTime lastModifiedAt;

    // Getters (no setters for auditing fields)
}
</code></pre>
<ol start="3">
    <li><strong>Use in domain entities</strong>:</li>
</ol>
<pre><code class="language-java">@Entity
public class Product extends Auditable {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    private BigDecimal price;
    // Regular fields and methods
}
</code></pre>
<ol start="4">
    <li><strong>For revision history</strong> use Hibernate Envers:</li>
</ol>
<pre><code class="language-java">@Entity
@Audited
public class Customer extends Auditable {
    @Id
    @GeneratedValue
    private Long id;

    private String name;
    private String email;

    @NotAudited
    private String internalNotes;
}
</code></pre>
<h3 id="148-what-are-the-different-locking-modes-in-jpa-and-their-use-cases">148. What are the different locking modes in JPA and their use cases?</h3>
<p><strong>Answer:</strong> JPA provides several locking modes for concurrency control:</p>
<ol>
    <li><p><strong>OPTIMISTIC (LockModeType.OPTIMISTIC)</strong>:</p>
        <ul>
            <li>Verifies version hasn&#39;t changed since load</li>
            <li>For read-mostly data with low contention</li>
        </ul>
        <pre><code class="language-java">Employee employee = entityManager.find(
    Employee.class, id, LockModeType.OPTIMISTIC);
</code></pre>
    </li>
    <li><p><strong>OPTIMISTIC_FORCE_INCREMENT (LockModeType.OPTIMISTIC_FORCE_INCREMENT)</strong>:</p>
        <ul>
            <li>Verifies and always increments version</li>
            <li>For when non-persistent changes should trigger version increment</li>
        </ul>
        <pre><code class="language-java">Employee employee = entityManager.find(
    Employee.class, id, LockModeType.OPTIMISTIC_FORCE_INCREMENT);
// Version increments even if no fields change
</code></pre>
    </li>
    <li><p><strong>PESSIMISTIC_READ (LockModeType.PESSIMISTIC_READ)</strong>:</p>
        <ul>
            <li>Locks for reading, prevents writes by others</li>
            <li>For consistent reads when data might change</li>
        </ul>
        <pre><code class="language-java">Employee employee = entityManager.find(
    Employee.class, id, LockModeType.PESSIMISTIC_READ);
</code></pre>
    </li>
    <li><p><strong>PESSIMISTIC_WRITE (LockModeType.PESSIMISTIC_WRITE)</strong>:</p>
        <ul>
            <li>Exclusive lock, prevents others from reading and writing</li>
            <li>For ensuring exclusive access to data</li>
        </ul>
        <pre><code class="language-java">Employee employee = entityManager.find(
    Employee.class, id, LockModeType.PESSIMISTIC_WRITE);
</code></pre>
    </li>
    <li><p><strong>PESSIMISTIC_FORCE_INCREMENT (LockModeType.PESSIMISTIC_FORCE_INCREMENT)</strong>:</p>
        <ul>
            <li>Exclusive lock and forces version increment</li>
            <li>Combines pessimistic locking with version incrementing</li>
        </ul>
        <pre><code class="language-java">Employee employee = entityManager.find(
    Employee.class, id, LockModeType.PESSIMISTIC_FORCE_INCREMENT);
</code></pre>
    </li>
    <li><p><strong>Lock timeouts</strong>:</p>
        <pre><code class="language-java">Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();
properties.put(&quot;javax.persistence.lock.timeout&quot;, 1000); // 1 second
Employee employee = entityManager.find(
    Employee.class, id, LockModeType.PESSIMISTIC_WRITE, properties);
</code></pre>
    </li>
</ol>
<p>Choose locking strategy based on:</p>
<ol>
    <li>Read/write ratio</li>
    <li>Contention likelihood</li>
    <li>Performance requirements</li>
    <li>Consistency needs</li>
    <li>Transaction isolation level</li>
</ol>
<h3 id="149-how-do-you-implement-polymorphic-queries-in-jpa">149. How do you implement polymorphic queries in JPA?</h3>
<p><strong>Answer:</strong> JPA supports polymorphic queries to retrieve entities across an inheritance hierarchy:</p>
<ol>
    <li><strong>Querying base class</strong> (returns all subtypes):</li>
</ol>
<pre><code class="language-java">// Using Employee base class
TypedQuery&lt;Employee&gt; query = entityManager.createQuery(
    &quot;SELECT e FROM Employee e&quot;, Employee.class);
List&lt;Employee&gt; employees = query.getResultList();
// Returns both FullTimeEmployee and ContractEmployee objects
</code></pre>
<ol start="2">
    <li><strong>Type checking and casting</strong>:</li>
</ol>
<pre><code class="language-java">for (Employee employee : employees) {
    if (employee instanceof FullTimeEmployee) {
        FullTimeEmployee fte = (FullTimeEmployee) employee;
        System.out.println(&quot;Salary: &quot; + fte.getSalary());
    } else if (employee instanceof ContractEmployee) {
        ContractEmployee cte = (ContractEmployee) employee;
        System.out.println(&quot;Hourly rate: &quot; + cte.getHourlyRate());
    }
}
</code></pre>
<ol start="3">
    <li><strong>JPQL TYPE operator</strong>:</li>
</ol>
<pre><code class="language-java">// Find only full-time employees
TypedQuery&lt;Employee&gt; ftQuery = entityManager.createQuery(
    &quot;SELECT e FROM Employee e WHERE TYPE(e) = FullTimeEmployee&quot;, Employee.class);
List&lt;Employee&gt; fullTimeEmployees = ftQuery.getResultList();

// Count by subtype
TypedQuery&lt;Object[]&gt; countQuery = entityManager.createQuery(
    &quot;SELECT TYPE(e), COUNT(e) FROM Employee e GROUP BY TYPE(e)&quot;, Object[].class);
List&lt;Object[]&gt; results = countQuery.getResultList();
for (Object[] result : results) {
    System.out.println(&quot;Type: &quot; + result[0] + &quot;, Count: &quot; + result[1]);
}
</code></pre>
<ol start="4">
    <li><strong>TREAT operator for subtype properties</strong>:</li>
</ol>
<pre><code class="language-java">// Query using subtype property
TypedQuery&lt;FullTimeEmployee&gt; highSalaryQuery = entityManager.createQuery(
    &quot;SELECT e FROM Employee e WHERE TREAT(e AS FullTimeEmployee).salary &gt; :minSalary&quot;,
    FullTimeEmployee.class);
highSalaryQuery.setParameter(&quot;minSalary&quot;, new BigDecimal(&quot;100000&quot;));
List&lt;FullTimeEmployee&gt; highPaidEmployees = highSalaryQuery.getResultList();
</code></pre>
<p>Polymorphic queries work with all inheritance strategies but perform best with SINGLE_TABLE.</p>
<h3 id="150-what-is-the-persistencexml-file-and-is-it-always-required">150. What is the persistence.xml file and is it always required?</h3>
<p><strong>Answer:</strong> <code>persistence.xml</code> is a JPA configuration file that defines persistence units:</p>
<pre><code class="language-xml">&lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot;
             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
             xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence
                                 http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot;
             version=&quot;2.2&quot;&gt;
    &lt;persistence-unit name=&quot;myPU&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;
        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;
        &lt;class&gt;com.example.domain.Employee&lt;/class&gt;
        &lt;class&gt;com.example.domain.Department&lt;/class&gt;
        &lt;properties&gt;
            &lt;property name=&quot;javax.persistence.jdbc.url&quot;
                     value=&quot;jdbc:mysql://localhost:3306/employeedb&quot;/&gt;
            &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;user&quot;/&gt;
            &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;password&quot;/&gt;
            &lt;property name=&quot;javax.persistence.jdbc.driver&quot;
                     value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</code></pre>
<p><strong>Is persistence.xml always required?</strong></p>
<p>No, it&#39;s not always required:</p>
<ol>
    <li><p><strong>Required in</strong>:</p>
        <ul>
            <li>Java SE environments</li>
            <li>Basic Java EE without container injection</li>
            <li>Applications using the standard <code>Persistence.createEntityManagerFactory()</code> bootstrap</li>
        </ul>
    </li>
    <li><p><strong>Not required in</strong>:</p>
        <ul>
            <li>Spring Boot applications (replaced by application.properties/yml)</li>
            <li>Applications using programmatic configuration</li>
            <li>Container-managed environments with alternative configuration mechanisms</li>
        </ul>
    </li>
</ol>
<p>Spring Boot example (no persistence.xml):</p>
<pre><code class="language-properties"># application.properties
spring.datasource.url=jdbc:mysql://localhost:3306/employeedb
spring.datasource.username=user
spring.datasource.password=password
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
</code></pre>
</body>
</html>