<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title></title>

  <link href="../style.css" rel="stylesheet" type="text/css" >
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
  <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11/build/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

</head>
<body>
<h1 id="micronaut-framework-interview-questions-and-answers">Micronaut Framework Interview Questions and Answers</h1>
<h3 id="1-what-is-micronaut-framework">1. What is Micronaut Framework?</h3>
<p><strong>Answer:</strong> Micronaut is a modern, JVM-based, full-stack framework for building modular, easily testable microservices and serverless applications. It was developed by the creators of Grails and provides dependency injection, AOP support, and configuration management without using reflection, resulting in fast startup times and lower memory consumption.</p>
<h3 id="2-what-are-the-key-features-of-micronaut">2. What are the key features of Micronaut?</h3>
<p><strong>Answer:</strong> Key features include compile-time dependency injection and AOP, ultra-fast startup time, low memory footprint, no runtime reflection, native cloud support, reactive and non-blocking HTTP client and server, built-in service discovery, and integrated testing capabilities.</p>
<h3 id="3-how-does-micronaut-differ-from-spring-boot">3. How does Micronaut differ from Spring Boot?</h3>
<p><strong>Answer:</strong> Unlike Spring Boot which uses runtime reflection, Micronaut uses annotation processors at compile-time to perform dependency injection. This approach results in faster startup times, reduced memory usage, and works better with GraalVM native image. Micronaut also has a smaller codebase and doesn&#39;t require proxies for bean creation.</p>
<h3 id="4-what-is-compile-time-dependency-injection-in-micronaut">4. What is compile-time dependency injection in Micronaut?</h3>
<p><strong>Answer:</strong> Compile-time dependency injection means Micronaut processes annotations during compilation rather than at runtime. It generates classes that handle dependency injection, eliminating the need for reflection and improving startup performance. This approach also enables ahead-of-time (AOT) compilation and helps identify configuration issues at compile-time.</p>
<h3 id="5-how-do-you-create-a-new-micronaut-application">5. How do you create a new Micronaut application?</h3>
<p><strong>Answer:</strong> You can create a new Micronaut application using the Micronaut CLI with <code>mn create-app my-app</code>, using the Micronaut Launch web interface at <a href="https://launch.micronaut.io">https://launch.micronaut.io</a>, or with build tools by adding Micronaut dependencies to your Maven/Gradle project and configuring the annotation processor.</p>
<h3 id="6-what-build-tools-are-supported-by-micronaut">6. What build tools are supported by Micronaut?</h3>
<p><strong>Answer:</strong> Micronaut supports Gradle and Maven as build tools. Both have plugins and configurations available for Micronaut projects. Gradle is the default build tool when creating a new project with the Micronaut CLI or Launch interface, but Maven is equally well-supported.</p>
<h3 id="7-what-is-the-purpose-of-the-singleton-annotation-in-micronaut">7. What is the purpose of the @Singleton annotation in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>@Singleton</code> annotation in Micronaut marks a class as a singleton bean that should only be instantiated once in the application context. Beans with this annotation are lazy by default (created when first requested) and remain in memory for the application&#39;s lifetime, making them suitable for stateless services.</p>
<h3 id="8-how-does-micronaut-handle-configuration">8. How does Micronaut handle configuration?</h3>
<p><strong>Answer:</strong> Micronaut uses a PropertySources abstraction for configuration. It can load configuration from various sources including application.yml, application.properties, environment variables, and command-line arguments. Configuration follows a precedence order and supports environment-specific configurations through application-{environment}.yml files.</p>
<h3 id="9-what-is-the-controller-annotation-used-for-in-micronaut">9. What is the @Controller annotation used for in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>@Controller</code> annotation in Micronaut marks a class as a controller that handles HTTP requests. It&#39;s used with method annotations like <code>@Get</code>, <code>@Post</code>, <code>@Put</code>, and <code>@Delete</code> to define routes. Controllers automatically become beans in the application context and can have other beans injected into them.</p>
<h3 id="10-how-do-you-define-a-route-in-a-micronaut-controller">10. How do you define a route in a Micronaut controller?</h3>
<p><strong>Answer:</strong> Routes are defined using HTTP method annotations on controller methods. For example: <code>@Get(&quot;/hello&quot;)</code> maps GET requests to &quot;/hello&quot;, <code>@Post(&quot;/users&quot;)</code> maps POST requests to &quot;/users&quot;. You can include path variables (<code>@Get(&quot;/users/{id}&quot;)</code>) and access them with the <code>@PathVariable</code> annotation on method parameters.</p>
<h3 id="11-what-is-the-purpose-of-the-client-annotation-in-micronaut">11. What is the purpose of the @Client annotation in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>@Client</code> annotation is used to create declarative HTTP clients in Micronaut. It allows you to define an interface that Micronaut will implement at compile-time, handling all the HTTP request/response processing. This makes API integrations cleaner and more maintainable compared to manual HTTP client implementation.</p>
<h3 id="12-how-does-micronaut-handle-dependency-injection">12. How does Micronaut handle dependency injection?</h3>
<p><strong>Answer:</strong> Micronaut handles dependency injection at compile-time using annotation processors rather than runtime reflection. When you annotate a class with <code>@Singleton</code>, <code>@Controller</code>, etc., Micronaut generates the necessary metadata during compilation. Dependencies are then resolved and injected when the application starts without using reflection.</p>
<h3 id="13-what-is-the-introspected-annotation-used-for">13. What is the @Introspected annotation used for?</h3>
<p><strong>Answer:</strong> The <code>@Introspected</code> annotation enables compile-time generation of bean introspection metadata for a class. This allows Micronaut to perform operations like validation and data binding without using reflection. It&#39;s particularly useful for DTOs, request/response objects, and other classes that need property access but aren&#39;t managed beans.</p>
<h3 id="14-how-does-micronaut-support-reactive-programming">14. How does Micronaut support reactive programming?</h3>
<p><strong>Answer:</strong> Micronaut has built-in support for reactive programming through integration with reactive libraries like RxJava and Project Reactor. Controllers and clients can return reactive types (<code>Flux</code>, <code>Mono</code>, <code>Flowable</code>, <code>Single</code>), and Micronaut&#39;s HTTP server and client are built on Netty, which provides non-blocking I/O capabilities.</p>
<h3 id="15-what-is-the-function-of-applicationyml-in-a-micronaut-application">15. What is the function of application.yml in a Micronaut application?</h3>
<p><strong>Answer:</strong> The <code>application.yml</code> file is the main configuration file for Micronaut applications. It contains configuration properties for the application, including server settings, logging configuration, database connections, custom application properties, and environment-specific settings. YAML format is preferred for its hierarchical structure, but properties files are also supported.</p>
<h3 id="16-how-do-you-handle-validation-in-micronaut">16. How do you handle validation in Micronaut?</h3>
<p><strong>Answer:</strong> Micronaut supports validation through the Bean Validation API (JSR 380). You can add validation annotations like <code>@NotNull</code>, <code>@Size</code>, or <code>@Email</code> to class fields or method parameters, and use <code>@Valid</code> on complex objects. Validation is performed at compile-time using the <code>@Introspected</code> annotation, offering better performance than reflection-based validation.</p>
<h3 id="17-what-is-the-purpose-of-eventlistener-in-micronaut">17. What is the purpose of @EventListener in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>@EventListener</code> annotation allows methods to listen for and respond to application events. When an event is published using the <code>ApplicationEventPublisher</code>, methods annotated with <code>@EventListener</code> that accept that event type will be called. This enables loosely-coupled communication between different components of your application.</p>
<h3 id="18-how-does-micronaut-support-environment-specific-configuration">18. How does Micronaut support environment-specific configuration?</h3>
<p><strong>Answer:</strong> Micronaut supports environment-specific configuration through environment-specific property files like <code>application-dev.yml</code>, <code>application-test.yml</code>, and <code>application-prod.yml</code>. You can set the active environment using the <code>micronaut.environments</code> system property or <code>MICRONAUT_ENVIRONMENTS</code> environment variable. Properties in environment-specific files override those in the default <code>application.yml</code>.</p>
<h3 id="19-what-is-the-requires-annotation-used-for-in-micronaut">19. What is the @Requires annotation used for in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>@Requires</code> annotation is used for conditional bean loading in Micronaut. It allows beans to be included in the application context only when specific conditions are met, such as when certain classes are present on the classpath, specific configuration properties exist, or environment variables are set, enabling flexible application configuration.</p>
<h3 id="20-how-do-you-write-tests-for-a-micronaut-application">20. How do you write tests for a Micronaut application?</h3>
<p><strong>Answer:</strong> Micronaut provides comprehensive testing support through the <code>micronaut-test</code> module. You can use <code>@MicronautTest</code> to start a Micronaut application context for tests, inject beans, and test HTTP endpoints using <code>@Client</code>. For unit tests, beans can be mocked with <code>@MockBean</code>. Micronaut&#39;s compile-time approach makes tests start quickly and consume less memory.
  Thank you for providing the timestamp and login information, Vin-it-9. Here&#39;s the next set of Micronaut interview questions and answers:</p>
<h3 id="21-what-is-the-difference-between-inject-and-value-annotations-in-micronaut">21. What is the difference between @Inject and @Value annotations in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>@Inject</code> annotation is used for dependency injection of beans, while <code>@Value</code> injects configuration values from properties files or environment variables. <code>@Inject</code> resolves beans from the application context, whereas <code>@Value</code> uses the expression language to resolve property values, often with a default fallback like <code>@Value(&quot;${my.property:defaultValue}&quot;)</code>.</p>
<h3 id="22-how-does-micronaut-support-database-access">22. How does Micronaut support database access?</h3>
<p><strong>Answer:</strong> Micronaut provides data access support through modules like <code>micronaut-data-jdbc</code>, <code>micronaut-data-jpa</code>, and <code>micronaut-data-r2dbc</code>. These offer compile-time repository implementations that work without reflection. Micronaut Data uses annotation processors to generate query implementations at compile-time, reducing startup time and memory usage compared to runtime-generated proxies.</p>
<h3 id="23-what-is-the-purpose-of-executable-annotation-in-micronaut">23. What is the purpose of @Executable annotation in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>@Executable</code> annotation marks methods that should have implementation classes generated at compile-time. It&#39;s particularly used in repository interfaces with Micronaut Data to generate the query implementation during compilation. This approach avoids runtime proxy generation and reflection, making applications more efficient and compatible with GraalVM native images.</p>
<h3 id="24-how-do-you-implement-exception-handling-in-micronaut-controllers">24. How do you implement exception handling in Micronaut controllers?</h3>
<p><strong>Answer:</strong> Exception handling in Micronaut is done by implementing the <code>ExceptionHandler</code> interface and annotating the class with <code>@Error</code>. You specify the exception type and can optionally define the status code. These handlers can be global or controller-specific, and they transform exceptions into appropriate HTTP responses with custom error messages and status codes.</p>
<h3 id="25-what-is-the-purpose-of-the-beancontext-in-micronaut">25. What is the purpose of the BeanContext in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>BeanContext</code> is Micronaut&#39;s IoC container that manages beans and their dependencies. It&#39;s responsible for bean instantiation, dependency injection, and lifecycle management. Unlike traditional IoC containers, Micronaut&#39;s <code>BeanContext</code> doesn&#39;t use reflection but relies on precomputed metadata generated during compilation, making it more efficient and GraalVM-friendly.</p>
<h3 id="26-how-does-micronaut-support-request-scoped-beans">26. How does Micronaut support request scoped beans?</h3>
<p><strong>Answer:</strong> Micronaut supports request-scoped beans through the <code>@RequestScope</code> annotation. Beans with this scope are created once per HTTP request and destroyed when the request completes. This is useful for beans that need to maintain state during a single request but shouldn&#39;t share state between different requests, like user authentication information or request-specific caching.</p>
<h3 id="27-what-is-content-negotiation-in-micronaut-and-how-is-it-implemented">27. What is content negotiation in Micronaut and how is it implemented?</h3>
<p><strong>Answer:</strong> Content negotiation in Micronaut allows an endpoint to produce different representations of the same resource based on client preferences. It&#39;s implemented using the <code>@Produces</code> and <code>@Consumes</code> annotations to specify supported media types. Micronaut uses the HTTP Accept header to determine the response format (JSON, XML, etc.) and the Content-Type header for request parsing.</p>
<h3 id="28-how-do-you-implement-server-side-validation-in-micronaut">28. How do you implement server-side validation in Micronaut?</h3>
<p><strong>Answer:</strong> Server-side validation in Micronaut uses Bean Validation (JSR 380) annotations on controller method parameters or request bodies. To enable validation, add the <code>micronaut-validation</code> dependency, annotate classes with <code>@Introspected</code>, and use <code>@Valid</code> on parameters that need validation. Validation failures automatically result in HTTP 400 responses with detailed error messages.</p>
<h3 id="29-what-is-the-difference-between-controller-and-restcontroller">29. What is the difference between @Controller and @RestController?</h3>
<p><strong>Answer:</strong> In Micronaut, <code>@Controller</code> is the primary annotation for defining HTTP request handlers. There is no separate <code>@RestController</code> annotation as in Spring. All Micronaut controllers function as REST controllers by default, automatically handling serialization/deserialization of request and response bodies to and from JSON or other formats based on content negotiation.</p>
<h3 id="30-how-do-you-enable-cors-in-a-micronaut-application">30. How do you enable CORS in a Micronaut application?</h3>
<p><strong>Answer:</strong> To enable CORS (Cross-Origin Resource Sharing) in Micronaut, configure it in your application.yml file under the <code>micronaut.server.cors</code> section. You can specify allowed origins, methods, headers, and whether credentials are supported. For more specific control, you can use the <code>@CrossOrigin</code> annotation on controller classes or methods to define CORS settings at a more granular level.
  Thank you for providing the timestamp and login information, Vin-it-9. Here&#39;s the next set of Micronaut interview questions and answers:</p>
<h3 id="31-what-is-the-micronaut-cli-and-what-are-its-benefits">31. What is the Micronaut CLI and what are its benefits?</h3>
<p><strong>Answer:</strong> Micronaut CLI is a command-line tool that simplifies creating Micronaut projects and components. It provides commands like <code>mn create-app</code>, <code>mn create-controller</code>, and <code>mn create-bean</code> to scaffold applications and components with proper structure. The CLI helps developers get started quickly, ensures best practices, and can generate different project types with various features pre-configured.</p>
<h3 id="32-how-do-you-implement-authentication-in-micronaut">32. How do you implement authentication in Micronaut?</h3>
<p><strong>Answer:</strong> Micronaut Security provides authentication through the <code>micronaut-security</code> module. You can implement authentication by configuring security providers (LDAP, JDBC, OAuth2, etc.) in application.yml and creating security filters. Authentication can be session-based or token-based (JWT), and integrated with login controllers. The <code>@Secured</code> annotation protects resources based on user roles.</p>
<h3 id="33-what-is-the-function-of-pathvariable-in-micronaut">33. What is the function of @PathVariable in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>@PathVariable</code> annotation binds a method parameter to a URI template variable in the request path. For example, in a route like <code>/users/{id}</code>, you can access the ID value with <code>@PathVariable String id</code>. It extracts the value from the URI path and converts it to the appropriate type (String, Integer, UUID, etc.) before injecting it into your controller method.</p>
<h3 id="34-how-do-you-implement-background-job-processing-in-micronaut">34. How do you implement background job processing in Micronaut?</h3>
<p><strong>Answer:</strong> Micronaut supports background processing through <code>@Scheduled</code> tasks and integration with job schedulers. The <code>@Scheduled</code> annotation allows methods to be executed periodically. For more complex requirements, Micronaut integrates with libraries like Quartz for advanced scheduling or can connect to message queues (RabbitMQ, Kafka) for asynchronous job processing.</p>
<h3 id="35-what-is-the-purpose-of-retryable-in-micronaut">35. What is the purpose of @Retryable in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>@Retryable</code> annotation enables automatic retry behavior for methods that might fail due to transient errors. You can configure it with parameters like <code>attempts</code> (max retry count), <code>delay</code> (time between retries), and <code>includes</code> (which exceptions should trigger retry). It&#39;s useful for operations like API calls to external services that may experience temporary network issues.</p>
<h3 id="36-how-does-micronaut-handle-request-parameters">36. How does Micronaut handle request parameters?</h3>
<p><strong>Answer:</strong> Micronaut binds request parameters to method parameters using annotations. For query parameters, use <code>@QueryValue</code>. For form data, use <code>@Part</code> or <code>@Body</code>. For path variables, use <code>@PathVariable</code>. For HTTP headers, use <code>@Header</code>. Each annotation extracts data from the appropriate part of the request and converts it to the target type.</p>
<h3 id="37-what-is-the-role-of-the-application-context-in-micronaut">37. What is the role of the application context in Micronaut?</h3>
<p><strong>Answer:</strong> The application context in Micronaut is the central registry of beans. It&#39;s responsible for managing the lifecycle of beans, providing dependency injection, and handling configuration. When a Micronaut application starts, it creates an application context, discovers and instantiates all beans, injects dependencies, and makes them available for use throughout the application.</p>
<h3 id="38-how-do-you-implement-method-interception-in-micronaut">38. How do you implement method interception in Micronaut?</h3>
<p><strong>Answer:</strong> Method interception in Micronaut is implemented using AOP with annotations like <code>@Around</code>, <code>@Before</code>, <code>@After</code>, and <code>@AfterReturning</code>. You create a custom annotation (marked with <code>@Introduction</code> or <code>@InterceptorBinding</code>) and an associated interceptor class that implements <code>MethodInterceptor</code>. Unlike Spring, Micronaut performs AOP at compile-time, generating bytecode rather than using runtime proxies.</p>
<h3 id="39-what-is-the-purpose-of-transactional-in-micronaut">39. What is the purpose of @Transactional in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>@Transactional</code> annotation in Micronaut manages database transactions. It ensures that all database operations within a method either complete successfully or roll back entirely. You can configure isolation levels, propagation behavior, and which exceptions should trigger rollback. Like other Micronaut features, transaction management is implemented at compile-time rather than through runtime proxies.</p>
<h3 id="40-how-do-you-deploy-a-micronaut-application">40. How do you deploy a Micronaut application?</h3>
<p><strong>Answer:</strong> Micronaut applications can be deployed as standalone JARs with <code>./gradlew build</code> or <code>./mvnw package</code>, then running with <code>java -jar app.jar</code>. They can be containerized with Docker, deployed to Kubernetes, or run as serverless functions on platforms like AWS Lambda. Micronaut&#39;s small memory footprint and fast startup time make it suitable for cloud deployments and container orchestration platforms.
  Thank you for providing the timestamp and login information, Vin-it-9. Here&#39;s the final set of Micronaut interview questions and answers:</p>
<h3 id="41-how-does-micronaut-support-serverless-deployments">41. How does Micronaut support serverless deployments?</h3>
<p><strong>Answer:</strong> Micronaut supports serverless deployments through specialized modules like <code>micronaut-function-aws</code> and <code>micronaut-azure-function</code>. Its fast startup and low memory footprint make it ideal for serverless environments. The framework can automatically adapt your application for specific serverless platforms, handling the function entry points and transforming HTTP requests to the appropriate format.</p>
<h3 id="42-what-is-micronaut-data-and-how-is-it-different-from-other-orm-frameworks">42. What is Micronaut Data and how is it different from other ORM frameworks?</h3>
<p><strong>Answer:</strong> Micronaut Data is a database access toolkit that generates repositories at compile time rather than runtime. Unlike Hibernate or Spring Data which use reflection and runtime proxies, Micronaut Data&#39;s compile-time approach offers significant performance benefits. It supports SQL (JDBC, R2DBC) and NoSQL databases, and generates queries based on method names or annotations during compilation.</p>
<h3 id="43-how-do-you-implement-caching-in-micronaut">43. How do you implement caching in Micronaut?</h3>
<p><strong>Answer:</strong> Micronaut provides caching through the <code>@Cacheable</code>, <code>@CachePut</code>, and <code>@CacheInvalidate</code> annotations. Add the <code>micronaut-cache-caffeine</code> dependency (or Redis/Hazelcast for distributed caching), then annotate methods to cache their results. The caching system works at compile-time without reflection, making it more efficient than traditional Spring caching.</p>
<h3 id="44-what-is-graalvm-native-image-support-in-micronaut">44. What is GraalVM Native Image support in Micronaut?</h3>
<p><strong>Answer:</strong> Micronaut has first-class support for GraalVM Native Image compilation, which converts Java applications into native executables. This results in incredibly fast startup times (milliseconds) and reduced memory usage. Since Micronaut avoids reflection, proxies, and runtime bytecode generation, it&#39;s naturally compatible with GraalVM&#39;s limitations, requiring minimal additional configuration.</p>
<h3 id="45-how-do-you-configure-logging-in-a-micronaut-application">45. How do you configure logging in a Micronaut application?</h3>
<p><strong>Answer:</strong> Micronaut uses SLF4J with Logback as the default logging implementation. Configure logging in the <code>logback.xml</code> file in the resources directory, or via properties in <code>application.yml</code> under the <code>logger.levels</code> namespace. You can set log levels for specific packages, configure appenders for console/file output, and enable advanced features like MDC logging or async logging.</p>
<h3 id="46-what-is-service-discovery-in-micronaut-and-how-is-it-implemented">46. What is service discovery in Micronaut and how is it implemented?</h3>
<p><strong>Answer:</strong> Service discovery in Micronaut allows services to find and communicate with each other without hardcoded URLs. Micronaut supports multiple service discovery mechanisms including Consul, Eureka, and Kubernetes. Configure your service registry in <code>application.yml</code>, annotate clients with <code>@Client(id = &quot;service-id&quot;)</code>, and Micronaut automatically handles service lookup and load balancing.</p>
<h3 id="47-how-does-micronaut-support-configuration-properties">47. How does Micronaut support configuration properties?</h3>
<p><strong>Answer:</strong> Micronaut supports type-safe configuration properties using the <code>@ConfigurationProperties</code> annotation. Create a class with this annotation defining the configuration prefix, add fields with corresponding property names, and Micronaut will bind configuration values from application.yml or environment variables at startup. This approach provides compile-time validation of configuration rather than runtime errors.</p>
<h3 id="48-what-is-the-difference-between-factory-and-singleton-in-micronaut">48. What is the difference between @Factory and @Singleton in Micronaut?</h3>
<p><strong>Answer:</strong> <code>@Factory</code> annotates a class that produces beans through methods annotated with <code>@Bean</code>, similar to factory patterns. It&#39;s used to programmatically create and configure beans, especially third-party objects. <code>@Singleton</code> directly annotates a class to make it a singleton bean. Use <code>@Factory</code> when you need custom bean creation logic, and <code>@Singleton</code> for straightforward beans.</p>
<h3 id="49-how-does-micronaut-handle-http-client-communication">49. How does Micronaut handle HTTP client communication?</h3>
<p><strong>Answer:</strong> Micronaut provides both declarative and low-level HTTP clients. For declarative clients, create an interface with <code>@Client</code> annotation and method declarations with HTTP method annotations (<code>@Get</code>, <code>@Post</code>). For low-level API, use <code>HttpClient</code>. Both support synchronous and reactive (non-blocking) communication, automatic JSON serialization/deserialization, and circuit breakers for fault tolerance.</p>
<h3 id="50-how-can-you-optimize-a-micronaut-application-for-production">50. How can you optimize a Micronaut application for production?</h3>
<p><strong>Answer:</strong> To optimize a Micronaut application for production: enable ahead-of-time compilation with GraalVM for faster startup; configure appropriate JVM settings; use proper connection pooling for databases; implement caching strategies; enable response compression; optimize logging levels; implement circuit breakers for external services; and use metrics monitoring through Micrometer to identify performance bottlenecks.</p>
<h3 id="51-what-are-bean-introspections-in-micronaut-and-why-are-they-important">51. What are Bean Introspections in Micronaut and why are they important?</h3>
<p><strong>Answer:</strong> Bean Introspections in Micronaut provide a reflection-free way to access bean properties. Classes annotated with <code>@Introspected</code> have metadata generated at compile-time, enabling operations like validation, data binding, and JSON serialization without reflection. This approach is crucial for GraalVM native image support and improves performance by eliminating the need for runtime reflection.</p>
<h3 id="52-how-do-you-configure-multiple-data-sources-in-a-micronaut-application">52. How do you configure multiple data sources in a Micronaut application?</h3>
<p><strong>Answer:</strong> To configure multiple data sources, define them under separate namespaces in <code>application.yml</code> (e.g., <code>datasources.default</code> and <code>datasources.secondary</code>). Create corresponding <code>@EachProperty(&quot;datasources&quot;)</code> configuration classes and use qualifiers like <code>@Named(&quot;secondary&quot;)</code> when injecting data sources. With Micronaut Data, use <code>@JdbcRepository(dataSource = &quot;secondary&quot;)</code> to specify which data source a repository should use.</p>
<h3 id="53-what-is-the-purpose-of-context-annotation-in-micronaut">53. What is the purpose of @Context annotation in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>@Context</code> annotation marks a bean to be bound to the request context but with a broader scope than <code>@RequestScope</code>. Context scoped beans are created once per HTTP request but are shared across the request processing chain. This makes them suitable for request-specific data that needs to be accessed by multiple components during request processing.</p>
<h3 id="54-how-can-you-configure-micronaut-to-run-on-a-specific-port">54. How can you configure Micronaut to run on a specific port?</h3>
<p><strong>Answer:</strong> To configure Micronaut to run on a specific port, set <code>micronaut.server.port</code> property in <code>application.yml</code> (e.g., <code>micronaut.server.port: 8080</code>). You can also set it via environment variable <code>MICRONAUT_SERVER_PORT</code> or as a JVM system property <code>-Dmicronaut.server.port=8080</code>. For random port assignment during testing, use <code>micronaut.server.port: -1</code>.</p>
<h3 id="55-what-are-the-different-bean-scopes-available-in-micronaut">55. What are the different bean scopes available in Micronaut?</h3>
<p><strong>Answer:</strong> Micronaut offers several bean scopes: <code>@Singleton</code> (default, one instance per application), <code>@Context</code> (one instance per request chain), <code>@RequestScope</code> (one instance per HTTP request), <code>@Prototype</code> (new instance each time requested), <code>@ThreadLocal</code> (one instance per thread), <code>@Refreshable</code> (reloadable without restart), and <code>@SessionScope</code> (one instance per user session in web applications).</p>
<h3 id="56-how-does-lazy-initialization-work-in-micronaut">56. How does lazy initialization work in Micronaut?</h3>
<p><strong>Answer:</strong> In Micronaut, beans are lazily initialized by default, meaning they&#39;re created only when first requested, not at application startup. You can make a bean eager (instantiated at startup) by setting <code>@Singleton(preDestroy=&quot;true&quot;)</code> or globally configure eager initialization with <code>micronaut.context.eager-init-singletons: true</code>. Lazy initialization reduces startup time but can delay first request processing.</p>
<h3 id="57-what-is-the-secondary-annotation-used-for-in-micronaut">57. What is the @Secondary annotation used for in Micronaut?</h3>
<p><strong>Answer:</strong> The <code>@Secondary</code> annotation marks a bean as a secondary candidate when multiple beans of the same type exist in the application context. When multiple beans qualify for injection, Micronaut prefers beans without the <code>@Secondary</code> annotation. This provides a simple way to define fallback beans that are used only when a primary implementation is unavailable.</p>
<h3 id="58-how-do-you-implement-custom-bean-qualifiers-in-micronaut">58. How do you implement custom bean qualifiers in Micronaut?</h3>
<p><strong>Answer:</strong> Custom bean qualifiers in Micronaut are created by defining an annotation with <code>@Qualifier</code> meta-annotation. The custom annotation should have <code>@Retention(RUNTIME)</code> and can include attributes. Apply this custom qualifier to both the bean definition and the injection point. This approach provides type-safe dependency resolution when you have multiple beans of the same type.</p>
<h3 id="59-what-is-the-configurationreader-annotation-used-for">59. What is the @ConfigurationReader annotation used for?</h3>
<p><strong>Answer:</strong> The <code>@ConfigurationReader</code> annotation is used with <code>@ConfigurationBuilder</code> to map configuration properties to a builder pattern API. It&#39;s particularly useful when configuring third-party libraries that use builders. This annotation tells Micronaut to read configuration values and apply them to the builder, allowing type-safe configuration of complex objects without custom code.</p>
<h3 id="60-how-do-you-override-beans-in-micronaut-for-testing">60. How do you override beans in Micronaut for testing?</h3>
<p><strong>Answer:</strong> To override beans in Micronaut tests, use <code>@Replaces(Bean.class)</code> on your test replacement bean. For more control, implement the <code>BeanDefinitionCustomizer</code> interface and register it with <code>ApplicationContextBuilder</code>. You can also use <code>ApplicationContext.registerSingleton()</code> to programmatically replace beans. The <code>@MockBean</code> annotation provides a convenient way to replace beans with mocks in tests.</p>
<h3 id="61-how-does-micronauts-testing-support-differ-from-spring-boots">61. How does Micronaut&#39;s testing support differ from Spring Boot&#39;s?</h3>
<p><strong>Answer:</strong> Micronaut&#39;s testing support emphasizes compile-time components over runtime proxies, resulting in faster test startup. The <code>@MicronautTest</code> annotation is similar to Spring&#39;s <code>@SpringBootTest</code> but creates a lightweight context. Micronaut tests don&#39;t rely on reflection-based mocking frameworks and work better with GraalVM. Additionally, Micronaut&#39;s test context is shared across test classes by default, improving test suite performance.</p>
<h3 id="62-what-is-the-purpose-of-mockbean-in-micronaut-tests">62. What is the purpose of @MockBean in Micronaut tests?</h3>
<p><strong>Answer:</strong> The <code>@MockBean</code> annotation in Micronaut replaces a bean in the application context with a mock implementation for testing. Unlike Spring&#39;s mocking, which relies on runtime proxies, Micronaut creates compile-time mock implementations. Specify the bean to mock with <code>@MockBean(Bean.class)</code>, and use the returned mock object to define behavior with Mockito-style syntax.</p>
<h3 id="63-how-do-you-test-micronaut-http-clients">63. How do you test Micronaut HTTP clients?</h3>
<p><strong>Answer:</strong> To test Micronaut HTTP clients, use <code>@MicronautTest</code> with an embedded server and inject the client with <code>@Inject</code>. For more control, use <code>EmbeddedServer</code> with <code>ApplicationContext.run()</code> to programmatically start the server. You can also use <code>HttpClientTestUtils</code> to test client behavior without a server by providing mock responses, or use external tools like MockServer or WireMock.</p>
<h3 id="64-what-is-the-difference-between-micronauttest-and-manual-applicationcontext-setup">64. What is the difference between @MicronautTest and manual ApplicationContext setup?</h3>
<p><strong>Answer:</strong> <code>@MicronautTest</code> automatically creates and manages an application context for the test class, handling bean injection and server startup. Manual context setup with <code>ApplicationContext.run()</code> provides more control over context configuration and lifecycle. <code>@MicronautTest</code> is preferable for standard tests while manual setup is better for specialized scenarios requiring custom context configuration or programmatic bean registration.</p>
<h3 id="65-how-do-you-deploy-micronaut-applications-to-serverless-environments-like-aws-lambda">65. How do you deploy Micronaut applications to serverless environments like AWS Lambda?</h3>
<p><strong>Answer:</strong> To deploy to AWS Lambda, add the <code>micronaut-function-aws</code> dependency and create a handler class that implements the appropriate Lambda interface. Use <code>@FunctionBean</code> for request-response functions or extend <code>MicronautRequestHandler</code>. Package as a shaded JAR or GraalVM native image for better cold start performance. Configure the function in AWS using the handler class name as the entry point.</p>
<h3 id="66-whats-the-recommended-way-to-test-micronaut-data-repositories">66. What&#39;s the recommended way to test Micronaut Data repositories?</h3>
<p><strong>Answer:</strong> Test Micronaut Data repositories with <code>@MicronautTest</code> and an in-memory database like H2. Configure test-specific database properties in <code>application-test.yml</code>. Use <code>@Transactional</code> to automatically rollback transactions between tests. For repository-specific tests, you can use <code>@DataJpaTest</code> (JPA) or <code>@DataJdbcTest</code> (JDBC) as more focused alternatives that load only repository-related beans.</p>
<h3 id="67-how-can-you-profile-a-micronaut-application-during-testing">67. How can you profile a Micronaut application during testing?</h3>
<p><strong>Answer:</strong> Profile a Micronaut application by enabling metrics with the <code>micronaut-micrometer</code> module and configure a reporter like JMX or Prometheus. Use <code>@MicronautTest(propertySources={&quot;classpath:profiling.yml&quot;})</code> to apply profiling-specific configuration. For memory profiling, use JVM tooling like VisualVM or async-profiler. The Micronaut CLI offers the <code>mn create-profile</code> command to create custom test profiles with specific configurations.</p>
<h3 id="68-what-container-tools-work-best-with-micronaut-applications">68. What container tools work best with Micronaut applications?</h3>
<p><strong>Answer:</strong> Micronaut works well with Docker for containerization and includes Dockerfiles when generated with the CLI. Jib is recommended for creating optimized containers without a Docker daemon. For orchestration, Kubernetes is well-supported through the <code>micronaut-kubernetes</code> module for service discovery and configuration. Docker Compose is useful for local development with multiple services.</p>
<h3 id="69-how-can-you-implement-continuous-deployment-for-a-micronaut-application">69. How can you implement continuous deployment for a Micronaut application?</h3>
<p><strong>Answer:</strong> Implement continuous deployment using CI/CD tools like Jenkins, GitHub Actions, or GitLab CI. Create a pipeline that builds the application, runs tests, packages it (as JAR or Docker image), and deploys to your target environment. Use Micronaut&#39;s built-in health checks for deployment validation. For Kubernetes, use the <code>micronaut-kubernetes</code> module to leverage readiness and liveness probes.</p>
<h3 id="70-how-does-micronaut-support-different-runtime-environments">70. How does Micronaut support different runtime environments?</h3>
<p><strong>Answer:</strong> Micronaut supports different environments through the <code>micronaut.environments</code> property. Add environment-specific configuration in files like <code>application-dev.yml</code> or <code>application-prod.yml</code>. Use the <code>@Requires(env=...)</code> annotation to conditionally include beans based on the active environment. Environment detection is automatic for platforms like Google App Engine, AWS Lambda, and Kubernetes, with appropriate defaults applied.</p>
<h3 id="71-how-does-micronauts-security-module-handle-jwt-authentication">71. How does Micronaut&#39;s security module handle JWT authentication?</h3>
<p><strong>Answer:</strong> Micronaut Security JWT creates and validates JSON Web Tokens using the <code>micronaut-security-jwt</code> module. Configure JWT settings in <code>application.yml</code> including issuer, expiration, and signature algorithms. Create a <code>JWTClaimsSetGenerator</code> bean for custom claims. JWT tokens are automatically validated on protected endpoints, and authentication details are available through <code>Authentication</code> or <code>Principal</code> objects.</p>
<h3 id="72-what-http-server-features-does-micronaut-support-out-of-the-box">72. What HTTP server features does Micronaut support out of the box?</h3>
<p><strong>Answer:</strong> Micronaut&#39;s HTTP server supports request routing, content negotiation, file uploads, server-sent events, WebSockets, HTTP/2, and HTTPS. It includes built-in support for response compression, CORS, static resource serving, and custom error handling. The server is built on Netty, providing non-blocking I/O for high concurrency, and supports both imperative and reactive programming models.</p>
<h3 id="73-how-do-you-implement-role-based-authorization-in-micronaut">73. How do you implement role-based authorization in Micronaut?</h3>
<p><strong>Answer:</strong> Implement role-based authorization using the <code>@Secured</code> annotation with role names (e.g., <code>@Secured(&quot;ROLE_ADMIN&quot;)</code>). Configure security rules in <code>application.yml</code> under <code>micronaut.security.intercept-url-map</code>. Create a custom <code>AuthenticationProvider</code> that populates user roles. Roles are stored in the <code>Authentication</code> object and can be accessed via the security context. Use expressions like <code>@Secured({&quot;isAuthenticated() &amp;&amp; hasRole(&#39;ADMIN&#39;)&quot;})</code> for complex rules.</p>
<h3 id="74-what-options-are-available-for-securing-endpoints-in-micronaut">74. What options are available for securing endpoints in Micronaut?</h3>
<p><strong>Answer:</strong> Secure endpoints in Micronaut using annotations like <code>@Secured</code> for role-based security or <code>@RequiresAuthentication</code> to require any authenticated user. For IP-based restrictions, use <code>@Requires(ip=&quot;192.168.1.0/24&quot;)</code>. Configure security through interceptor URL mapping in <code>application.yml</code>. Implement OAuth 2.0/OIDC using the dedicated modules, or create custom security filters by implementing the <code>HttpServerFilter</code> interface.</p>
<h3 id="75-how-do-you-handle-file-uploads-in-a-micronaut-controller">75. How do you handle file uploads in a Micronaut controller?</h3>
<p><strong>Answer:</strong> Handle file uploads by adding parameters annotated with <code>@Part</code> to controller methods. For a single file, use <code>CompletedFileUpload file</code>. For multiple files, use <code>CompletedFileUpload[] files</code> or <code>List&lt;CompletedFileUpload&gt;</code>. Access file metadata via methods like <code>getName()</code>, <code>getContentType()</code>, and <code>getSize()</code>. Access file content with <code>getInputStream()</code> or as bytes with <code>getBytes()</code>. Configure upload size limits in <code>application.yml</code>.</p>
<h3 id="76-what-is-content-negotiation-in-micronaut-and-how-is-it-implemented">76. What is content negotiation in Micronaut and how is it implemented?</h3>
<p><strong>Answer:</strong> Content negotiation allows endpoints to produce different representations (JSON, XML, etc.) based on the client&#39;s preference. Micronaut implements this through the <code>Accept</code> header and file extensions. Use <code>@Produces</code> to specify supported media types. The framework automatically selects appropriate encoders/decoders based on the content type, with Jackson as the default JSON processor. Custom media types can be added by implementing <code>MediaTypeCodec</code>.</p>
<h3 id="77-how-does-micronaut-implement-http-client-retry-and-circuit-breaking">77. How does Micronaut implement HTTP client retry and circuit breaking?</h3>
<p><strong>Answer:</strong> HTTP client retry is implemented with the <code>@Retryable</code> annotation, configuring parameters like <code>attempts</code>, <code>delay</code>, and which exceptions should trigger retries. Circuit breaking uses the <code>@CircuitBreaker</code> annotation from the <code>micronaut-retry</code> module, with configurable thresholds, reset timeouts, and fallback methods. Both features work with declarative clients and the low-level <code>HttpClient</code>, providing resilience against transient failures.</p>
<h3 id="78-what-is-the-purpose-of-http-filters-in-micronaut">78. What is the purpose of HTTP filters in Micronaut?</h3>
<p><strong>Answer:</strong> HTTP filters in Micronaut intercept and modify requests and responses before they reach controllers or after controllers generate responses. Create a filter by implementing <code>HttpServerFilter</code> or <code>HttpClientFilter</code> and annotate with <code>@Filter(&quot;/path/**&quot;)</code>. Filters can add headers, modify content, perform authentication, implement rate limiting, log requests, or reject requests based on custom criteria. They&#39;re executed in order of their priority.</p>
<h3 id="79-how-do-you-handle-response-caching-in-micronaut">79. How do you handle response caching in Micronaut?</h3>
<p><strong>Answer:</strong> Implement response caching in Micronaut using HTTP Cache-Control headers with the <code>@CacheControl</code> annotation on controller methods. For more advanced caching, use the <code>@Cacheable</code> annotation from the cache module. Configure cache providers like Caffeine (in-memory), Redis, or Hazelcast in your application.yml. Server responses can include cache validation headers like ETag or Last-Modified for conditional requests.</p>
<h3 id="80-how-do-you-implement-websockets-in-a-micronaut-application">80. How do you implement WebSockets in a Micronaut application?</h3>
<p><strong>Answer:</strong> Implement WebSockets by creating a class annotated with <code>@ServerWebSocket(&quot;/path&quot;)</code> and methods annotated with <code>@OnOpen</code>, <code>@OnMessage</code>, <code>@OnClose</code>, and <code>@OnError</code>. Use parameters like <code>Session</code> to interact with the connection and <code>WebSocketBroadcaster</code> to send messages to all clients. For reactive programming, methods can return <code>Publisher</code> types. Client-side WebSockets are created via the <code>WebSocketClient</code> interface.</p>
<h3 id="81-how-does-micronaut-integrate-with-kafka-for-messaging">81. How does Micronaut integrate with Kafka for messaging?</h3>
<p><strong>Answer:</strong> Micronaut provides Kafka integration through the <code>micronaut-kafka</code> module. Create Kafka consumers with <code>@KafkaListener</code> and producers with <code>@KafkaClient</code>. Configure Kafka connection details in <code>application.yml</code>. The integration supports key/value serialization/deserialization, record batch processing, and reactive streams. Both imperative and reactive programming models are supported, with seamless JSON conversion for POJOs.</p>
<h3 id="82-how-do-you-implement-event-driven-communication-between-micronaut-services">82. How do you implement event-driven communication between Micronaut services?</h3>
<p><strong>Answer:</strong> Implement event-driven communication using Micronaut&#39;s event system with <code>ApplicationEventPublisher</code> to emit events and <code>@EventListener</code> to handle them. For distributed events, use integration modules like <code>micronaut-kafka</code>, <code>micronaut-rabbitmq</code>, or <code>micronaut-redis</code>. Create event classes with <code>@Introspected</code> for proper serialization. Configure async event processing with the <code>micronaut-jms</code> module or reactive streams integration.</p>
<h3 id="83-what-messaging-systems-does-micronaut-support">83. What messaging systems does Micronaut support?</h3>
<p><strong>Answer:</strong> Micronaut supports multiple messaging systems through dedicated modules: Kafka (<code>micronaut-kafka</code>), RabbitMQ (<code>micronaut-rabbitmq</code>), NATS (<code>micronaut-nats</code>), MQTT (<code>micronaut-mqtt</code>), JMS (<code>micronaut-jms</code>), and Redis PubSub (<code>micronaut-redis</code>). Each integration provides consistent programming models using annotations like <code>@KafkaListener</code> or <code>@RabbitListener</code> and supports both imperative and reactive approaches, with automatic message conversion and error handling.</p>
<h3 id="84-how-does-micronaut-support-grpc">84. How does Micronaut support gRPC?</h3>
<p><strong>Answer:</strong> Micronaut supports gRPC through the <code>micronaut-grpc</code> module. Define services using Protocol Buffers (.proto files) and generate code with the protobuf compiler. Create server implementations by extending generated service classes and annotating with <code>@Singleton</code>. Create clients with <code>@GrpcClient</code>. The integration supports client/server streaming, deadline propagation, and metadata handling, with both blocking and reactive APIs.</p>
<h3 id="85-how-can-micronaut-services-discover-each-other">85. How can Micronaut services discover each other?</h3>
<p><strong>Answer:</strong> Micronaut services can discover each other using service discovery mechanisms configured in <code>application.yml</code>. The framework supports Consul, Eureka, Kubernetes, and AWS Route53 through dedicated modules. Use <code>@Client(id = &quot;service-name&quot;)</code> for declarative clients, and Micronaut will resolve the actual endpoint using the configured discovery service. Load balancing is built-in using round-robin or random selection strategies.</p>
<h3 id="86-how-does-micronaut-integrate-with-graphql">86. How does Micronaut integrate with GraphQL?</h3>
<p><strong>Answer:</strong> Micronaut integrates with GraphQL through the <code>micronaut-graphql</code> module, which uses GraphQL Java. Create a schema file defining types and operations, then implement resolvers as beans. Queries are sent to the <code>/graphql</code> endpoint by default. The integration supports schema validation, data fetching, subscriptions, and error handling. For advanced usage, implement <code>GraphQLContextBuilder</code> or <code>GraphQLRootContextBuilder</code> to provide custom context.</p>
<h3 id="87-how-can-you-schedule-recurring-tasks-in-micronaut">87. How can you schedule recurring tasks in Micronaut?</h3>
<p><strong>Answer:</strong> Schedule recurring tasks in Micronaut using the <code>@Scheduled</code> annotation from the <code>micronaut-scheduling</code> module. Configure schedules using cron expressions (<code>@Scheduled(cron=&quot;0 0 * * *&quot;)</code>), fixed delays (<code>@Scheduled(fixedDelay=&quot;10m&quot;)</code>), or fixed rates (<code>@Scheduled(fixedRate=&quot;1h&quot;)</code>). Methods can return <code>void</code> for simple tasks or <code>CompletableFuture</code>/reactive types for non-blocking execution. Scheduled tasks can be conditionally enabled with <code>@Requires</code>.</p>
<h3 id="88-how-does-micronaut-support-reactive-programming-with-project-reactor">88. How does Micronaut support reactive programming with Project Reactor?</h3>
<p><strong>Answer:</strong> Micronaut supports Project Reactor through the <code>micronaut-reactor</code> module, allowing you to use <code>Mono</code> and <code>Flux</code> types in controllers, clients, and services. Controllers can return reactive types directly, and HTTP clients can convert responses to <code>Mono</code> or <code>Flux</code>. The framework maintains the reactive execution model throughout the request chain, preventing thread blocking. Use <code>Schedulers.boundedElastic()</code> for non-blocking I/O operations.</p>
<h3 id="89-how-does-micronaut-integrate-with-cloud-platforms">89. How does Micronaut integrate with cloud platforms?</h3>
<p><strong>Answer:</strong> Micronaut offers dedicated modules for cloud platforms: <code>micronaut-aws</code> for AWS services, <code>micronaut-gcp</code> for Google Cloud, and <code>micronaut-azure</code> for Microsoft Azure. Each module provides client libraries, serverless function support, and cloud-specific service discovery. The framework automatically detects cloud environments and configures appropriate settings. Use annotations like <code>@AwsFunction</code> or <code>@FunctionHub</code> for serverless deployments.</p>
<h3 id="90-how-can-micronaut-services-communicate-with-rest-apis">90. How can Micronaut services communicate with REST APIs?</h3>
<p><strong>Answer:</strong> Micronaut services can communicate with REST APIs using declarative HTTP clients (interfaces with <code>@Client</code> annotation) or the low-level <code>HttpClient</code>. For declarative clients, define interfaces with methods annotated with <code>@Get</code>, <code>@Post</code>, etc., and Micronaut generates the implementation. For external APIs, use <code>@Client(&quot;https://api.example.com&quot;)</code>. Both approaches support JSON mapping, query parameters, headers, and reactive types.</p>
<h3 id="91-how-does-micronaut-achieve-its-fast-startup-time-compared-to-spring-boot">91. How does Micronaut achieve its fast startup time compared to Spring Boot?</h3>
<p><strong>Answer:</strong> Micronaut achieves fast startup by avoiding runtime reflection and generating metadata at compile time. While Spring Boot scans classpath, creates proxies, and processes annotations at runtime, Micronaut&#39;s annotation processors generate required classes during compilation. This approach eliminates the need for classpath scanning and runtime proxy generation, significantly reducing startup overhead and enabling ahead-of-time compilation.</p>
<h3 id="92-what-is-micronaut-aop-and-why-is-it-different-from-other-frameworks">92. What is Micronaut AOP and why is it different from other frameworks?</h3>
<p><strong>Answer:</strong> Micronaut AOP (Aspect-Oriented Programming) generates interceptors at compile time rather than using runtime proxies. This approach improves performance, reduces memory usage, and works well with GraalVM. Interceptors are created via annotation processors without reflection, unlike Spring or Jakarta EE which create proxy classes at runtime. Micronaut&#39;s approach avoids proxy-related limitations and works with final classes and methods.</p>
<h3 id="93-how-does-micronaut-support-observability-and-monitoring">93. How does Micronaut support observability and monitoring?</h3>
<p><strong>Answer:</strong> Micronaut supports observability through the <code>micronaut-micrometer</code> module, which provides metrics collection, and <code>micronaut-tracing</code> for distributed tracing. Metrics can be exposed to monitoring systems like Prometheus, Datadog, or CloudWatch. Tracing integrates with Zipkin or Jaeger to track requests across services. Health checks are provided by the management module, exposing endpoints for application health state monitoring.</p>
<h3 id="94-what-is-micronaut-launch-and-how-does-it-help-developers">94. What is Micronaut Launch and how does it help developers?</h3>
<p><strong>Answer:</strong> Micronaut Launch is a web-based and CLI tool for bootstrapping Micronaut applications. It allows developers to select language (Java, Kotlin, Groovy), build tool (Gradle, Maven), testing framework, and features like security, database access, or cloud support. The service generates a pre-configured project with selected dependencies and configuration. It&#39;s accessible at <a href="https://launch.micronaut.io">https://launch.micronaut.io</a> or via the CLI with <code>mn create-app</code>.</p>
<h3 id="95-how-do-you-optimize-a-micronaut-application-for-memory-usage">95. How do you optimize a Micronaut application for memory usage?</h3>
<p><strong>Answer:</strong> Optimize memory usage by using constructor injection instead of field injection, enabling bean introspection only where needed, and limiting the use of <code>@Prototype</code> scoped beans. Configure appropriate heap sizes, use GraalVM native image for significant memory reduction, and avoid reflection-based libraries. Remove unused dependencies and leverage Micronaut&#39;s inherently lower memory footprint due to its compile-time approach to dependency injection.</p>
<h3 id="96-how-does-micronaut-handle-thread-management-and-concurrency">96. How does Micronaut handle thread management and concurrency?</h3>
<p><strong>Answer:</strong> Micronaut handles concurrency through its reactive foundation built on Netty. It uses event loops for I/O operations and a configurable thread pool for request processing (<code>micronaut.server.executor</code>). For blocking operations, it automatically shifts execution to dedicated threads using <code>@ExecuteOn(TaskExecutors.IO)</code>. The framework supports both imperative and reactive programming models, with built-in thread context propagation for consistent behavior.</p>
<h3 id="97-whats-the-difference-between-bean-and-factory-annotation-in-micronaut">97. What&#39;s the difference between @Bean and @Factory annotation in Micronaut?</h3>
<p><strong>Answer:</strong> <code>@Bean</code> annotates methods within a class marked with <code>@Factory</code> to define beans programmatically, while <code>@Factory</code> marks the class containing these bean-producing methods. <code>@Bean</code> methods can accept parameters (dependencies) and have configuration like scope and qualifiers. This distinction separates the factory class from its produced beans, allowing complex initialization logic while maintaining dependency injection benefits.</p>
<h3 id="98-how-does-micronaut-handle-custom-metrics-collection">98. How does Micronaut handle custom metrics collection?</h3>
<p><strong>Answer:</strong> Custom metrics are collected using the <code>micronaut-micrometer</code> module by injecting a <code>MeterRegistry</code> and registering counters, gauges, timers, or distribution summaries. Use <code>@Timed</code> on methods to automatically time their execution or <code>@CountedMethod</code> to count invocations. Configure metric tags in application.yml under the <code>micronaut.metrics.tags</code> namespace. Metrics are automatically exposed via endpoints like <code>/metrics</code> and can be exported to monitoring systems.</p>
<h3 id="99-what-is-the-micronaut-integration-test-library-and-how-does-it-help-with-testing">99. What is the Micronaut Integration Test library and how does it help with testing?</h3>
<p><strong>Answer:</strong> The Micronaut Integration Test library (<code>micronaut-test-core</code>) simplifies testing by providing the <code>@MicronautTest</code> annotation that manages application context lifecycle. It automatically injects beans into test classes, starts embedded servers for HTTP tests, and supports mocking with <code>@MockBean</code>. The library offers specialized annotations like <code>@TransactionalTest</code> for database testing, and works with JUnit 5, Spock, and Kotest, maintaining fast startup times even in test environments.</p>
<h3 id="100-what-are-the-key-differences-in-programming-models-between-micronaut-and-spring-boot">100. What are the key differences in programming models between Micronaut and Spring Boot?</h3>
<p><strong>Answer:</strong> While Spring Boot uses runtime reflection and proxies, Micronaut uses compile-time processing, resulting in faster startup and lower memory usage. Spring Boot relies on classpath scanning and runtime bean discovery, whereas Micronaut generates metadata during compilation. Spring uses runtime AOP proxies; Micronaut generates interceptors at compile time. Both support similar annotations, but Micronaut&#39;s programming model works better with GraalVM native image compilation.</p>




</body>
</html>